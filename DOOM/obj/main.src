; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_lut:
	DS	3
	SEGMENT DATA
_lookupTableSize:
	DW	0
	DB	0
_skip:
	DW	0
	DB	0
	SEGMENT CODE
_generateLookupTable:
	LD	HL,-9
	CALL	__frameset
	LD	BC,(IX+6)
	LD	(_lookupTableSize),BC
	LD	BC,(IX+9)
	LD	(_skip),BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(_lut),HL
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
	LD	HL,(_skip)
	LD	BC,(IX+-3)
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-6),HL	; spill
	LD	(IX+-9),HL	; spill
	LD	HL,(IX+-3)
	LD	BC,(_lut)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-9)	; unspill
	LD	(IY),HL
	LD	(IY+3),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_3:
	LD	BC,(IX+6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _generateLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;_lut                                STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_skip                               STATIC      3   variable
;_lookupTableSize                    STATIC      3   variable
;i                                     IX-3      3   variable
;ski                                   IX+9      3   parameter
;size                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


_lookupSqrt:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(_lookupTableSize)
	DEC	BC
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fcmp
	JP	M,L_6
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	JR	L_7
L_6:
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	HL,(_skip)
	CALL	__imuls
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(_lut)
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,BC
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_lut)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupSqrt ***************************
;Name                         Addr/Register   Size   Type
;_lut                                STATIC      3   variable
;_skip                               STATIC      3   variable
;_sqrt                               IMPORT  -----   function
;_lookupTableSize                    STATIC      3   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


_freeLookupTable:
	LD	BC,(_lut)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,0
	LD	(_lookupTableSize),BC
	RET	


;**************************** _freeLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTableSize                    STATIC      3   variable
;_lut                                STATIC      3   variable
;_free                               IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT DATA
_lineSpacing:
	DW	20
	DB	0
_focalLength:
	DF	5.0
_multiplier:
	DF	50.0
_fov:
	DF	1.57079637050629
	SEGMENT TEXT
_DISTANCE_FOG:
	DB	1
_RENDER_WIDTH:
	DW	100
	DB	0
_MAX_DISTANCE:
	DF	2.0
	SEGMENT DATA
_lookDirection:
	DF	0.0
	DF	1.0
_playerPosition:
	DF	0.0
	DF	0.0
	SEGMENT TEXT
_FACEARRAYMAXSIZE:
	DW	10
	DB	0
	SEGMENT BSS
_faceArray:
	DS	3
	SEGMENT DATA
_faceArrayCurrentSize:
	DW	0
	DB	0
_numberOfObjects:
	DW	0
	DB	0
	SEGMENT BSS
_objectArray:
	DS	3
_partial_redraw:
	DS	1
_key:
	DS	1
	SEGMENT STRSECT
L__5:
	DB	"Not Yet Implemented"
	DB	0
	SEGMENT DATA
_nyiError:
	DW24	L__5
	SEGMENT BSS
_akSprite_data:
	DS	3076
	SEGMENT DATA
_akSprite:
	DW24	_akSprite_data
	SEGMENT BSS
_enemy1Sprite_data:
	DS	347
	SEGMENT DATA
_enemy1Sprite:
	DW24	_enemy1Sprite_data
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <graphx.h>
;   10	#include <debug.h>
;   11	#include <keypadc.h>
;   12	#include <assert.h>
;   13	#include <compression.h>
;   14	#include "gfx/gfx_group.h"
;   15	#include "lookup_table.h"
;   16	#include "helpers.h"
;   17	typedef struct 
;   18	{
;   19		float origin[2];
;   20		float direction[2];
;   21	
;   22	}Ray;
;   23	typedef struct 
;   24	{
;   25		uint8_t r,g,b;
;   26	}Color;
;   27	typedef struct 
;   28	{
;   29		float point1[2];
;   30		float point2[2];
;   31		uint8_t color;
;   32	}Face;
;   33	typedef struct{
;   34		float position[2];
;   35		gfx_sprite_t * sprite;	
;   36	}Object;
;   37	
;   38	int lineSpacing = 20;
;   39	float focalLength = 5.0;
;   40	float multiplier = 50;
;   41	
;   42	float fov = M_PI/2;
;   43	const bool DISTANCE_FOG = true;
;   44	const int RENDER_WIDTH = 100;
;   45	const float MAX_DISTANCE = 2;
;   46	float lookDirection[] = {0,1};
;   47	float playerPosition[] = {0,0};
;   48	const int FACEARRAYMAXSIZE = 10;
;   49	Face * faceArray;
;   50	static int faceArrayCurrentSize = 0;
;   51	static int numberOfObjects = 0;
;   52	#define OBJECTARRAYMAXSIZE  10
;   53	
;   54	Object * objectArray;
;   55	
;   56	
;   57	void loadLevel();
;   58	void printTextSmall(const char *, uint8_t , uint8_t);
;   59	void printText(const char *, uint8_t, uint8_t );
;   60	Face * mallocAndGenerateFace(float , float, float, float , uint8_t);
;   61	void drawObjects();
;   62	void drawMap();
;   63	
;   64	Face *ClosestFace(Ray*, float*, bool*);
;   65	void GetRayToFaceIntersection(Ray*, Face*, float * ,bool *);
;   66	
;   67	char * gcvt(float, size_t, char *);
;   68	void begin();
;   69	void end();
;   70	void step();
;   71	void draw();
;   72	bool partial_redraw;
;   73	kb_key_t key;
;   74	
;   75	
;   76	
;   77	char * nyiError = "Not Yet Implemented";
;   78	//gfx_sprite_t * akSprite;
;   79	gfx_UninitedSprite(akSprite, doomak2_width,doomak2_height);
;   80	gfx_UninitedSprite(enemy1Sprite, enemy1_width, enemy1_height);
	SEGMENT CODE
;   81	void main() {
_main:
	LD	HL,-24
	CALL	__frameset
;   82		
;   83		int i;
;   84		Ray * testRay = malloc(sizeof(Ray));
	LD	BC,16
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;   85		Face * testFace;
;   86		Face * testFace2;	
;   87		Face * testFace3;
;   88		Face * testFace4;
;   89		
;   90		float  * destination  = calloc(2 , sizeof(float));
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(IX+-21),HL
;   91		//float destination[2];
;   92		bool  hit = false;
;   93		faceArray = calloc(FACEARRAYMAXSIZE ,sizeof(Face));
	LD	BC,17
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(_faceArray),HL
;   94		testRay->origin[0] = 0;
	LD	IY,(IX+-6)
	LD	BC,0
	LD	(IY+0),BC
	LD	(IY+3),0
;   95		testRay->origin[1] = -1;
	LEA	HL,IY+4
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;   96		testRay->direction[0] = 0;
	LEA	BC,IY+8
	LD	(IX+-24),BC
	LD	BC,0
	LD	(IY+8),BC
	LD	(IY+11),0
;   97		testRay->direction[1] = 1;
	LD	IY,(IX+-24)
;   98		testFace = mallocAndGenerateFace(-5,6,5,6, 65);
	LD	BC,65
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	LEA	HL,IY+4
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),63
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-9),HL
;   99		testFace2 = mallocAndGenerateFace(-5,-5,5,-5,12);
	LD	BC,12
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	C,64
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-12),HL
;  100		testFace3 = mallocAndGenerateFace(-7,7,-7,-7,02);
	LD	BC,2
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	DE,14680064
	PUSH	DE
	PUSH	BC
	LD	C,64
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	LD	BC,14680064
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-15),HL
;  101		testFace4 = mallocAndGenerateFace(4,-9,8,2,196);
	LD	BC,196
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	C,65
	LD	DE,0
	PUSH	DE
	PUSH	BC
	LD	C,193
	PUSH	DE
	PUSH	BC
	LD	C,64
	LD	DE,1048576
	PUSH	DE
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-18),HL
;  102		faceArray[0] = *testFace;
	LD	DE,(_faceArray)
	LD	HL,(IX+-9)
	LD	BC,17
	LDIR	
;  103		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  104		faceArray[1] = *testFace2;
	LD	IY,(_faceArray)
	LEA	DE,IY+17
	LD	HL,(IX+-12)
	LD	BC,17
	LDIR	
;  105		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  106		faceArray[2] = *testFace3;
	LD	IY,(_faceArray)
	LEA	DE,IY+34
	LD	HL,(IX+-15)
	LD	BC,17
	LDIR	
;  107		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  108		faceArray[3] = *testFace4;
	LD	IY,(_faceArray)
	LEA	DE,IY+51
	LD	HL,(IX+-18)
	LD	BC,17
	LDIR	
;  109		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  110		//generateLookupTable(1000, 1);
;  111	
;  112	    loadLevel();
	CALL	_loadLevel
;  113		begin(); // No rendering allowed!
	CALL	_begin
;  114		
;  115	
;  116		
;  117		//sets up NYI error message
;  118		for (i = 0; i < 20; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_16
L_14:
;  119		{
;  120			os_AppErr1[i] =nyiError[i];
	LD	BC,(IX+-3)
	LD	HL,(_nyiError)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,13641129
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  121			
;  122		}
L_16:
	LD	BC,20
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;  123		
;  124		
;  125		//allocates and decompresses gun sprite
;  126		akSprite = gfx_MallocSprite(doomak2_width,doomak2_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,58
	PUSH	BC
	LD	BC,53
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_akSprite),HL
;  127		zx7_Decompress(akSprite, doomak2_compressed);
	LD	BC,_doomak2_compressed
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  128		
;  129	    gfx_Begin();
	CALL	_gfx_Begin
;  130	    gfx_SetDrawBuffer(); // Draw to the buffer to avoid rendering artifats
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  131		
;  132		kb_Scan();
	CALL	_kb_Scan
;  133		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  134			
;  135	    while (kb_Data[1] !=kb_2nd) { 
	JR	L_20
L_21:
;  136			step();// No rendering allowed in step!
	CALL	_step
;  137	        if (partial_redraw) // Only want to redraw part of the previous frame?
	LD	A,(_partial_redraw)
	OR	A,A
	JR	Z,L_19
;  138	            gfx_BlitScreen(); // Copy previous frame as a base for this frame
	LD	BC,0
	PUSH	BC
	CALL	_gfx_Blit
	POP	BC
L_19:
;  139	        draw(); // As little non-rendering logic as possible
	CALL	_draw
;  140	        gfx_SwapDraw(); // Queue the buffered frame to be displayed
	CALL	_gfx_SwapDraw
;  141	    }
L_20:
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_21
;  142	
;  143	    gfx_End();
	CALL	_gfx_End
;  144	    end();
	CALL	_end
;  145		
;  146		
;  147		os_ClrHome();
	LD	BC,_asm_ClrLCD
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_HomeUp
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_DrawStatusBar
	PUSH	BC
	CALL	__OS
	POP	BC
;  148		
;  149		
;  150		while (!os_GetCSC());
L_26:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_26
;  151		free(destination);
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_free
	POP	BC
;  152		free(testFace);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  153		free(testFace2);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  154		free(testFace3);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_free
	POP	BC
;  155		free(testRay);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  156		free(faceArray);
	LD	BC,(_faceArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  157		free(akSprite);
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_free
	POP	BC
;  158		//freeLookupTable();
;  159	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_asm_DrawStatusBar                  IMPORT  -----   function
;_asm_HomeUp                         IMPORT  -----   function
;_asm_ClrLCD                         IMPORT  -----   function
;__OS                                IMPORT  -----   function
;_end                                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_draw                               IMPORT  -----   function
;_gfx_Blit                           IMPORT  -----   function
;_partial_redraw                     STATIC      1   variable
;_step                               IMPORT  -----   function
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_doomak2_compressed                 IMPORT   1819   variable
;_zx7_Decompress                     IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_nyiError                           STATIC      3   variable
;_begin                              IMPORT  -----   function
;_loadLevel                          IMPORT  -----   function
;_faceArrayCurrentSize               STATIC      3   variable
;_mallocAndGenerateFace              IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_calloc                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;destination                          IX-21      3   variable
;testFace4                            IX-18      3   variable
;testFace3                            IX-15      3   variable
;testFace2                            IX-12      3   variable
;testFace                              IX-9      3   variable
;testRay                               IX-6      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


;  160	
;  161	/* Put other functions here */
;  162	void begin() {	
_begin:
;  163			gfx_SetTransparentColor(gfx_group_transparent_color_index);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  164		
;  165	}
	RET	


;**************************** _begin ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetTransparentColor            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  166	
;  167	void end() {
_end:
;  168	    /* Implement me! */
;  169	}
	RET	


;**************************** _end ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT BSS
_movementRay:
	DS	16
;  170	Ray movementRay;
	SEGMENT CODE
;  171	void step() {
_step:
	LD	HL,-56
	CALL	__frameset
;  172	  	float distanceFromCam;
;  173		  bool hit;
;  174		movementRay.origin[0] = playerPosition[0];
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
;  175		movementRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-47),HL	; spill
	LD	(_movementRay),BC
	LD	(_movementRay+3),A
	LD	HL,_movementRay+4
	LD	(IX+-44),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+-44)	; unspill
	LD	(IX+-50),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-50)	; unspill
	LD	(IX+-53),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-53)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-56)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	A,(HL)
	LD	HL,(IX+-56)	; unspill
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  176		//keypad input
;  177		kb_Scan();
	CALL	_kb_Scan
;  178		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  179		//back
;  180		 if (kb_Data[4] & kb_2) {
	LD	A,(16056344)
	AND	A,2
	JR	Z,L_38
;  181			 	movementRay.direction[0] =  -lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-20),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(_movementRay+8),BC
;  182				movementRay.direction[1] =  -lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(_movementRay+11),A
	LD	(IX+-17),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	IY,(IX+-20)
;  183				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  184				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_33
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_38
L_33:
	OR	A,A
;  185				{
;  186	           		playerPosition[0] = playerPosition[0] + lookDirection[0] * -0.5;
	SBC	HL,HL
	LD	E,191
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  187					playerPosition[1] = playerPosition[1] + lookDirection[1] * -0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-23),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,191
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-23)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  188				}
;  189				
;  190	        } 
L_38:
;  191			//forward
;  192	        if (kb_Data[4] & kb_8) {
	LD	A,(16056344)
	AND	A,8
	JR	Z,L_42
;  193				movementRay.direction[0] =  lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-26),BC
	LD	HL,BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  194				movementRay.direction[1] =  lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(HL),A
	LD	(IX+-8),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-26)
;  195				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	INC	HL
	INC	HL
	LD	DE,_movementRay
	PUSH	DE
	INC	HL
	LD	A,(HL)
	LEA	HL,IY+4
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  196				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_42
L_36:
	OR	A,A
;  197				{
;  198	            	playerPosition[0] = playerPosition[0] + lookDirection[0] * 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  199					playerPosition[1] = playerPosition[1] + lookDirection[1] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-29),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-29)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  200				}
;  201				
;  202	        } 
L_42:
;  203			//left
;  204	        if (kb_Data[3] & kb_4) {
	LD	A,(16056342)
	AND	A,4
	JR	Z,L_46
;  205				movementRay.direction[0] =  -lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-32),BC
	LD	(IX+-11),DE
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fneg
	LD	IY,(IX+-32)
	LD	(IY),BC
	LD	(IY+3),A
;  206				movementRay.direction[1] =  lookDirection[0];
;  207				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LEA	HL,IY+4
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	LD	BC,_movementRay
	PUSH	BC
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  208				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_40
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_46
L_40:
;  209				{
;  210	            	playerPosition[0] = playerPosition[0] - lookDirection[1] * 0.5;
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fsub
	LD	(_playerPosition),BC
;  211					playerPosition[1] = playerPosition[1] + lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-35),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-35)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  212				}
;  213	        } 
L_46:
;  214			//right
;  215	        if (kb_Data[5] & kb_6) {
	LD	A,(16056346)
	AND	A,4
	JR	Z,L_48
;  216				movementRay.direction[0] =  lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-38),BC
	LD	(IX+-14),DE
	LD	HL,(IX+-14)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  217				movementRay.direction[1] =  -lookDirection[0];
	LD	IY,(IX+-38)
;  218				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  219				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_44
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_48
L_44:
;  220				{
;  221	            	playerPosition[0] = playerPosition[0] + lookDirection[1] * 0.5;
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  222					playerPosition[1] = playerPosition[1] - lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-41),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-41)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IY),BC
	LD	(IY+3),A
;  223				}
;  224				
;  225	        } 
L_48:
;  226			if (kb_Data[3] & kb_7)
	LD	A,(16056342)
	AND	A,8
	JR	Z,L_50
;  227			{
;  228				rotateVector(&lookDirection, 0.2);
	LD	C,62
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  229			}
L_50:
;  230			if (kb_Data[5] & kb_9)
	LD	A,(16056346)
	AND	A,8
	JR	Z,L_52
;  231			{
;  232				rotateVector(&lookDirection, -0.2);
	LD	C,190
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  233			}
L_52:
;  234			if (kb_Data[7] & kb_Up)
	LD	A,(16056350)
	AND	A,8
	JR	Z,L_54
;  235			{
;  236				fov+= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fadd
	LD	(_fov),BC
	LD	(_fov+3),A
;  237			}
L_54:
;  238			if (kb_Data[7] & kb_Down)
	LD	A,(16056350)
	AND	A,1
	JR	Z,L_57
;  239			{
;  240				fov-= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fsub
	LD	(_fov),BC
	LD	(_fov+3),A
;  241			}
L_57:
;  242			if (kb_Data[7] & kb_Left)
	LD	A,(16056350)
	AND	A,2
	JR	Z,L_61
;  243			{
;  244				lineSpacing++;
	LD	BC,(_lineSpacing)
	INC	BC
	LD	(_lineSpacing),BC
;  245			}
L_61:
;  246			if (kb_Data[7] & kb_Right)
	LD	A,(16056350)
	AND	A,4
	JR	Z,L_63
;  247			{
;  248				if (lineSpacing > 1)
	LD	BC,(_lineSpacing)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JP	P,L_63
;  249				{
;  250					lineSpacing--;
	LD	BC,(_lineSpacing)
	DEC	BC
	LD	(_lineSpacing),BC
;  251				}
;  252			}
L_63:
;  253			if (kb_Data[6] & kb_Add)
	LD	A,(16056348)
	AND	A,2
	JR	Z,L_66
;  254			{
;  255				multiplier+= 5;
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fadd
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  256			}
L_66:
;  257			if (kb_Data[6] & kb_Sub)
	LD	A,(16056348)
	AND	A,4
	JR	Z,L_68
;  258			{
;  259				if (multiplier > 5)
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fcmp
	JP	P,L_68
;  260				{
;  261					multiplier-= 5;
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fsub
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  262				}
;  263			}
L_68:
;  264			if (kb_Data[6] & kb_Mul)
	LD	A,(16056348)
	AND	A,8
	JR	Z,L_71
	OR	A,A
;  265			{
;  266				focalLength += 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fadd
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  267			}
L_71:
;  268			if (kb_Data[6] & kb_Div)
	LD	A,(16056348)
	AND	A,16
	JR	Z,L_72
	OR	A,A
;  269			{
;  270				if (focalLength > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fcmp
	JP	P,L_72
	OR	A,A
;  271				{
;  272					focalLength -= 0.5;
	SBC	HL,HL
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fsub
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  273				}
;  274			}
;  275	}
L_72:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _step ***************************
;Name                         Addr/Register   Size   Type
;_focalLength                        STATIC      4   variable
;_multiplier                         STATIC      4   variable
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_movementRay                        STATIC     16   variable
;_playerPosition                     STATIC      8   variable
;G_0                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;G_2                                  IX-11      3   variable
;G_1                                   IX-8      3   variable
;distanceFromCam                       IX-5      4   variable
;hit                                   IX-1      1   variable


; Stack Frame Size: 62 (bytes)
;       Spill Code: -1 (instruction)


;  276	
;  277	void draw() {
_draw:
	LD	HL,-61
	CALL	__frameset
;  278		int row = LCD_WIDTH/2;
;  279		int fillSpacing = 0;
;  280		int temp = 0;
;  281		float closeDist = -1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,191
	LD	(IX+-8),A
;  282		float fardist = 2;
;  283		float res[2];
;  284		char buf[10];
;  285		bool hmm = false;
	LD	(IX+-7),0
;  286		Face * hit ;
;  287		Ray  lookRay ;
;  288		float newClose;
;  289		float angleFromCenter = 0;
;  290		//145,156,255,221,205,190, or 165
;  291		gfx_FillScreen(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  292		
;  293		lookRay.direction[0] = lookDirection[0];
	LEA	BC,IX+-39
	LD	(IX+-53),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(IX+-39),BC
;  294		lookRay.direction[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-36),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LEA	IY,IX+-35
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+3),A
;  295		lookRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-47
	LD	(IX+-50),BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(IX+-47),BC
;  296		lookRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-44),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	IY,(IX+-50)
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
;  297		//rotate the ray to the very left in preparation for spinning it around
;  298		rotateVector(&lookRay.direction, fov/2);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+-53)
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
;  299		angleFromCenter = fov/2;
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  300		
;  301		//loop for each vertical line
;  302		
;  303		for (row = 0; row <LCD_WIDTH; row+= lineSpacing){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_83
L_81:
;  304		
;  305			//rotate ray by a small amount and then cast again
;  306			rotateVector(&(lookRay.direction), -((float)fov / LCD_WIDTH) * lineSpacing);
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-60),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-61),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-60)
	LD	A,(IX+-61)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-39
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  307			angleFromCenter += -((float)fov / LCD_WIDTH) * lineSpacing;
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-56),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-57),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-56)
	LD	A,(IX+-57)
	CALL	__fmul
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	CALL	__fadd
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  308			hit = ClosestFace(&lookRay, &closeDist, &hmm);
	PEA	IX+-7
	PEA	IX+-11
	PEA	IX+-47
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  309			
;  310			//if hit
;  311			if (hmm && hit != 0)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_82
	LD	HL,(IX+-17)
	CALL	__icmpzero
	JR	Z,L_82
;  312			{
;  313				
;  314				gfx_SetColor(hit->color);
	LD	IY,(IX+-17)
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  315				closeDist = closeDist * fastCos(angleFromCenter);
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
;  316				temp =(focalLength/closeDist) * multiplier;
	LD	HL,BC
	LD	BC,(_focalLength)
	LD	E,(IX+-8)
	LD	A,(_focalLength+3)
	CALL	__fdiv
	LD	H,A
	LD	A,(_multiplier+3)
	LD	E,A
	LD	A,H
	LD	HL,(_multiplier)
	CALL	__fmul
	CALL	__ftol
;  317				if (temp < 0)
	LD	HL,BC
	CALL	__icmpzero
	LD	(IX+-6),BC
	JP	P,L_76
;  318				{
;  319					temp = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  320				}
L_76:
;  321				if (temp > LCD_HEIGHT/2 -1)
	LD	BC,(IX+-6)
	LD	HL,119
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  322				{
;  323					temp = LCD_HEIGHT/2 -1;
	LD	BC,119
	LD	(IX+-6),BC
;  324				}
L_77:
;  325				/*
;  326					for (fillSpacing = 1; fillSpacing < lineSpacing && fillSpacing + row < LCD_WIDTH; fillSpacing++)
;  327					{
;  328						gfx_Line_NoClip(row+ fillSpacing, LCD_HEIGHT/2.0 + temp, row+ fillSpacing, LCD_HEIGHT/2.0 - temp);
;  329					}
;  330				*/
;  331				fillSpacing = lineSpacing;
	LD	BC,(_lineSpacing)
	LD	(IX+-14),BC
;  332				if (row + fillSpacing >= LCD_WIDTH)
	LD	HL,(IX+-3)
	ADD	HL,BC
	OR	A,A
	LD	BC,320
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  333				{
;  334					fillSpacing = LCD_WIDTH-row;
	LD	BC,(IX+-3)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	(IX+-14),HL
;  335				}
L_79:
;  336				
;  337				gfx_FillRectangle_NoClip(row,LCD_HEIGHT/2 - temp,fillSpacing, 2 * temp );
	LD	A,(IX+-6)
	ADD	A,A
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	A,120
	LD	BC,(IX+-14)
	PUSH	BC
	LD	B,(IX+-6)
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  338			}
;  339			
;  340			
;  341			
;  342		}
L_82:
	LD	BC,(IX+-3)
	LD	HL,(_lineSpacing)
	ADD	HL,BC
	LD	(IX+-3),HL
L_83:
	LD	BC,320
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_81
;  343			//draw position and rotation text
;  344			gcvt(playerPosition[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_playerPosition+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  345			gfx_SetTextFGColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  346			gfx_SetTextXY(0,0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  347			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  348			gcvt(playerPosition[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  349			gfx_SetTextXY(75,0);
	LD	BC,0
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  350			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  351			gcvt(lookDirection[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_lookDirection+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_lookDirection)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  352			gfx_SetTextXY(0,20);
	LD	BC,20
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  353			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  354			gcvt(lookDirection[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  355			gfx_SetTextXY(75,20);
	LD	BC,20
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  356			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  357			
;  358			//draw objects
;  359			drawObjects();
	CALL	_drawObjects
;  360			
;  361			//draw gun sprite
;  362			gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  363			gfx_ScaledTransparentSprite_NoClip(akSprite, (LCD_WIDTH /2) - 68 , LCD_HEIGHT - doomak2_height * 2, 2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	BC,124
	PUSH	BC
	LD	BC,92
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  364			
;  365			//draw crosshair
;  366			gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  367			gfx_Line_NoClip(LCD_WIDTH/2 - 2, LCD_HEIGHT/2, LCD_WIDTH/2 + 2, LCD_HEIGHT/2);
	LD	BC,120
	PUSH	BC
	LD	BC,162
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,158
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  368			gfx_Line_NoClip(LCD_WIDTH/2 , LCD_HEIGHT/2 - 2, LCD_WIDTH/2 , LCD_HEIGHT/2 + 2);
	LD	BC,122
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,118
	PUSH	BC
	LD	BC,160
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  369			
;  370	
;  371			//draw the overhead map
;  372			drawMap();
	CALL	_drawMap
;  373			
;  374	
;  375		
;  376	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _draw ***************************
;Name                         Addr/Register   Size   Type
;_drawMap                            IMPORT  -----   function
;_gfx_Line_NoClip                    IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_drawObjects                        IMPORT  -----   function
;_gfx_PrintString                    IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gcvt                               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_multiplier                         STATIC      4   variable
;_focalLength                        STATIC      4   variable
;_fastCos                            IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_lookDirection                      STATIC      8   variable
;_gfx_FillScreen                     IMPORT  -----   function
;lookRay                              IX-47     16   variable
;buf                                  IX-31     10   variable
;angleFromCenter                      IX-21      4   variable
;hit                                  IX-17      3   variable
;fillSpacing                          IX-14      3   variable
;closeDist                            IX-11      4   variable
;hmm                                   IX-7      1   variable
;temp                                  IX-6      3   variable
;row                                   IX-3      3   variable


; Stack Frame Size: 67 (bytes)
;       Spill Code: -1 (instruction)


;  377	Face *ClosestFace(Ray *ray, float *distance, bool * hitOrNot)
;  378	{
_ClosestFace:
	LD	HL,-26
	CALL	__frameset
;  379		float closestDist;
;  380		int i;
;  381		float hitpoint[2];
;  382		//float * hitpoint  = malloc(2 * sizeof(float));
;  383		float dist = 0;
	LD	BC,0
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  384		bool  didhit;
;  385		//pointer to the face in facearray that was hit
;  386		Face * outface = NULL;
	LD	(IX+-11),BC
;  387		*distance = -1;
	LD	HL,(IX+9)
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  388		closestDist = 999999;
	LD	BC,7611376
	LD	(IX+-7),BC
	LD	A,73
	LD	(IX+-4),A
;  389		*hitOrNot = false;
	LD	HL,(IX+12)
	LD	(HL),0
;  390		
;  391		//check if passed null pointers
;  392		if (ray == NULL || distance == NULL || hitOrNot == NULL)
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_97
L_88:
	OR	A,A
;  393		{
;  394			return outface;
	SBC	HL,HL
	JR	L_99
;  395		}
L_97:
;  396		
;  397		for (i = 0; i<faceArrayCurrentSize; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_96
L_94:
;  398		{
;  399			
;  400			GetRayToFaceIntersection(ray, &(faceArray[i]), &hitpoint, &didhit);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	(IX+-14),HL
	PEA	IX+-8
	PEA	IX+-26
	LD	BC,(_faceArray)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_GetRayToFaceIntersection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  401			
;  402			//if successfully hit something
;  403			if (didhit)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_93
;  404			{
;  405				
;  406				*hitOrNot = true;
	LD	HL,(IX+12)
;  407				dist = distanceBetween(ray->origin, hitpoint);
	PEA	IX+-26
	LD	(HL),1
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  408				//if closer than closest face so far, set face that its currently checking to be the closest face
;  409				if (dist < closestDist)
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	CALL	__fcmp
	JP	P,L_93
;  410				{
;  411					closestDist = dist;
	LD	BC,(IX+-18)
	LD	A,(IX+-15)
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  412					outface = &(faceArray[i]);
	LD	BC,(IX+-14)
	LD	HL,(_faceArray)
	ADD	HL,BC
	LD	(IX+-11),HL
;  413				}
;  414			}
L_93:
;  415			
;  416			//*distance = closestDist;
;  417			//if closest dist was changed
;  418			if (closestDist < 999999)
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,7611376
	LD	A,73
	CALL	__fcmp
	JP	P,L_95
;  419			{
;  420				
;  421				*hitOrNot = true;
	LD	HL,(IX+12)
	LD	(HL),1
;  422				*distance = closestDist;
	LD	HL,(IX+9)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  423				return outface;
	LD	HL,(IX+-11)
	JR	L_99
;  424			}
;  425		}
L_95:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_96:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
;  426		
;  427		return outface;
	LD	HL,(IX+-11)
;  428	}
L_99:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ClosestFace ***************************
;Name                         Addr/Register   Size   Type
;_faceArrayCurrentSize               STATIC      3   variable
;_distanceBetween                    IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_GetRayToFaceIntersection           IMPORT  -----   function
;hitpoint                             IX-26      8   variable
;dist                                 IX-18      4   variable
;G_4                                  IX-14      3   variable
;outface                              IX-11      3   variable
;didhit                                IX-8      1   variable
;closestDist                           IX-7      4   variable
;i                                     IX-3      3   variable
;hitOrNot                             IX+12      3   parameter
;distance                              IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


;  429	
;  430	void GetRayToFaceIntersection(Ray * ray, Face * face, float * result, bool * hit)
;  431	{
_GetRayToFaceIntersection:
	LD	HL,-72
	CALL	__frameset
;  432		float v1[2] = {0,0};
	LEA	DE,IX+-14
	LD	HL,_0temp100
	LD	BC,8
	LDIR	
;  433		float v2[2]= {0,0};
	LEA	DE,IX+-22
	LD	HL,_1temp101
	LD	BC,8
	LDIR	
;  434		float v3[2]= {0,0};
	LEA	DE,IX+-30
	LD	HL,_2temp102
	LD	BC,8
	LDIR	
;  435		float tOne = 0;
;  436		float tTwo = 0;
;  437		float dot = 0;
;  438		v1[0] =(ray->origin[0] - face->point1[0]);
	LD	IY,(IX+9)
	LEA	BC,IY+0
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-14),BC
	LD	(IX+-11),A
;  439		v1[1] = (ray->origin[1] - face->point1[1]);
	LD	IY,(IX+-6)
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-14
	LD	(IY+4),BC
	LD	(IY+7),A
;  440		v2[0] = (face->point2[0] - face->point1[0]);
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fsub
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  441		v2[1]= (face->point2[1] - face->point1[1]);
	LEA	BC,IY+12
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-22
	LD	(IY+4),BC
	LD	(IY+7),A
;  442		v3[0] = -(ray->direction[1]);
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	(IX+-30),BC
	LD	(IX+-27),A
;  443		v3[1] = (ray->direction[0]);
	LD	(IX+-45),BC	; spill
	LEA	HL,IX+-26
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	BC,(IY+8)
	LD	A,(IY+11)
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),BC
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
;  444		dot = (v2[0] * v3[0]) + (v2[1] * v3[1]);
	LD	(IX+-51),HL	; spill
	LEA	HL,IX+-18
	LD	(IX+-54),HL	; spill
	LD	HL,(IX+-51)	; unspill
	LEA	IY,IX+-30
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),A
	LD	HL,(IX+-45)	; unspill
	LD	E,(IX+-27)
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	CALL	__fmul
	LD	(IX+-71),BC
	LD	(IX+-72),A
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-51),HL	; spill
	LD	IY,(IX+-54)
	LD	HL,(IX+-51)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	A,(IX+-72)
	LD	HL,BC
	LD	BC,(IX+-71)
	CALL	__fadd
	LD	(IX+-38),BC
	LD	(IX+-35),A
;  445		
;  446		*hit = false;
	LD	HL,(IX+15)
	LD	(HL),0
;  447		if (abs(dot) < 0.000001)
	LD	A,(IX+-35)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8796093
	LD	A,53
	CALL	__fcmp
	JP	M,L_108
;  448		{
;  449			return;
;  450		}
;  451		tOne = ((v2[0] * v1[1]) - (v2[1] * v1[0])) / dot;
	LEA	IY,IX+-14
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fmul
	LD	(IX+-65),BC
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LEA	IY,IX+-22
	LD	BC,(IY+4)
	LD	(IX+-62),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-65)
	LD	A,(IX+-62)
	CALL	__fsub
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-34),BC
	LD	(IX+-31),A
;  452		tTwo = ((v1[0] * v3[0])+ (v1[1] * v3[1])) / dot;
	LEA	HL,IX+-10
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-30)
	LD	E,(IX+-27)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fmul
	LEA	IY,IX+-30
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-45),HL	; spill
	LD	IY,(IX+-61)
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-58)
	LD	A,(IX+-55)
	CALL	__fadd
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-42),BC
	LD	(IX+-39),A
;  453		
;  454		if (tOne>0.0 && (tTwo >=0.0 && tTwo <= 1.0))
	LD	BC,(IX+-34)
	LD	A,(IX+-31)
	OR	A,A
	SBC	HL,HL
	LD	E,0
	CALL	__fcmp
	JP	P,L_108
	LD	HL,(IX+-42)
	LD	E,(IX+-39)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_108
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-42)
	LD	A,(IX+-39)
	CALL	__fcmp
	JP	M,L_108
;  455		{
;  456			
;  457			*hit = true;
	LD	HL,(IX+15)
	LD	(HL),1
;  458			
;  459			//tOne is distance to point1
;  460			//multiply by normalized direction and add to origin to get point
;  461			(result)[0] = ray->origin[0] + (ray->direction[0] * tOne);
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	IY,(IX+6)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fmul
	LD	HL,BC
	LD	BC,(IY+0)
	LD	E,A
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY),BC
	LD	(IY+3),A
;  462			(result)[1] = ray->origin[1] + (ray->direction[1] * tOne);
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fmul
	LD	E,A
	LD	(IX+-45),BC	; spill
	LD	IY,(IX+-68)
	LD	HL,BC	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  463			
;  464		}
;  465		
;  466	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetRayToFaceIntersection ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;_2temp102                           STATIC      8   variable
;_1temp101                           STATIC      8   variable
;_0temp100                           STATIC      8   variable
;tTwo                                 IX-42      4   variable
;dot                                  IX-38      4   variable
;tOne                                 IX-34      4   variable
;v3                                   IX-30      8   variable
;v2                                   IX-22      8   variable
;v1                                   IX-14      8   variable
;hit                                  IX+15      3   parameter
;result                               IX+12      3   parameter
;face                                  IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: -4 (instruction)


	SEGMENT TEXT
_0temp100:
	DF	0.0
	DF	0.0
_1temp101:
	DF	0.0
	DF	0.0
_2temp102:
	DF	0.0
	DF	0.0
	SEGMENT CODE
;  467	
;  468	
;  469	#include <stdio.h>
;  470	
;  471	#define PSH(X) (*(buf++)=(X))
;  472	#define PSH1(X) (*(buf--)=(X))
;  473	#define PEEK() buf[-1]
;  474	#define POP() *(--buf) = '\0'
;  475	
;  476	#define PLUS 1
;  477	#define SPACE 2
;  478	
;  479	char * gcvt(double f, size_t ndigit, char * buf)
;  480	{
_gcvt:
	LD	HL,-44
	CALL	__frameset
;  481	  int i;
;  482		unsigned long z,k;
;  483	  int exp = 0;
;  484	  char *c = buf;
	LD	BC,(IX+15)
	LD	(IX+-14),BC
;  485	  double f2,t,scal;
;  486	  int   sign = 0;
	LD	BC,0
	LD	(IX+-21),BC
;  487	
;  488	  if((int)ndigit == -1)
	LD	HL,(IX+12)
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  489	    ndigit = 5;
	LD	BC,5
	LD	(IX+12),BC
L_111:
;  490	
;  491	  /* Unsigned long long only allows for 20 digits of precision
;  492	   * which is already more than double supports, so we limit the
;  493	   * digits to this.  long double might require an increase if it is ever
;  494	   * implemented.
;  495	   */
;  496	  if (ndigit > 20)
	LD	BC,(IX+12)
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	NC,L_114
;  497		  ndigit = 20;
	LD	BC,20
	LD	(IX+12),BC
L_114:
;  498	  
;  499	  if (f < 0.0) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_115
;  500	    sign = 1;
	LD	BC,1
	LD	(IX+-21),BC
;  501	    f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  502		 buf++;
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  503	  }
L_115:
;  504	
;  505	  scal = 1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,63
	LD	(IX+-8),A
;  506	  for (i=ndigit; i>0; i--)
	LD	BC,(IX+12)
	LD	(IX+-3),BC
	JR	L_119
L_117:
;  507		  scal *= 10;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+-11)
	LD	A,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
L_119:
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_117
;  508	  k = f + 0.1 / scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,13421773
	LD	A,61
	CALL	__fdiv
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  509	  f2 = f - k;
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-29),BC
	LD	(IX+-26),A
;  510	  if (!f) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	XOR	A,A
	LD	BC,0
	CALL	__fcmp
	JR	NZ,L_133
;  511	    PSH('0');
	LD	HL,(IX+15)
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  512	    if(ndigit > 0)
	LD	BC,(IX+12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_129
;  513	      PSH('.');
	LD	HL,(IX+15)
	LD	(HL),46
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
L_129:
;  514	    for (i=0;i<ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  515	      PSH('0');
	LD	BC,(IX+15)
	LD	(IX+-32),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_126
;  516	  	   PSH(0);
	LD	BC,(IX+15)
	LD	(IX+-35),BC
	LD	HL,BC
	LD	(HL),0
;  517	  	 return c;
	LD	HL,(IX+-14)
	JR	L_157
;  518	  }
L_133:
;  519	
;  520	  i = 1;
	LD	BC,1
	LD	(IX+-3),BC
;  521	  while (f >= 10.0) {
	JR	L_135
L_136:
;  522	  	f /= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  523	  	i++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  524	  }
L_135:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_136
;  525	
;  526	  buf += i + ndigit + 1; 	
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(IX+15),HL
;  527	
;  528	  PSH1(0);
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  529	
;  530	  if(ndigit > 0) {	
	OR	A,A
	LD	BC,(IX+12)
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_148
;  531		  t = f2 * scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,(IX+-29)
	LD	A,(IX+-26)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-22),A
	OR	A,A
;  532		 z = t + 0.5;
	SBC	HL,HL
	LD	E,63
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-18),BC
	LD	(IX+-15),A
;  533	    for (i = 0;i < ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_143
L_141:
;  534	    {
;  535	      PSH1('0'+ (z % 10));
	LD	BC,(IX+15)
	LD	(IX+-38),BC
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-38)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  536		   z /= 10;
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-18),HL
	LD	(IX+-15),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  537	    }
L_143:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_141
;  538	    PSH1('.');
	LD	BC,(IX+15)
	LD	(IX+-41),BC
	LD	HL,BC
	LD	(HL),46
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  539	  }
;  540	  else
	JR	L_150
L_148:
;  541	    PSH1(0);
	LD	HL,(IX+15)
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  542	
;  543	  do {
L_150:
;  544	    PSH1('0'+ (k % 10));
	LD	BC,(IX+15)
	LD	(IX+-44),BC
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-44)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  545	    k /= 10;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-7),HL
	LD	(IX+-4),E
;  546	  }while (k);
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__lcmpzero
	JR	NZ,L_150
;  547	
;  548	  if (sign)
	LD	HL,(IX+-21)
	CALL	__icmpzero
	JR	Z,L_156
;  549	    PSH1('-');
	LD	HL,(IX+15)
	LD	(HL),45
L_156:
;  550	  return c;
	LD	HL,(IX+-14)
;  551	}
L_157:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gcvt ***************************
;Name                         Addr/Register   Size   Type
;f2                                   IX-29      4   variable
;t                                    IX-25      4   variable
;sign                                 IX-21      3   variable
;z                                    IX-18      4   variable
;c                                    IX-14      3   variable
;scal                                 IX-11      4   variable
;k                                     IX-7      4   variable
;i                                     IX-3      3   variable
;buf                                  IX+15      3   parameter
;ndigit                               IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: -4 (instruction)


;  552	
;  553	 
;  554	 void drawMap()
;  555	 {
_drawMap:
	LD	HL,-44
	CALL	__frameset
;  556		 float lookview[2];
;  557		int face = 0;
;  558		float scale = 1.25;
;  559		lookview[0] = lookDirection[0];
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
;  560		lookview[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LEA	IY,IX+-11
;  561		//draw map box
;  562		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_gfx_SetColor
	POP	BC
;  563		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  564		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 50, 5);
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  565		gfx_Line_NoClip(LCD_WIDTH -50, 5, LCD_WIDTH - 50, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  566		gfx_Line_NoClip(LCD_WIDTH -50, 50, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  567	
;  568		//draw faces
;  569		for (face = 0; face < faceArrayCurrentSize; face++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_161
L_159:
;  570		{
;  571			gfx_SetColor(faceArray[face].color);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	IY,HL
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  572			gfx_Line_NoClip(faceArray[face].point1[0] * scale + LCD_WIDTH-25,  faceArray[face].point1[1]* -scale + 25,  faceArray[face].point2[0]* scale+ LCD_WIDTH-25,  faceArray[face].point2[1]* -scale + 25 );
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-20)
	LEA	BC,IY+8
	LD	(IX+-17),BC
	LEA	BC,IY+0
	LD	(IX+-14),BC
	LD	IY,(IX+-17)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	IY,(IX+-14)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  573		
;  574		}
L_161:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_159
;  575	
;  576		//draw player
;  577		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25 - 1,  playerPosition[1]* -scale +25,  playerPosition[0]* scale + LCD_WIDTH-25 + 1, playerPosition[1]* -scale +25);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-34),BC
	LD	(IX+-44),A
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,9699328
	LD	E,67
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-34)
	LD	A,(IX+-44)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13631488
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  578		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1]* -scale +25 -1,  playerPosition[0]* scale + LCD_WIDTH-25, playerPosition[1]* -scale +25 +1);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	(IX+-31),BC
	LD	(IX+-43),A
	LD	HL,13631488
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-31)
	LD	A,(IX+-43)
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  579		
;  580		//draw view
;  581		//
;  582		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
	OR	A,A
;  583		rotateVector(&lookview, fov/2);
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  584		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-27),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-28),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-28)
	LD	HL,(IX+-27)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-41),BC
	LD	(IX+-42),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-41)
	LD	A,(IX+-42)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-27)
	LD	A,(IX+-28)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  585		rotateVector(&lookview, -fov);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  586		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-23),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-24),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-24)
	LD	HL,(IX+-23)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-37),BC
	LD	(IX+-38),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-37)
	LD	A,(IX+-38)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-23)
	LD	A,(IX+-24)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  587		
;  588	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawMap ***************************
;Name                         Addr/Register   Size   Type
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_faceArrayCurrentSize               STATIC      3   variable
;_faceArray                          STATIC      3   variable
;_gfx_Line_NoClip                    IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;lookview                             IX-11      8   variable
;face                                  IX-3      3   variable


; Stack Frame Size: 50 (bytes)
;       Spill Code: -4 (instruction)


;  589	
;  590	void drawObjects()
;  591	{
_drawObjects:
	LD	HL,-77
	CALL	__frameset
;  592		
;  593		int num =0;
;  594		float dot;
;  595		float dist;
;  596		float distToFace;
;  597		bool hit;
;  598		int scale;
;  599		float angleFromCenter=0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  600		Ray testRay;
;  601		float toObject[2];
;  602		for (num = 0; num<numberOfObjects; num++)
	LD	(IX+-7),BC
	JR	L_171
L_169:
;  603		{
;  604			
;  605			toObject[0] = objectArray[num].position[0] - playerPosition[0];
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	IY,(IX+-46)
	LD	HL,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	E,A
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-20),BC
;  606			toObject[1] = objectArray[num].position[1] - playerPosition[1];
	LEA	BC,IX+-16
	LD	(IX+-17),A
	LD	(IX+-43),BC
	LEA	BC,IY+4
	LD	IY,_playerPosition
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	IY,(IX+-43)
	LD	(IY),BC
	LD	(IY+3),A
;  607			dot = (lookDirection[0] * toObject[0]) + (lookDirection[1] * toObject[1]);
	LD	BC,_lookDirection+4
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-72),BC
	LD	(IX+-73),A
;  608	
;  609			//get the angle of the sprite from the center 
;  610			angleFromCenter = -atan2((lookDirection[0]) *toObject[1] - (lookDirection[1]) * toObject[0], (lookDirection[0]) * toObject[0] + (lookDirection[1]) * toObject[1]);
	LD	A,(_lookDirection+3)
	LD	BC,(_lookDirection)
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	CALL	__fmul
	LD	E,(IX+-73)
	LD	HL,(IX+-72)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	A,(_lookDirection+3)
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	IY,(IX+-43)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(_lookDirection)
	CALL	__fmul
	LD	(IX+-76),BC
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	(IX+-77),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-76)
	LD	A,(IX+-77)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan2
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__fneg
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  611			
;  612			if (floatAbs(angleFromCenter) <= (fov/2))
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	(IX+-68),BC
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-69),A
	CALL	_floatAbs
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-68)
	LD	E,(IX+-69)
	CALL	__fcmp
	JP	M,L_170
;  613			{
;  614				//get distance to object
;  615				dist = (distanceBetween(&playerPosition, &objectArray[num].position));
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,_playerPosition
	PUSH	BC
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  616				//cast ray to nearest face and compare with distance to object
;  617				testRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-40
	LD	(IX+-52),BC
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  618				testRay.origin[1] = playerPosition[1];
	LD	IY,_playerPosition
	LEA	IY,IY+4
	LD	(IX+-61),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-61)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	LD	IY,(IX+-52)
	LEA	HL,IY+4
	LD	IY,(IX+-61)	; unspill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  619				testRay.direction[0] = toObject[0];
	LEA	BC,IX+-32
	LD	(IX+-49),BC
	LD	HL,BC
	LD	BC,(IX+-20)
	LD	A,(IX+-17)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  620				testRay.direction[1] = toObject[1];
	LEA	IY,IX+-16
	LD	(IX+-58),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-49)
;  621				ClosestFace(&testRay, &distToFace, &hit);
	PEA	IX+-8
	PEA	IX+-24
	PEA	IX+-40
	LEA	HL,IY+4
	LD	IY,(IX+-58)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  622				if (hit && dist >distToFace)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_167
	LD	HL,(IX+-24)
	LD	E,(IX+-21)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_170
;  623				{
;  624					//if the ray hit a face and that face is closer than the object, skip drawing it (it's obscured).
;  625					continue;
;  626				}
L_167:
;  627	
;  628				//change distance to the scale factor
;  629				dist =abs(1/((dist+3) *0.025)-2);
	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	HL,13421773
	LD	E,60
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fdiv
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
;  630				//limit dist to a minimum scale of 1
;  631				dist = max(dist,1);
	LD	C,63
	LD	B,0
	LD	(IX+-1),A
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  632				//set the color pallete
;  633				gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  634				//draw the scaled sprite.
;  635				gfx_ScaledTransparentSprite_NoClip(objectArray[num].sprite, (LCD_WIDTH/2) + (angleFromCenter *100 * fov) - (enemy1_width *dist)/2 ,LCD_HEIGHT/2 - (enemy1_height *dist)/2 ,dist,dist);
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	HL,12058624
	LD	E,65
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,15728640
	LD	A,66
	CALL	__fsub
	CALL	__ftol
	LD	HL,13107200
	LD	E,66
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fmul
	LD	H,A
	LD	A,(_fov+3)
	LD	E,A
	LD	A,H
	LD	HL,(_fov)
	CALL	__fmul
	LD	HL,2097152
	LD	E,67
	CALL	__fadd
	LD	(IX+-64),BC
	LD	(IX+-65),A
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	HL,7340032
	LD	E,65
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-64)
	LD	A,(IX+-65)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  636				
;  637			}
;  638		}
L_170:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_171:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_169
;  639		
;  640	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawObjects ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_max                                IMPORT  -----   function
;_abs                                IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_distanceBetween                    IMPORT  -----   function
;_floatAbs                           IMPORT  -----   function
;_fov                                STATIC      4   variable
;_atan2                              IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_playerPosition                     STATIC      8   variable
;_objectArray                        STATIC      3   variable
;testRay                              IX-40     16   variable
;distToFace                           IX-24      4   variable
;toObject                             IX-20      8   variable
;angleFromCenter                      IX-12      4   variable
;hit                                   IX-8      1   variable
;num                                   IX-7      3   variable
;dist                                  IX-4      4   variable


; Stack Frame Size: 83 (bytes)
;       Spill Code: -11 (instruction)


;  641	
;  642	
;  643	Face * mallocAndGenerateFace(float  point1x, float  point1y, float point2x, float point2y, uint8_t colorIndex)
;  644	{
_mallocAndGenerateFace:
	LD	HL,-6
	CALL	__frameset
;  645		Face * newFace = malloc(sizeof(Face));
	LD	BC,17
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;  646		newFace->point1[0] = point1x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+-6)
	LD	(IY+0),BC
	LD	(IY+3),A
;  647		newFace->point1[1] = point1y;
	LEA	HL,IY+4
	LD	BC,(IX+12)
	LD	A,(IX+15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  648		newFace->point2[0] = point2x;
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	BC,(IX+18)
	LD	A,(IX+21)
	LD	(IY+8),BC
	LD	(IY+11),A
;  649		newFace->point2[1] = point2y;
	LD	IY,(IX+-3)
	LEA	HL,IY+4
	LD	BC,(IX+24)
	LD	A,(IX+27)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  650		newFace->color = colorIndex;
	LD	A,(IX+30)
	LD	IY,(IX+-6)
	LD	(IY+16),A
;  651		return newFace;
	LD	HL,(IX+-6)
;  652	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mallocAndGenerateFace ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;newFace                               IX-6      3   variable
;colorIndex                           IX+30      1   parameter
;point2y                              IX+24      4   parameter
;point2x                              IX+18      4   parameter
;point1y                              IX+12      4   parameter
;point1x                               IX+6      4   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -11 (instruction)


;  653	
;  654	void loadLevel()
;  655	{
_loadLevel:
	LD	HL,-11
	CALL	__frameset
;  656		Object newObj;
;  657		numberOfObjects++;
	LD	BC,(_numberOfObjects)
	INC	BC
	LD	(_numberOfObjects),BC
;  658		//alloc object array
;  659		objectArray = malloc(sizeof(Object) * numberOfObjects);
	LD	HL,(_numberOfObjects)
	LD	A,11
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
;  660		//malloc sprite image
;  661		enemy1Sprite = gfx_MallocSprite(enemy1_width,enemy1_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	(_objectArray),HL
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_enemy1Sprite),HL
;  662		//decompress sprite image
;  663		zx7_Decompress(enemy1Sprite, enemy1_compressed);
	LD	BC,_enemy1_compressed
	PUSH	BC
	LD	BC,(_enemy1Sprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  664		newObj.sprite =  enemy1Sprite;
	LD	BC,(_enemy1Sprite)
	LD	(IX+-3),BC
;  665		
;  666		//set position
;  667		newObj.position[0] = -2;
	LD	BC,0
	LD	(IX+-11),BC
	LD	A,192
	LD	(IX+-8),A
;  668		newObj.position[1] = 2;
	LEA	IY,IX+-11
;  669		//add to array
;  670		objectArray[0] =newObj;
	LEA	HL,IX+-11
	LD	(IY+4),BC
	LD	(IY+7),64
	LD	DE,(_objectArray)
	LD	BC,11
	LDIR	
;  671		
;  672		
;  673	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadLevel ***************************
;Name                         Addr/Register   Size   Type
;_enemy1_compressed                  IMPORT    258   variable
;_zx7_Decompress                     IMPORT  -----   function
;_enemy1Sprite                       STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_objectArray                        STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_numberOfObjects                    STATIC      3   variable
;newObj                               IX-11     11   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: -11 (instruction)


;  674	
;  675	void unloadLevel()
;  676	{
_unloadLevel:
	LD	HL,-3
	CALL	__frameset
;  677		int j =0;
;  678		for (j=0;j<numberOfObjects;j++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_179
L_177:
;  679		{
;  680			free(objectArray[j].sprite);
	LD	HL,(IX+-3)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  681		}
L_179:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_177
;  682		free(objectArray);
	LD	BC,(_objectArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  683	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _unloadLevel ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_objectArray                        STATIC      3   variable
;_free                               IMPORT  -----   function
;j                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: -11 (instruction)


;  684	
;  685	void printText(const char *text, uint8_t xpos, uint8_t ypos) {
_printText:
	CALL	__frameset0
;  686	    os_SetCursorPos(ypos, xpos);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+12)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  687	    os_PutStrFull(text);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  688	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


;  689	
;  690	/* Draw small text at the given X/Y location */
;  691	void printTextSmall(const char *text, uint8_t xpos, uint8_t ypos) {
_printTextSmall:
	CALL	__frameset0
;  692	    os_FontSelect(0); // sets small font (1 == big, see docs)
	LD	BC,0
	PUSH	BC
	CALL	_os_FontSelect
	POP	BC
;  693	    os_FontDrawText(text, xpos, ypos);
	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_FontDrawText
	POP	BC
	POP	BC
	POP	BC
;  694	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printTextSmall ***************************
;Name                         Addr/Register   Size   Type
;_os_FontDrawText                    IMPORT  -----   function
;_os_FontSelect                      IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


	XREF _rotateVector:ROM
	XREF _distanceBetween:ROM
	XREF _fastCos:ROM
	XREF _floatAbs:ROM
	XREF _max:ROM
	XREF _gfx_group_pal:ROM
	XREF _enemy1_compressed:ROM
	XREF _doomak2_compressed:ROM
	XREF _zx7_Decompress:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_ScaledTransparentSprite_NoClip:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintString:ROM
	XREF _gfx_Blit:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_Line_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _calloc:ROM
	XREF _sqrt:ROM
	XREF _atan2:ROM
	XREF _asm_DrawStatusBar:ROM
	XREF _asm_ClrLCD:ROM
	XREF _asm_HomeUp:ROM
	XREF __OS:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_FontDrawText:ROM
	XREF _os_FontSelect:ROM
	XREF _os_SetCursorPos:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __lremu:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __imul_b:ROM
	XDEF _printTextSmall
	XDEF _printText
	XDEF _unloadLevel
	XDEF _loadLevel
	XDEF _mallocAndGenerateFace
	XDEF _drawObjects
	XDEF _drawMap
	XDEF _gcvt
	XDEF _GetRayToFaceIntersection
	XDEF _ClosestFace
	XDEF _draw
	XDEF _step
	XDEF _movementRay
	XDEF _end
	XDEF _begin
	XDEF _main
	XDEF _enemy1Sprite
	XDEF _enemy1Sprite_data
	XDEF _akSprite
	XDEF _akSprite_data
	XDEF _nyiError
	XDEF _key
	XDEF _partial_redraw
	XDEF _objectArray
	XDEF _faceArray
	XDEF _FACEARRAYMAXSIZE
	XDEF _playerPosition
	XDEF _lookDirection
	XDEF _MAX_DISTANCE
	XDEF _RENDER_WIDTH
	XDEF _DISTANCE_FOG
	XDEF _fov
	XDEF _multiplier
	XDEF _focalLength
	XDEF _lineSpacing
	XDEF _freeLookupTable
	XDEF _lookupSqrt
	XDEF _generateLookupTable
	XDEF _lut
	END
