; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_lut:
	DS	3
	SEGMENT DATA
_lookupTableSize:
	DW	0
	DB	0
_skip:
	DW	0
	DB	0
	SEGMENT CODE
_generateLookupTable:
	LD	HL,-9
	CALL	__frameset
	LD	BC,(IX+6)
	LD	(_lookupTableSize),BC
	LD	BC,(IX+9)
	LD	(_skip),BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(_lut),HL
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
	LD	HL,(_skip)
	LD	BC,(IX+-3)
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-6),HL	; spill
	LD	(IX+-9),HL	; spill
	LD	HL,(IX+-3)
	LD	BC,(_lut)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-9)	; unspill
	LD	(IY),HL
	LD	(IY+3),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_3:
	LD	BC,(IX+6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _generateLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;_lut                                STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_skip                               STATIC      3   variable
;_lookupTableSize                    STATIC      3   variable
;i                                     IX-3      3   variable
;ski                                   IX+9      3   parameter
;size                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


_lookupSqrt:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(_lookupTableSize)
	DEC	BC
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fcmp
	JP	M,L_6
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	JR	L_7
L_6:
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	HL,(_skip)
	CALL	__imuls
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(_lut)
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,BC
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_lut)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupSqrt ***************************
;Name                         Addr/Register   Size   Type
;_lut                                STATIC      3   variable
;_skip                               STATIC      3   variable
;_sqrt                               IMPORT  -----   function
;_lookupTableSize                    STATIC      3   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


_freeLookupTable:
	LD	BC,(_lut)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,0
	LD	(_lookupTableSize),BC
	RET	


;**************************** _freeLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTableSize                    STATIC      3   variable
;_lut                                STATIC      3   variable
;_free                               IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT DATA
_lineSpacing:
	DW	20
	DB	0
_focalLength:
	DF	5.0
_multiplier:
	DF	50.0
_fov:
	DF	1.57079637050629
	SEGMENT TEXT
_DISTANCE_FOG:
	DB	1
_RENDER_WIDTH:
	DW	100
	DB	0
_MAX_DISTANCE:
	DF	2.0
	SEGMENT DATA
_lookDirection:
	DF	0.0
	DF	1.0
_playerPosition:
	DF	0.0
	DF	0.0
	SEGMENT TEXT
_FACEARRAYMAXSIZE:
	DW	10
	DB	0
	SEGMENT BSS
_faceArray:
	DS	3
	SEGMENT DATA
_faceArrayCurrentSize:
	DW	0
	DB	0
_numberOfObjects:
	DW	0
	DB	0
	SEGMENT BSS
_objectArray:
	DS	3
_partial_redraw:
	DS	1
_key:
	DS	1
	SEGMENT STRSECT
L__5:
	DB	"Not Yet Implemented"
	DB	0
	SEGMENT DATA
_nyiError:
	DW24	L__5
	SEGMENT BSS
_akSprite_data:
	DS	3076
	SEGMENT DATA
_akSprite:
	DW24	_akSprite_data
	SEGMENT BSS
_enemy1Sprite_data:
	DS	347
	SEGMENT DATA
_enemy1Sprite:
	DW24	_enemy1Sprite_data
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <graphx.h>
;   10	#include <debug.h>
;   11	#include <keypadc.h>
;   12	#include <assert.h>
;   13	#include <compression.h>
;   14	#include "gfx/gfx_group.h"
;   15	#include "lookup_table.h"
;   16	#include "helpers.h"
;   17	
;   18	//A ray is defined by two float tuples, its origin and its direction.
;   19	typedef struct 
;   20	{
;   21		float origin[2];
;   22		float direction[2];
;   23	
;   24	}Ray;
;   25	//An rgb color.
;   26	//Unusued right now (AFAIK)
;   27	typedef struct 
;   28	{
;   29		uint8_t r,g,b;
;   30	}Color;
;   31	//A face is defined by two points and a color index.
;   32	typedef struct 
;   33	{
;   34		float point1[2];
;   35		float point2[2];
;   36		uint8_t color;
;   37	}Face;
;   38	//An object (or sprite) is defined by its position and a pointer to the graphics sprite that it uses.
;   39	typedef struct{
;   40		float position[2];
;   41		gfx_sprite_t * sprite;	
;   42	}Object;
;   43	
;   44	//The distance between cast rays
;   45	int lineSpacing = 20;
;   46	float focalLength = 5.0;
;   47	//Height of walls
;   48	float multiplier = 50;
;   49	
;   50	//The horizontal FOV, measured in radians. The default is 0.5pi, or 90 degrees
;   51	float fov = M_PI/2;
;   52	//Whether or not father faces are rendered darker than closer ones. Not yet implemented
;   53	const bool DISTANCE_FOG = true;
;   54	//Idk why I made this variable, and it isnt used.
;   55	const int RENDER_WIDTH = 100;
;   56	//Ditto.
;   57	const float MAX_DISTANCE = 2;
;   58	//The vector that defines what direction the camera is looking at. 
;   59	//Should be normalized, but its not the end of the world if it isn't.
;   60	float lookDirection[] = {0,1};
;   61	//The vector that defines where the camera is.
;   62	float playerPosition[] = {0,0};
;   63	
;   64	const int FACEARRAYMAXSIZE = 10;
;   65	//A pointer to the list of faces. It is dynamically allocated on the beginning of the program, with a size of FACEARRAYMAXSIZE
;   66	Face * faceArray;
;   67	//Current number of faces in the list of faces.
;   68	static int faceArrayCurrentSize = 0;
;   69	//Current number of objects in the list of objects.
;   70	static int numberOfObjects = 0;
;   71	
;   72	#define OBJECTARRAYMAXSIZE  10
;   73	
;   74	//A pointer to the list of objects. It is dynamically allocated on the beginning of the program, with a size of OBJECTARRAYMAXSIZE
;   75	Object * objectArray;
;   76	
;   77	
;   78	void loadLevel();
;   79	Face * mallocAndGenerateFace(float , float, float, float , uint8_t);
;   80	void drawObjects();
;   81	void drawMap();
;   82	
;   83	Face *ClosestFace(Ray*, float*, bool*);
;   84	void GetRayToFaceIntersection(Ray*, Face*, float * ,bool *);
;   85	
;   86	char * gcvt(double, size_t, char *);
;   87	void begin();
;   88	void end();
;   89	void step();
;   90	void draw();
;   91	bool partial_redraw;
;   92	kb_key_t key;
;   93	
;   94	
;   95	//The string displayed when the Not Yet Implemented error is thrown.
;   96	char * nyiError = "Not Yet Implemented";
;   97	//Creates sprites for enemy1 and the gun.
;   98	gfx_UninitedSprite(akSprite, doomak2_width,doomak2_height);
;   99	gfx_UninitedSprite(enemy1Sprite, enemy1_width, enemy1_height);
	SEGMENT CODE
;  100	void main() {
_main:
	LD	HL,-18
	CALL	__frameset
;  101		
;  102		int i;
;  103		Face * testFace;
;  104		Face * testFace2;	
;  105		Face * testFace3;
;  106		Face * testFace4;
;  107		
;  108		float  * destination  = calloc(2 , sizeof(float));
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(IX+-18),HL
;  109		bool  hit = false;
;  110		faceArray = calloc(FACEARRAYMAXSIZE ,sizeof(Face));
	LD	BC,17
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
;  111	
;  112		//create test walls
;  113		testFace = mallocAndGenerateFace(-5,6,5,6, 65);
	LD	BC,65
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	LD	(_faceArray),HL
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-6),HL
;  114		testFace2 = mallocAndGenerateFace(-5,-5,5,-5,12);
	LD	BC,12
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	C,64
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-9),HL
;  115		testFace3 = mallocAndGenerateFace(-7,7,-7,-7,02);
	LD	BC,2
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	DE,14680064
	PUSH	DE
	PUSH	BC
	LD	C,64
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	LD	BC,14680064
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-12),HL
;  116		testFace4 = mallocAndGenerateFace(4,-9,8,2,196);
	LD	BC,196
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	C,65
	LD	DE,0
	PUSH	DE
	PUSH	BC
	LD	C,193
	PUSH	DE
	PUSH	BC
	LD	C,64
	LD	DE,1048576
	PUSH	DE
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-15),HL
;  117		faceArray[0] = *testFace;
	LD	DE,(_faceArray)
	LD	HL,(IX+-6)
	LD	BC,17
	LDIR	
;  118		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  119		faceArray[1] = *testFace2;
	LD	IY,(_faceArray)
	LEA	DE,IY+17
	LD	HL,(IX+-9)
	LD	BC,17
	LDIR	
;  120		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  121		faceArray[2] = *testFace3;
	LD	IY,(_faceArray)
	LEA	DE,IY+34
	LD	HL,(IX+-12)
	LD	BC,17
	LDIR	
;  122		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  123		faceArray[3] = *testFace4;
	LD	IY,(_faceArray)
	LEA	DE,IY+51
	LD	HL,(IX+-15)
	LD	BC,17
	LDIR	
;  124		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  125	    loadLevel();
	CALL	_loadLevel
;  126		begin(); // No rendering allowed!
	CALL	_begin
;  127	
;  128		
;  129		//sets up not yet implemented error message
;  130		for (i = 0; i < 20; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_16
L_14:
;  131		{
;  132			os_AppErr1[i] =nyiError[i];
	LD	BC,(IX+-3)
	LD	HL,(_nyiError)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,13641129
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  133			
;  134		}
L_16:
	LD	BC,20
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;  135		
;  136		
;  137		//allocates and decompresses gun sprite
;  138		akSprite = gfx_MallocSprite(doomak2_width,doomak2_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,58
	PUSH	BC
	LD	BC,53
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_akSprite),HL
;  139		zx7_Decompress(akSprite, doomak2_compressed);
	LD	BC,_doomak2_compressed
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  140		
;  141	    gfx_Begin();
	CALL	_gfx_Begin
;  142	    gfx_SetDrawBuffer(); // Draw to the buffer to avoid rendering artifats
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  143		
;  144		
;  145		kb_Scan();
	CALL	_kb_Scan
;  146		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  147			
;  148		//runs until 2nd is pressed
;  149	    while (kb_Data[1] !=kb_2nd) { 
	JR	L_20
L_21:
;  150			step();// No rendering allowed in step!
	CALL	_step
;  151	        if (partial_redraw) // Only want to redraw part of the previous frame?
	LD	A,(_partial_redraw)
	OR	A,A
	JR	Z,L_19
;  152	            gfx_BlitScreen(); // Copy previous frame as a base for this frame
	LD	BC,0
	PUSH	BC
	CALL	_gfx_Blit
	POP	BC
L_19:
;  153	        draw(); // As little non-rendering logic as possible
	CALL	_draw
;  154	        gfx_SwapDraw(); // Queue the buffered frame to be displayed
	CALL	_gfx_SwapDraw
;  155	    }
L_20:
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_21
;  156	
;  157	    gfx_End();
	CALL	_gfx_End
;  158	    end();
	CALL	_end
;  159		
;  160		
;  161		os_ClrHome();
	LD	BC,_asm_ClrLCD
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_HomeUp
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_DrawStatusBar
	PUSH	BC
	CALL	__OS
	POP	BC
;  162		
;  163		
;  164		while (!os_GetCSC());
L_26:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_26
;  165		//free memory
;  166		free(destination);
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_free
	POP	BC
;  167		free(testFace);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  168		free(testFace2);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  169		free(testFace3);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  170		free(faceArray);
	LD	BC,(_faceArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  171		free(akSprite);
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_free
	POP	BC
;  172	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_asm_DrawStatusBar                  IMPORT  -----   function
;_asm_HomeUp                         IMPORT  -----   function
;_asm_ClrLCD                         IMPORT  -----   function
;__OS                                IMPORT  -----   function
;_end                                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_draw                               IMPORT  -----   function
;_gfx_Blit                           IMPORT  -----   function
;_partial_redraw                     STATIC      1   variable
;_step                               IMPORT  -----   function
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_doomak2_compressed                 IMPORT   1819   variable
;_zx7_Decompress                     IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_nyiError                           STATIC      3   variable
;_begin                              IMPORT  -----   function
;_loadLevel                          IMPORT  -----   function
;_faceArrayCurrentSize               STATIC      3   variable
;_mallocAndGenerateFace              IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_calloc                             IMPORT  -----   function
;destination                          IX-18      3   variable
;testFace4                            IX-15      3   variable
;testFace3                            IX-12      3   variable
;testFace2                             IX-9      3   variable
;testFace                              IX-6      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 24 (bytes)
;       Spill Code: -1 (instruction)


;  173	
;  174	/* Put other functions here */
;  175	void begin() {	
_begin:
;  176			gfx_SetTransparentColor(gfx_group_transparent_color_index);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  177		
;  178	}
	RET	


;**************************** _begin ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetTransparentColor            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  179	
;  180	void end() {
_end:
;  181	    /* Implement me! */
;  182	}
	RET	


;**************************** _end ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  183	
;  184	
;  185	
;  186	void step() {
_step:
	LD	HL,-72
	CALL	__frameset
;  187	  	float distanceFromCam;
;  188		bool hit;
;  189		Ray movementRay;
;  190		movementRay.origin[0] = playerPosition[0];
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
;  191		movementRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-63),HL	; spill
	LD	(IX+-33),BC
	LD	(IX+-30),A
	LEA	HL,IX+-29
	LD	(IX+-60),HL	; spill
	LD	HL,(IX+-63)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+-60)	; unspill
	LD	(IX+-66),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	(IX+-69),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-69)	; unspill
	LD	(IX+-72),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-72)	; unspill
	LD	(IX+-72),HL	; spill
	LD	HL,(IX+-63)	; unspill
	LD	A,(HL)
	LD	HL,(IX+-72)	; unspill
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  192		//keypad input
;  193		kb_Scan();
	CALL	_kb_Scan
;  194		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  195		
;  196		//back
;  197		 if (kb_Data[4] & kb_2) {
	LD	A,(16056344)
	AND	A,2
	JR	Z,L_38
;  198			 	movementRay.direction[0] =  -lookDirection[0];
	LEA	BC,IX+-25
	LD	(IX+-36),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(IX+-25),BC
;  199				movementRay.direction[1] =  -lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(IX+-22),A
	LD	(IX+-8),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	IY,(IX+-36)
;  200				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  201				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_33
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_38
L_33:
	OR	A,A
;  202				{
;  203	           		playerPosition[0] = playerPosition[0] + lookDirection[0] * -0.5;
	SBC	HL,HL
	LD	E,191
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  204					playerPosition[1] = playerPosition[1] + lookDirection[1] * -0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-39),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,191
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-39)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  205				}
;  206				
;  207	        } 
L_38:
;  208			//forward
;  209	    if (kb_Data[4] & kb_8) {
	LD	A,(16056344)
	AND	A,8
	JR	Z,L_42
;  210			movementRay.direction[0] =  lookDirection[0];
	LEA	BC,IX+-25
	LD	(IX+-42),BC
	LD	HL,BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  211			movementRay.direction[1] =  lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(HL),A
	LD	(IX+-11),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-42)
;  212			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LEA	HL,IY+4
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  213			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_42
L_36:
	OR	A,A
;  214			{
;  215	        	playerPosition[0] = playerPosition[0] + lookDirection[0] * 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  216				playerPosition[1] = playerPosition[1] + lookDirection[1] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-45),BC
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-45)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  217			}
;  218				
;  219	    } 
L_42:
;  220		//left
;  221	    if (kb_Data[3] & kb_4) {
	LD	A,(16056342)
	AND	A,4
	JR	Z,L_46
;  222			movementRay.direction[0] =  -lookDirection[1];
	LEA	BC,IX+-25
	LD	DE,_lookDirection+4
	LD	(IX+-48),BC
	LD	(IX+-14),DE
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fneg
	LD	IY,(IX+-48)
	LD	(IY),BC
	LD	(IY+3),A
;  223			movementRay.direction[1] =  lookDirection[0];
;  224			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	LEA	HL,IY+4
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  225			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_40
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_46
L_40:
;  226			{
;  227	           	playerPosition[0] = playerPosition[0] - lookDirection[1] * 0.5;
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fsub
	LD	(_playerPosition),BC
;  228				playerPosition[1] = playerPosition[1] + lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-51),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-51)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  229			}
;  230	    } 
L_46:
;  231		//right
;  232	    if (kb_Data[5] & kb_6) {
	LD	A,(16056346)
	AND	A,4
	JR	Z,L_48
;  233			movementRay.direction[0] =  lookDirection[1];
	LEA	BC,IX+-25
	LD	DE,_lookDirection+4
	LD	(IX+-54),BC
	LD	(IX+-17),DE
	LD	HL,(IX+-17)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	HL,(IX+-54)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  234			movementRay.direction[1] =  -lookDirection[0];
	LD	IY,(IX+-54)
;  235			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  236			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_44
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_48
L_44:
;  237			{
;  238	           	playerPosition[0] = playerPosition[0] + lookDirection[1] * 0.5;
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  239				playerPosition[1] = playerPosition[1] - lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-57),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-57)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IY),BC
	LD	(IY+3),A
;  240			}
;  241		} 
L_48:
;  242		//rotation
;  243		if (kb_Data[3] & kb_7)
	LD	A,(16056342)
	AND	A,8
	JR	Z,L_50
;  244		{
;  245			rotateVector(&lookDirection, 0.2);
	LD	C,62
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  246		}
L_50:
;  247		if (kb_Data[5] & kb_9)
	LD	A,(16056346)
	AND	A,8
	JR	Z,L_52
;  248		{
;  249			rotateVector(&lookDirection, -0.2);
	LD	C,190
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  250		}
L_52:
;  251		if (kb_Data[7] & kb_Up)
	LD	A,(16056350)
	AND	A,8
	JR	Z,L_54
;  252		{
;  253			fov+= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fadd
	LD	(_fov),BC
	LD	(_fov+3),A
;  254		}
L_54:
;  255		if (kb_Data[7] & kb_Down)
	LD	A,(16056350)
	AND	A,1
	JR	Z,L_57
;  256		{
;  257			fov-= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fsub
	LD	(_fov),BC
	LD	(_fov+3),A
;  258		}
L_57:
;  259		if (kb_Data[7] & kb_Left)
	LD	A,(16056350)
	AND	A,2
	JR	Z,L_61
;  260		{
;  261			lineSpacing++;
	LD	BC,(_lineSpacing)
	INC	BC
	LD	(_lineSpacing),BC
;  262		}
L_61:
;  263		if (kb_Data[7] & kb_Right)
	LD	A,(16056350)
	AND	A,4
	JR	Z,L_63
;  264		{
;  265			if (lineSpacing > 1)
	LD	BC,(_lineSpacing)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JP	P,L_63
;  266			{
;  267				lineSpacing--;
	LD	BC,(_lineSpacing)
	DEC	BC
	LD	(_lineSpacing),BC
;  268			}
;  269		}
L_63:
;  270		if (kb_Data[6] & kb_Add)
	LD	A,(16056348)
	AND	A,2
	JR	Z,L_66
;  271		{
;  272			multiplier+= 5;
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fadd
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  273		}
L_66:
;  274		if (kb_Data[6] & kb_Sub)
	LD	A,(16056348)
	AND	A,4
	JR	Z,L_68
;  275		{
;  276			if (multiplier > 5)
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fcmp
	JP	P,L_68
;  277			{
;  278				multiplier-= 5;
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fsub
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  279			}
;  280		}
L_68:
;  281		if (kb_Data[6] & kb_Mul)
	LD	A,(16056348)
	AND	A,8
	JR	Z,L_71
	OR	A,A
;  282		{
;  283			focalLength += 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fadd
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  284		}
L_71:
;  285		if (kb_Data[6] & kb_Div)
	LD	A,(16056348)
	AND	A,16
	JR	Z,L_72
	OR	A,A
;  286		{
;  287			if (focalLength > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fcmp
	JP	P,L_72
	OR	A,A
;  288			{
;  289				focalLength -= 0.5;
	SBC	HL,HL
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fsub
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  290			}
;  291		}
;  292	}
L_72:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _step ***************************
;Name                         Addr/Register   Size   Type
;_focalLength                        STATIC      4   variable
;_multiplier                         STATIC      4   variable
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;movementRay                          IX-33     16   variable
;G_3                                  IX-17      3   variable
;G_2                                  IX-14      3   variable
;G_1                                  IX-11      3   variable
;G_0                                   IX-8      3   variable
;distanceFromCam                       IX-5      4   variable
;hit                                   IX-1      1   variable


; Stack Frame Size: 78 (bytes)
;       Spill Code: -1 (instruction)


;  293	
;  294	//does the main drawing
;  295	void draw() {
_draw:
	LD	HL,-61
	CALL	__frameset
;  296		int row = LCD_WIDTH/2;
;  297		int fillSpacing = 0;
;  298		int temp = 0;
;  299		float closeDist = -1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,191
	LD	(IX+-8),A
;  300		float fardist = 2;
;  301		float res[2];
;  302		char buf[10];
;  303		bool hmm = false;
	LD	(IX+-7),0
;  304		Face * hit ;
;  305		Ray  lookRay ;
;  306		float newClose;
;  307		float angleFromCenter = 0;
;  308		
;  309		//clear the screen
;  310		gfx_FillScreen(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  311		
;  312		//center lookray
;  313		lookRay.direction[0] = lookDirection[0];
	LEA	BC,IX+-39
	LD	(IX+-53),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(IX+-39),BC
;  314		lookRay.direction[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-36),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LEA	IY,IX+-35
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+3),A
;  315		lookRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-47
	LD	(IX+-50),BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(IX+-47),BC
;  316		lookRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-44),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	IY,(IX+-50)
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
;  317		//rotate the ray to the very left in preparation for spinning it around
;  318		rotateVector(&lookRay.direction, fov/2);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+-53)
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
;  319		angleFromCenter = fov/2;
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  320		
;  321		//loop for each vertical line
;  322		
;  323		for (row = 0; row <LCD_WIDTH; row+= lineSpacing){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_83
L_81:
;  324		
;  325			//rotate ray by a small amount
;  326			rotateVector(&(lookRay.direction), -((float)fov / LCD_WIDTH) * lineSpacing);
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-60),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-61),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-60)
	LD	A,(IX+-61)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-39
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  327			angleFromCenter += -((float)fov / LCD_WIDTH) * lineSpacing;
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-56),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-57),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-56)
	LD	A,(IX+-57)
	CALL	__fmul
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	CALL	__fadd
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  328			//cast the ray
;  329			hit = ClosestFace(&lookRay, &closeDist, &hmm);
	PEA	IX+-7
	PEA	IX+-11
	PEA	IX+-47
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  330			
;  331			//if hit
;  332			if (hmm && hit != 0)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_82
	LD	HL,(IX+-17)
	CALL	__icmpzero
	JR	Z,L_82
;  333			{
;  334				
;  335				gfx_SetColor(hit->color);
	LD	IY,(IX+-17)
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  336				closeDist = closeDist * fastCos(angleFromCenter);
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
;  337				temp =(focalLength/closeDist) * multiplier;
	LD	HL,BC
	LD	BC,(_focalLength)
	LD	E,(IX+-8)
	LD	A,(_focalLength+3)
	CALL	__fdiv
	LD	H,A
	LD	A,(_multiplier+3)
	LD	E,A
	LD	A,H
	LD	HL,(_multiplier)
	CALL	__fmul
	CALL	__ftol
;  338				if (temp < 0)
	LD	HL,BC
	CALL	__icmpzero
	LD	(IX+-6),BC
	JP	P,L_76
;  339				{
;  340					temp = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  341				}
L_76:
;  342				if (temp > LCD_HEIGHT/2 -1)
	LD	BC,(IX+-6)
	LD	HL,119
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  343				{
;  344					temp = LCD_HEIGHT/2 -1;
	LD	BC,119
	LD	(IX+-6),BC
;  345				}
L_77:
;  346				
;  347				fillSpacing = lineSpacing;
	LD	BC,(_lineSpacing)
	LD	(IX+-14),BC
;  348				if (row + fillSpacing >= LCD_WIDTH)
	LD	HL,(IX+-3)
	ADD	HL,BC
	OR	A,A
	LD	BC,320
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  349				{
;  350					fillSpacing = LCD_WIDTH-row;
	LD	BC,(IX+-3)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	(IX+-14),HL
;  351				}
L_79:
;  352				
;  353				
;  354				gfx_FillRectangle_NoClip(row,LCD_HEIGHT/2 - temp,fillSpacing, 2 * temp );
	LD	A,(IX+-6)
	ADD	A,A
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	A,120
	LD	BC,(IX+-14)
	PUSH	BC
	LD	B,(IX+-6)
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  355			}
;  356			
;  357			
;  358			
;  359		}
L_82:
	LD	BC,(IX+-3)
	LD	HL,(_lineSpacing)
	ADD	HL,BC
	LD	(IX+-3),HL
L_83:
	LD	BC,320
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_81
;  360			//draw position and rotation text
;  361			gcvt(playerPosition[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_playerPosition+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  362			gfx_SetTextFGColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  363			gfx_SetTextXY(0,0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  364			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  365			gcvt(playerPosition[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  366			gfx_SetTextXY(75,0);
	LD	BC,0
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  367			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  368			gcvt(lookDirection[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_lookDirection+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_lookDirection)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  369			gfx_SetTextXY(0,20);
	LD	BC,20
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  370			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  371			gcvt(lookDirection[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  372			gfx_SetTextXY(75,20);
	LD	BC,20
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  373			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  374			
;  375			//draw objects
;  376			drawObjects();
	CALL	_drawObjects
;  377			
;  378			//draw gun sprite
;  379			gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  380			gfx_ScaledTransparentSprite_NoClip(akSprite, (LCD_WIDTH /2) - 68 , LCD_HEIGHT - doomak2_height * 2, 2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	BC,124
	PUSH	BC
	LD	BC,92
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  381			
;  382			//draw crosshair
;  383			gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  384			gfx_Line_NoClip(LCD_WIDTH/2 - 2, LCD_HEIGHT/2, LCD_WIDTH/2 + 2, LCD_HEIGHT/2);
	LD	BC,120
	PUSH	BC
	LD	BC,162
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,158
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  385			gfx_Line_NoClip(LCD_WIDTH/2 , LCD_HEIGHT/2 - 2, LCD_WIDTH/2 , LCD_HEIGHT/2 + 2);
	LD	BC,122
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,118
	PUSH	BC
	LD	BC,160
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  386			
;  387	
;  388			//draw the overhead map
;  389			drawMap();
	CALL	_drawMap
;  390			
;  391	
;  392		
;  393	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _draw ***************************
;Name                         Addr/Register   Size   Type
;_drawMap                            IMPORT  -----   function
;_gfx_Line_NoClip                    IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_drawObjects                        IMPORT  -----   function
;_gfx_PrintString                    IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gcvt                               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_multiplier                         STATIC      4   variable
;_focalLength                        STATIC      4   variable
;_fastCos                            IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_lookDirection                      STATIC      8   variable
;_gfx_FillScreen                     IMPORT  -----   function
;lookRay                              IX-47     16   variable
;buf                                  IX-31     10   variable
;angleFromCenter                      IX-21      4   variable
;hit                                  IX-17      3   variable
;fillSpacing                          IX-14      3   variable
;closeDist                            IX-11      4   variable
;hmm                                   IX-7      1   variable
;temp                                  IX-6      3   variable
;row                                   IX-3      3   variable


; Stack Frame Size: 67 (bytes)
;       Spill Code: -1 (instruction)


;  394	
;  395	//returns the closest face a ray hits, and sets the distance and whether or not the ray hit anything
;  396	Face *ClosestFace(Ray *ray, float *distance, bool * hitOrNot)
;  397	{
_ClosestFace:
	LD	HL,-26
	CALL	__frameset
;  398		float closestDist;
;  399		int i;
;  400		float hitpoint[2];
;  401		//float * hitpoint  = malloc(2 * sizeof(float));
;  402		float dist = 0;
	LD	BC,0
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  403		bool  didhit;
;  404		//pointer to the face in facearray that was hit
;  405		Face * outface = NULL;
	LD	(IX+-11),BC
;  406		*distance = -1;
	LD	HL,(IX+9)
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  407		closestDist = 999999;
	LD	BC,7611376
	LD	(IX+-7),BC
	LD	A,73
	LD	(IX+-4),A
;  408		*hitOrNot = false;
	LD	HL,(IX+12)
	LD	(HL),0
;  409		
;  410		//check if passed null pointers
;  411		if (ray == NULL || distance == NULL || hitOrNot == NULL)
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_97
L_88:
	OR	A,A
;  412		{
;  413			return outface;
	SBC	HL,HL
	JR	L_99
;  414		}
L_97:
;  415		
;  416		for (i = 0; i<faceArrayCurrentSize; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_96
L_94:
;  417		{
;  418			
;  419			GetRayToFaceIntersection(ray, &(faceArray[i]), &hitpoint, &didhit);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	(IX+-14),HL
	PEA	IX+-8
	PEA	IX+-26
	LD	BC,(_faceArray)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_GetRayToFaceIntersection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  420			
;  421			//if successfully hit something
;  422			if (didhit)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_93
;  423			{
;  424				
;  425				*hitOrNot = true;
	LD	HL,(IX+12)
;  426				dist = distanceBetween(ray->origin, hitpoint);
	PEA	IX+-26
	LD	(HL),1
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  427				//if closer than closest face so far, set face that its currently checking to be the closest face
;  428				if (dist < closestDist)
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	CALL	__fcmp
	JP	P,L_93
;  429				{
;  430					closestDist = dist;
	LD	BC,(IX+-18)
	LD	A,(IX+-15)
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  431					outface = &(faceArray[i]);
	LD	BC,(IX+-14)
	LD	HL,(_faceArray)
	ADD	HL,BC
	LD	(IX+-11),HL
;  432				}
;  433			}
L_93:
;  434			
;  435			//*distance = closestDist;
;  436			//if closest dist was changed
;  437			if (closestDist < 999999)
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,7611376
	LD	A,73
	CALL	__fcmp
	JP	P,L_95
;  438			{
;  439				
;  440				*hitOrNot = true;
	LD	HL,(IX+12)
	LD	(HL),1
;  441				*distance = closestDist;
	LD	HL,(IX+9)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  442				return outface;
	LD	HL,(IX+-11)
	JR	L_99
;  443			}
;  444		}
L_95:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_96:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
;  445		
;  446		return outface;
	LD	HL,(IX+-11)
;  447	}
L_99:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ClosestFace ***************************
;Name                         Addr/Register   Size   Type
;_faceArrayCurrentSize               STATIC      3   variable
;_distanceBetween                    IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_GetRayToFaceIntersection           IMPORT  -----   function
;hitpoint                             IX-26      8   variable
;dist                                 IX-18      4   variable
;G_4                                  IX-14      3   variable
;outface                              IX-11      3   variable
;didhit                                IX-8      1   variable
;closestDist                           IX-7      4   variable
;i                                     IX-3      3   variable
;hitOrNot                             IX+12      3   parameter
;distance                              IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


;  448	
;  449	//outputs whether or not a ray hit a certain face, and if so the distance
;  450	void GetRayToFaceIntersection(Ray * ray, Face * face, float * result, bool * hit)
;  451	{
_GetRayToFaceIntersection:
	LD	HL,-72
	CALL	__frameset
;  452		float v1[2] = {0,0};
	LEA	DE,IX+-14
	LD	HL,_0temp100
	LD	BC,8
	LDIR	
;  453		float v2[2]= {0,0};
	LEA	DE,IX+-22
	LD	HL,_1temp101
	LD	BC,8
	LDIR	
;  454		float v3[2]= {0,0};
	LEA	DE,IX+-30
	LD	HL,_2temp102
	LD	BC,8
	LDIR	
;  455		float tOne = 0;
;  456		float tTwo = 0;
;  457		float dot = 0;
;  458		v1[0] =(ray->origin[0] - face->point1[0]);
	LD	IY,(IX+9)
	LEA	BC,IY+0
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-14),BC
	LD	(IX+-11),A
;  459		v1[1] = (ray->origin[1] - face->point1[1]);
	LD	IY,(IX+-6)
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-14
	LD	(IY+4),BC
	LD	(IY+7),A
;  460		v2[0] = (face->point2[0] - face->point1[0]);
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fsub
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  461		v2[1]= (face->point2[1] - face->point1[1]);
	LEA	BC,IY+12
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-22
	LD	(IY+4),BC
	LD	(IY+7),A
;  462		v3[0] = -(ray->direction[1]);
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	(IX+-30),BC
	LD	(IX+-27),A
;  463		v3[1] = (ray->direction[0]);
	LD	(IX+-45),BC	; spill
	LEA	HL,IX+-26
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	BC,(IY+8)
	LD	A,(IY+11)
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),BC
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
;  464		dot = (v2[0] * v3[0]) + (v2[1] * v3[1]);
	LD	(IX+-51),HL	; spill
	LEA	HL,IX+-18
	LD	(IX+-54),HL	; spill
	LD	HL,(IX+-51)	; unspill
	LEA	IY,IX+-30
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),A
	LD	HL,(IX+-45)	; unspill
	LD	E,(IX+-27)
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	CALL	__fmul
	LD	(IX+-71),BC
	LD	(IX+-72),A
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-51),HL	; spill
	LD	IY,(IX+-54)
	LD	HL,(IX+-51)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	A,(IX+-72)
	LD	HL,BC
	LD	BC,(IX+-71)
	CALL	__fadd
	LD	(IX+-38),BC
	LD	(IX+-35),A
;  465		
;  466		*hit = false;
	LD	HL,(IX+15)
	LD	(HL),0
;  467		if (abs(dot) < 0.000001)
	LD	A,(IX+-35)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8796093
	LD	A,53
	CALL	__fcmp
	JP	M,L_108
;  468		{
;  469			return;
;  470		}
;  471		tOne = ((v2[0] * v1[1]) - (v2[1] * v1[0])) / dot;
	LEA	IY,IX+-14
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fmul
	LD	(IX+-65),BC
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LEA	IY,IX+-22
	LD	BC,(IY+4)
	LD	(IX+-62),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-65)
	LD	A,(IX+-62)
	CALL	__fsub
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-34),BC
	LD	(IX+-31),A
;  472		tTwo = ((v1[0] * v3[0])+ (v1[1] * v3[1])) / dot;
	LEA	HL,IX+-10
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-30)
	LD	E,(IX+-27)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fmul
	LEA	IY,IX+-30
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-45),HL	; spill
	LD	IY,(IX+-61)
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-58)
	LD	A,(IX+-55)
	CALL	__fadd
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-42),BC
	LD	(IX+-39),A
;  473		
;  474		if (tOne>0.0 && (tTwo >=0.0 && tTwo <= 1.0))
	LD	BC,(IX+-34)
	LD	A,(IX+-31)
	OR	A,A
	SBC	HL,HL
	LD	E,0
	CALL	__fcmp
	JP	P,L_108
	LD	HL,(IX+-42)
	LD	E,(IX+-39)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_108
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-42)
	LD	A,(IX+-39)
	CALL	__fcmp
	JP	M,L_108
;  475		{
;  476			
;  477			*hit = true;
	LD	HL,(IX+15)
	LD	(HL),1
;  478			
;  479			//tOne is distance to point1
;  480			//multiply by normalized direction and add to origin to get point
;  481			(result)[0] = ray->origin[0] + (ray->direction[0] * tOne);
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	IY,(IX+6)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fmul
	LD	HL,BC
	LD	BC,(IY+0)
	LD	E,A
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY),BC
	LD	(IY+3),A
;  482			(result)[1] = ray->origin[1] + (ray->direction[1] * tOne);
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fmul
	LD	E,A
	LD	(IX+-45),BC	; spill
	LD	IY,(IX+-68)
	LD	HL,BC	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  483			
;  484		}
;  485		
;  486	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetRayToFaceIntersection ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;_2temp102                           STATIC      8   variable
;_1temp101                           STATIC      8   variable
;_0temp100                           STATIC      8   variable
;tTwo                                 IX-42      4   variable
;dot                                  IX-38      4   variable
;tOne                                 IX-34      4   variable
;v3                                   IX-30      8   variable
;v2                                   IX-22      8   variable
;v1                                   IX-14      8   variable
;hit                                  IX+15      3   parameter
;result                               IX+12      3   parameter
;face                                  IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: -4 (instruction)


	SEGMENT TEXT
_0temp100:
	DF	0.0
	DF	0.0
_1temp101:
	DF	0.0
	DF	0.0
_2temp102:
	DF	0.0
	DF	0.0
	SEGMENT CODE
;  487	
;  488	
;  489	
;  490	//copied from online, changes a float into a string
;  491	#include <stdio.h>
;  492	#define PSH(X) (*(buf++)=(X))
;  493	#define PSH1(X) (*(buf--)=(X))
;  494	#define PEEK() buf[-1]
;  495	#define POP() *(--buf) = '\0'
;  496	#define PLUS 1
;  497	#define SPACE 2
;  498	char * gcvt(double f, size_t ndigit, char * buf)
;  499	{
_gcvt:
	LD	HL,-44
	CALL	__frameset
;  500	  int i;
;  501		unsigned long z,k;
;  502	  int exp = 0;
;  503	  char *c = buf;
	LD	BC,(IX+15)
	LD	(IX+-14),BC
;  504	  double f2,t,scal;
;  505	  int   sign = 0;
	LD	BC,0
	LD	(IX+-21),BC
;  506	
;  507	  if((int)ndigit == -1)
	LD	HL,(IX+12)
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  508	    ndigit = 5;
	LD	BC,5
	LD	(IX+12),BC
L_111:
;  509	
;  510	  /* Unsigned long long only allows for 20 digits of precision
;  511	   * which is already more than double supports, so we limit the
;  512	   * digits to this.  long double might require an increase if it is ever
;  513	   * implemented.
;  514	   */
;  515	  if (ndigit > 20)
	LD	BC,(IX+12)
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	NC,L_114
;  516		  ndigit = 20;
	LD	BC,20
	LD	(IX+12),BC
L_114:
;  517	  
;  518	  if (f < 0.0) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_115
;  519	    sign = 1;
	LD	BC,1
	LD	(IX+-21),BC
;  520	    f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  521		 buf++;
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  522	  }
L_115:
;  523	
;  524	  scal = 1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,63
	LD	(IX+-8),A
;  525	  for (i=ndigit; i>0; i--)
	LD	BC,(IX+12)
	LD	(IX+-3),BC
	JR	L_119
L_117:
;  526		  scal *= 10;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+-11)
	LD	A,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
L_119:
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_117
;  527	  k = f + 0.1 / scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,13421773
	LD	A,61
	CALL	__fdiv
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  528	  f2 = f - k;
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-29),BC
	LD	(IX+-26),A
;  529	  if (!f) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	XOR	A,A
	LD	BC,0
	CALL	__fcmp
	JR	NZ,L_133
;  530	    PSH('0');
	LD	HL,(IX+15)
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  531	    if(ndigit > 0)
	LD	BC,(IX+12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_129
;  532	      PSH('.');
	LD	HL,(IX+15)
	LD	(HL),46
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
L_129:
;  533	    for (i=0;i<ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  534	      PSH('0');
	LD	BC,(IX+15)
	LD	(IX+-32),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_126
;  535	  	   PSH(0);
	LD	BC,(IX+15)
	LD	(IX+-35),BC
	LD	HL,BC
	LD	(HL),0
;  536	  	 return c;
	LD	HL,(IX+-14)
	JR	L_157
;  537	  }
L_133:
;  538	
;  539	  i = 1;
	LD	BC,1
	LD	(IX+-3),BC
;  540	  while (f >= 10.0) {
	JR	L_135
L_136:
;  541	  	f /= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  542	  	i++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  543	  }
L_135:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_136
;  544	
;  545	  buf += i + ndigit + 1; 	
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(IX+15),HL
;  546	
;  547	  PSH1(0);
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  548	
;  549	  if(ndigit > 0) {	
	OR	A,A
	LD	BC,(IX+12)
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_148
;  550		  t = f2 * scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,(IX+-29)
	LD	A,(IX+-26)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-22),A
	OR	A,A
;  551		 z = t + 0.5;
	SBC	HL,HL
	LD	E,63
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-18),BC
	LD	(IX+-15),A
;  552	    for (i = 0;i < ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_143
L_141:
;  553	    {
;  554	      PSH1('0'+ (z % 10));
	LD	BC,(IX+15)
	LD	(IX+-38),BC
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-38)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  555		   z /= 10;
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-18),HL
	LD	(IX+-15),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  556	    }
L_143:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_141
;  557	    PSH1('.');
	LD	BC,(IX+15)
	LD	(IX+-41),BC
	LD	HL,BC
	LD	(HL),46
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  558	  }
;  559	  else
	JR	L_150
L_148:
;  560	    PSH1(0);
	LD	HL,(IX+15)
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  561	
;  562	  do {
L_150:
;  563	    PSH1('0'+ (k % 10));
	LD	BC,(IX+15)
	LD	(IX+-44),BC
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-44)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  564	    k /= 10;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-7),HL
	LD	(IX+-4),E
;  565	  }while (k);
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__lcmpzero
	JR	NZ,L_150
;  566	
;  567	  if (sign)
	LD	HL,(IX+-21)
	CALL	__icmpzero
	JR	Z,L_156
;  568	    PSH1('-');
	LD	HL,(IX+15)
	LD	(HL),45
L_156:
;  569	  return c;
	LD	HL,(IX+-14)
;  570	}
L_157:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gcvt ***************************
;Name                         Addr/Register   Size   Type
;f2                                   IX-29      4   variable
;t                                    IX-25      4   variable
;sign                                 IX-21      3   variable
;z                                    IX-18      4   variable
;c                                    IX-14      3   variable
;scal                                 IX-11      4   variable
;k                                     IX-7      4   variable
;i                                     IX-3      3   variable
;buf                                  IX+15      3   parameter
;ndigit                               IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: -4 (instruction)


;  571	
;  572	 //draws the map in the top right corner
;  573	 void drawMap()
;  574	 {
_drawMap:
	LD	HL,-44
	CALL	__frameset
;  575		 float lookview[2];
;  576		int face = 0;
;  577		float scale = 1.25;
;  578		lookview[0] = lookDirection[0];
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
;  579		lookview[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LEA	IY,IX+-11
;  580		//draw map box
;  581		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_gfx_SetColor
	POP	BC
;  582		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  583		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 50, 5);
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  584		gfx_Line_NoClip(LCD_WIDTH -50, 5, LCD_WIDTH - 50, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  585		gfx_Line_NoClip(LCD_WIDTH -50, 50, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  586	
;  587		//draw faces
;  588		for (face = 0; face < faceArrayCurrentSize; face++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_161
L_159:
;  589		{
;  590			gfx_SetColor(faceArray[face].color);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	IY,HL
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  591			gfx_Line_NoClip(faceArray[face].point1[0] * scale + LCD_WIDTH-25,  faceArray[face].point1[1]* -scale + 25,  faceArray[face].point2[0]* scale+ LCD_WIDTH-25,  faceArray[face].point2[1]* -scale + 25 );
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-20)
	LEA	BC,IY+8
	LD	(IX+-17),BC
	LEA	BC,IY+0
	LD	(IX+-14),BC
	LD	IY,(IX+-17)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	IY,(IX+-14)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  592		
;  593		}
L_161:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_159
;  594	
;  595		//draw player
;  596		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25 - 1,  playerPosition[1]* -scale +25,  playerPosition[0]* scale + LCD_WIDTH-25 + 1, playerPosition[1]* -scale +25);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-34),BC
	LD	(IX+-44),A
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,9699328
	LD	E,67
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-34)
	LD	A,(IX+-44)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13631488
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  597		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1]* -scale +25 -1,  playerPosition[0]* scale + LCD_WIDTH-25, playerPosition[1]* -scale +25 +1);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	(IX+-31),BC
	LD	(IX+-43),A
	LD	HL,13631488
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-31)
	LD	A,(IX+-43)
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  598		
;  599		//draw view
;  600		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
	OR	A,A
;  601		rotateVector(&lookview, fov/2);
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  602		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-27),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-28),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-28)
	LD	HL,(IX+-27)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-41),BC
	LD	(IX+-42),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-41)
	LD	A,(IX+-42)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-27)
	LD	A,(IX+-28)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  603		rotateVector(&lookview, -fov);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  604		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-23),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-24),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-24)
	LD	HL,(IX+-23)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-37),BC
	LD	(IX+-38),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-37)
	LD	A,(IX+-38)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-23)
	LD	A,(IX+-24)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  605		
;  606	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawMap ***************************
;Name                         Addr/Register   Size   Type
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_faceArrayCurrentSize               STATIC      3   variable
;_faceArray                          STATIC      3   variable
;_gfx_Line_NoClip                    IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;lookview                             IX-11      8   variable
;face                                  IX-3      3   variable


; Stack Frame Size: 50 (bytes)
;       Spill Code: -4 (instruction)


;  607	
;  608	//draws the sprites on the screen (not the gun sprite)
;  609	void drawObjects()
;  610	{
_drawObjects:
	LD	HL,-77
	CALL	__frameset
;  611		
;  612		int num =0;
;  613		float dot;
;  614		float dist;
;  615		float distToFace;
;  616		bool hit;
;  617		int scale;
;  618		float angleFromCenter=0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  619		Ray testRay;
;  620		float toObject[2];
;  621		for (num = 0; num<numberOfObjects; num++)
	LD	(IX+-7),BC
	JR	L_171
L_169:
;  622		{
;  623			
;  624			toObject[0] = objectArray[num].position[0] - playerPosition[0];
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	IY,(IX+-46)
	LD	HL,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	E,A
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-20),BC
;  625			toObject[1] = objectArray[num].position[1] - playerPosition[1];
	LEA	BC,IX+-16
	LD	(IX+-17),A
	LD	(IX+-43),BC
	LEA	BC,IY+4
	LD	IY,_playerPosition
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	IY,(IX+-43)
	LD	(IY),BC
	LD	(IY+3),A
;  626			dot = (lookDirection[0] * toObject[0]) + (lookDirection[1] * toObject[1]);
	LD	BC,_lookDirection+4
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-72),BC
	LD	(IX+-73),A
;  627	
;  628			//get the angle of the sprite from the center 
;  629			angleFromCenter = -atan2((lookDirection[0]) *toObject[1] - (lookDirection[1]) * toObject[0], (lookDirection[0]) * toObject[0] + (lookDirection[1]) * toObject[1]);
	LD	A,(_lookDirection+3)
	LD	BC,(_lookDirection)
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	CALL	__fmul
	LD	E,(IX+-73)
	LD	HL,(IX+-72)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	A,(_lookDirection+3)
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	IY,(IX+-43)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(_lookDirection)
	CALL	__fmul
	LD	(IX+-76),BC
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	(IX+-77),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-76)
	LD	A,(IX+-77)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan2
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__fneg
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  630			
;  631			if (floatAbs(angleFromCenter) <= (fov/2))
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	(IX+-68),BC
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-69),A
	CALL	_floatAbs
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-68)
	LD	E,(IX+-69)
	CALL	__fcmp
	JP	M,L_170
;  632			{
;  633				//get distance to object
;  634				dist = (distanceBetween(&playerPosition, &objectArray[num].position));
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,_playerPosition
	PUSH	BC
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  635				//cast ray to nearest face and compare with distance to object
;  636				testRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-40
	LD	(IX+-52),BC
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  637				testRay.origin[1] = playerPosition[1];
	LD	IY,_playerPosition
	LEA	IY,IY+4
	LD	(IX+-61),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-61)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	LD	IY,(IX+-52)
	LEA	HL,IY+4
	LD	IY,(IX+-61)	; unspill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  638				testRay.direction[0] = toObject[0];
	LEA	BC,IX+-32
	LD	(IX+-49),BC
	LD	HL,BC
	LD	BC,(IX+-20)
	LD	A,(IX+-17)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  639				testRay.direction[1] = toObject[1];
	LEA	IY,IX+-16
	LD	(IX+-58),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-49)
;  640				ClosestFace(&testRay, &distToFace, &hit);
	PEA	IX+-8
	PEA	IX+-24
	PEA	IX+-40
	LEA	HL,IY+4
	LD	IY,(IX+-58)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  641				if (hit && dist >distToFace)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_167
	LD	HL,(IX+-24)
	LD	E,(IX+-21)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_170
;  642				{
;  643					//if the ray hit a face and that face is closer than the object, skip drawing it (it's obscured).
;  644					continue;
;  645				}
L_167:
;  646	
;  647				//change distance to the scale factor
;  648				dist =abs(1/((dist+3) *0.025)-2);
	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	HL,13421773
	LD	E,60
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fdiv
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
;  649				//limit dist to a minimum scale of 1
;  650				dist = max(dist,1);
	LD	C,63
	LD	B,0
	LD	(IX+-1),A
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  651				//set the color pallete
;  652				gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  653				//draw the scaled sprite.
;  654				gfx_ScaledTransparentSprite_NoClip(objectArray[num].sprite, (LCD_WIDTH/2) + (angleFromCenter *100 * fov) - (enemy1_width *dist)/2 ,LCD_HEIGHT/2 - (enemy1_height *dist)/2 ,dist,dist);
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	HL,12058624
	LD	E,65
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,15728640
	LD	A,66
	CALL	__fsub
	CALL	__ftol
	LD	HL,13107200
	LD	E,66
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fmul
	LD	H,A
	LD	A,(_fov+3)
	LD	E,A
	LD	A,H
	LD	HL,(_fov)
	CALL	__fmul
	LD	HL,2097152
	LD	E,67
	CALL	__fadd
	LD	(IX+-64),BC
	LD	(IX+-65),A
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	HL,7340032
	LD	E,65
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-64)
	LD	A,(IX+-65)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  655				
;  656			}
;  657		}
L_170:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_171:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_169
;  658		
;  659	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawObjects ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_max                                IMPORT  -----   function
;_abs                                IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_distanceBetween                    IMPORT  -----   function
;_floatAbs                           IMPORT  -----   function
;_fov                                STATIC      4   variable
;_atan2                              IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_playerPosition                     STATIC      8   variable
;_objectArray                        STATIC      3   variable
;testRay                              IX-40     16   variable
;distToFace                           IX-24      4   variable
;toObject                             IX-20      8   variable
;angleFromCenter                      IX-12      4   variable
;hit                                   IX-8      1   variable
;num                                   IX-7      3   variable
;dist                                  IX-4      4   variable


; Stack Frame Size: 83 (bytes)
;       Spill Code: -11 (instruction)


;  660	
;  661	//creates and mallocs a face, and returns a pointer to it
;  662	Face * mallocAndGenerateFace(float  point1x, float  point1y, float point2x, float point2y, uint8_t colorIndex)
;  663	{
_mallocAndGenerateFace:
	LD	HL,-6
	CALL	__frameset
;  664		Face * newFace = malloc(sizeof(Face));
	LD	BC,17
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;  665		newFace->point1[0] = point1x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+-6)
	LD	(IY+0),BC
	LD	(IY+3),A
;  666		newFace->point1[1] = point1y;
	LEA	HL,IY+4
	LD	BC,(IX+12)
	LD	A,(IX+15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  667		newFace->point2[0] = point2x;
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	BC,(IX+18)
	LD	A,(IX+21)
	LD	(IY+8),BC
	LD	(IY+11),A
;  668		newFace->point2[1] = point2y;
	LD	IY,(IX+-3)
	LEA	HL,IY+4
	LD	BC,(IX+24)
	LD	A,(IX+27)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  669		newFace->color = colorIndex;
	LD	A,(IX+30)
	LD	IY,(IX+-6)
	LD	(IY+16),A
;  670		return newFace;
	LD	HL,(IX+-6)
;  671	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mallocAndGenerateFace ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;newFace                               IX-6      3   variable
;colorIndex                           IX+30      1   parameter
;point2y                              IX+24      4   parameter
;point2x                              IX+18      4   parameter
;point1y                              IX+12      4   parameter
;point1x                               IX+6      4   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -11 (instruction)


;  672	
;  673	
;  674	void loadLevel()
;  675	{
_loadLevel:
	LD	HL,-11
	CALL	__frameset
;  676		Object newObj;
;  677		numberOfObjects++;
	LD	BC,(_numberOfObjects)
	INC	BC
	LD	(_numberOfObjects),BC
;  678		//alloc object array
;  679		objectArray = malloc(sizeof(Object) * numberOfObjects);
	LD	HL,(_numberOfObjects)
	LD	A,11
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
;  680		//malloc sprite image
;  681		enemy1Sprite = gfx_MallocSprite(enemy1_width,enemy1_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	(_objectArray),HL
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_enemy1Sprite),HL
;  682		//decompress sprite image
;  683		zx7_Decompress(enemy1Sprite, enemy1_compressed);
	LD	BC,_enemy1_compressed
	PUSH	BC
	LD	BC,(_enemy1Sprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  684		newObj.sprite =  enemy1Sprite;
	LD	BC,(_enemy1Sprite)
	LD	(IX+-3),BC
;  685		
;  686		//set position
;  687		newObj.position[0] = -2;
	LD	BC,0
	LD	(IX+-11),BC
	LD	A,192
	LD	(IX+-8),A
;  688		newObj.position[1] = 2;
	LEA	IY,IX+-11
;  689		//add to array
;  690		objectArray[0] =newObj;
	LEA	HL,IX+-11
	LD	(IY+4),BC
	LD	(IY+7),64
	LD	DE,(_objectArray)
	LD	BC,11
	LDIR	
;  691		
;  692		
;  693	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadLevel ***************************
;Name                         Addr/Register   Size   Type
;_enemy1_compressed                  IMPORT    258   variable
;_zx7_Decompress                     IMPORT  -----   function
;_enemy1Sprite                       STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_objectArray                        STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_numberOfObjects                    STATIC      3   variable
;newObj                               IX-11     11   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: -11 (instruction)


;  694	
;  695	//frees all of the objects' sprites
;  696	void unloadLevel()
;  697	{
_unloadLevel:
	LD	HL,-3
	CALL	__frameset
;  698		int j =0;
;  699		for (j=0;j<numberOfObjects;j++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_179
L_177:
;  700		{
;  701			free(objectArray[j].sprite);
	LD	HL,(IX+-3)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  702		}
L_179:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_177
;  703		free(objectArray);
	LD	BC,(_objectArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  704	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _unloadLevel ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_objectArray                        STATIC      3   variable
;_free                               IMPORT  -----   function
;j                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: -11 (instruction)


	XREF _rotateVector:ROM
	XREF _distanceBetween:ROM
	XREF _fastCos:ROM
	XREF _floatAbs:ROM
	XREF _max:ROM
	XREF _gfx_group_pal:ROM
	XREF _enemy1_compressed:ROM
	XREF _doomak2_compressed:ROM
	XREF _zx7_Decompress:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_ScaledTransparentSprite_NoClip:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintString:ROM
	XREF _gfx_Blit:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_Line_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _calloc:ROM
	XREF _sqrt:ROM
	XREF _atan2:ROM
	XREF _asm_DrawStatusBar:ROM
	XREF _asm_ClrLCD:ROM
	XREF _asm_HomeUp:ROM
	XREF __OS:ROM
	XREF _os_GetCSC:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __lremu:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __itol:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __imul_b:ROM
	XDEF _unloadLevel
	XDEF _loadLevel
	XDEF _mallocAndGenerateFace
	XDEF _drawObjects
	XDEF _drawMap
	XDEF _gcvt
	XDEF _GetRayToFaceIntersection
	XDEF _ClosestFace
	XDEF _draw
	XDEF _step
	XDEF _end
	XDEF _begin
	XDEF _main
	XDEF _enemy1Sprite
	XDEF _enemy1Sprite_data
	XDEF _akSprite
	XDEF _akSprite_data
	XDEF _nyiError
	XDEF _key
	XDEF _partial_redraw
	XDEF _objectArray
	XDEF _faceArray
	XDEF _FACEARRAYMAXSIZE
	XDEF _playerPosition
	XDEF _lookDirection
	XDEF _MAX_DISTANCE
	XDEF _RENDER_WIDTH
	XDEF _DISTANCE_FOG
	XDEF _fov
	XDEF _multiplier
	XDEF _focalLength
	XDEF _lineSpacing
	XDEF _freeLookupTable
	XDEF _lookupSqrt
	XDEF _generateLookupTable
	XDEF _lut
	END
