; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_lut:
	DS	3
	SEGMENT DATA
_lookupTableSize:
	DW	0
	DB	0
_skip:
	DW	0
	DB	0
	SEGMENT CODE
_generateLookupTable:
	LD	HL,-9
	CALL	__frameset
	LD	BC,(IX+6)
	LD	(_lookupTableSize),BC
	LD	BC,(IX+9)
	LD	(_skip),BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(_lut),HL
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
	LD	HL,(_skip)
	LD	BC,(IX+-3)
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-6),HL	; spill
	LD	(IX+-9),HL	; spill
	LD	HL,(IX+-3)
	LD	BC,(_lut)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-9)	; unspill
	LD	(IY),HL
	LD	(IY+3),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_3:
	LD	BC,(IX+6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _generateLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;_lut                                STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_skip                               STATIC      3   variable
;_lookupTableSize                    STATIC      3   variable
;i                                     IX-3      3   variable
;ski                                   IX+9      3   parameter
;size                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


_lookupSqrt:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(_lookupTableSize)
	DEC	BC
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fcmp
	JP	M,L_6
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	JR	L_7
L_6:
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	HL,(_skip)
	CALL	__imuls
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(_lut)
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,BC
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_lut)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupSqrt ***************************
;Name                         Addr/Register   Size   Type
;_lut                                STATIC      3   variable
;_skip                               STATIC      3   variable
;_sqrt                               IMPORT  -----   function
;_lookupTableSize                    STATIC      3   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


_freeLookupTable:
	LD	BC,(_lut)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,0
	LD	(_lookupTableSize),BC
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <graphx.h>
;   10	#include <debug.h>
;   11	#include <keypadc.h>
;   12	#include <assert.h>
;   13	#include <compression.h>
;   14	#include "gfx/gfx_group.h"
;   15	#include "lookup_table.h"
;   16	typedef struct 
;   17	{
;   18		float origin[2];
;   19		float direction[2];
;   20	
;   21	}Ray;
;   22	typedef struct 
;   23	{
;   24		uint8_t r,g,b;
;   25	}Color;
;   26	typedef struct 
;   27	{
;   28		float point1[2];
;   29		float point2[2];
;   30		uint8_t color;
;   31	}Face;
;   32	typedef struct{
;   33		float position[2];
;   34		gfx_sprite_t * sprite;	
;   35	}Object;
;   36	
;   37	int lineSpacing = 20;
;   38	float focalLength = 5.0;
;   39	float multiplier = 50;
;   40	
;   41	float fov = M_PI/2;
;   42	const bool DISTANCE_FOG = true;
;   43	const int RENDER_WIDTH = 100;
;   44	const float MAX_DISTANCE = 2;
;   45	float lookDirection[] = {0,1};
;   46	float playerPosition[] = {0,0};
;   47	const int FACEARRAYMAXSIZE = 10;
	RET	


;**************************** _freeLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTableSize                    STATIC      3   variable
;_lut                                STATIC      3   variable
;_free                               IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT DATA
_lineSpacing:
	DW	20
	DB	0
_focalLength:
	DF	5.0
_multiplier:
	DF	50.0
_fov:
	DF	1.57079637050629
	SEGMENT TEXT
_DISTANCE_FOG:
	DB	1
_RENDER_WIDTH:
	DW	100
	DB	0
_MAX_DISTANCE:
	DF	2.0
	SEGMENT DATA
_lookDirection:
	DF	0.0
	DF	1.0
_playerPosition:
	DF	0.0
	DF	0.0
	SEGMENT TEXT
_FACEARRAYMAXSIZE:
	DW	10
	DB	0
	SEGMENT BSS
_faceArray:
	DS	3
	SEGMENT DATA
_faceArrayCurrentSize:
	DW	0
	DB	0
_numberOfObjects:
	DW	0
	DB	0
	SEGMENT BSS
_objectArray:
	DS	3
_partial_redraw:
	DS	1
_key:
	DS	1
	SEGMENT STRSECT
L__5:
	DB	"Not Yet Implemented"
	DB	0
	SEGMENT DATA
_nyiError:
	DW24	L__5
	SEGMENT BSS
_akSprite_data:
	DS	3076
	SEGMENT DATA
_akSprite:
	DW24	_akSprite_data
	SEGMENT BSS
_enemy1Sprite_data:
	DS	347
	SEGMENT DATA
_enemy1Sprite:
	DW24	_enemy1Sprite_data
;   48	Face * faceArray;
;   49	static int faceArrayCurrentSize = 0;
;   50	static int numberOfObjects = 0;
;   51	#define OBJECTARRAYMAXSIZE  10
;   52	
;   53	Object * objectArray;
;   54	
;   55	float min(float, float);
;   56	float max(float, float);
;   57	float floatAbs(float );
;   58	float fastACos(float);
;   59	void loadLevel();
;   60	void printTextSmall(const char *, uint8_t , uint8_t);
;   61	void printText(const char *, uint8_t, uint8_t );
;   62	Face * mallocAndGenerateFace(float , float, float, float , uint8_t);
;   63	void drawObjects();
;   64	float fastSqrt(float);
;   65	float distanceBetween(float *, float *);
;   66	void drawMap();
;   67	float fastCos(float);
;   68	float fastSin(float);
;   69	void normalizeVector(float *);
;   70	void rotateVector(float *, float);
;   71	Face *ClosestFace(Ray*, float*, bool*);
;   72	void GetRayToFaceIntersection(Ray*, Face*, float * ,bool *);
;   73	char * gcvt(float, size_t, char *);
;   74	void begin();
;   75	void end();
;   76	void step();
;   77	void draw();
;   78	int root(int);
;   79	bool partial_redraw;
;   80	kb_key_t key;
;   81	
;   82	
;   83	
;   84	char * nyiError = "Not Yet Implemented";
;   85	//gfx_sprite_t * akSprite;
;   86	gfx_UninitedSprite(akSprite, doomak2_width,doomak2_height);
;   87	gfx_UninitedSprite(enemy1Sprite, enemy1_width, enemy1_height);
	SEGMENT CODE
;   88	void main() {
_main:
	LD	HL,-24
	CALL	__frameset
;   89		
;   90		int i;
;   91		Ray * testRay = malloc(sizeof(Ray));
	LD	BC,16
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;   92		Face * testFace;
;   93		Face * testFace2;	
;   94		Face * testFace3;
;   95		Face * testFace4;
;   96		
;   97		float  * destination  = calloc(2 , sizeof(float));
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(IX+-21),HL
;   98		//float destination[2];
;   99		bool  hit = false;
;  100		faceArray = calloc(FACEARRAYMAXSIZE ,sizeof(Face));
	LD	BC,17
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(_faceArray),HL
;  101		testRay->origin[0] = 0;
	LD	IY,(IX+-6)
	LD	BC,0
	LD	(IY+0),BC
	LD	(IY+3),0
;  102		testRay->origin[1] = -1;
	LEA	HL,IY+4
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  103		testRay->direction[0] = 0;
	LEA	BC,IY+8
	LD	(IX+-24),BC
	LD	BC,0
	LD	(IY+8),BC
	LD	(IY+11),0
;  104		testRay->direction[1] = 1;
	LD	IY,(IX+-24)
;  105		testFace = mallocAndGenerateFace(-5,6,5,6, 65);
	LD	BC,65
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	LEA	HL,IY+4
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),63
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-9),HL
;  106		testFace2 = mallocAndGenerateFace(-5,-5,5,-5,12);
	LD	BC,12
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	C,64
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-12),HL
;  107		testFace3 = mallocAndGenerateFace(-7,7,-7,-7,02);
	LD	BC,2
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	DE,14680064
	PUSH	DE
	PUSH	BC
	LD	C,64
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	LD	BC,14680064
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-15),HL
;  108		testFace4 = mallocAndGenerateFace(4,-9,8,2,196);
	LD	BC,196
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	C,65
	LD	DE,0
	PUSH	DE
	PUSH	BC
	LD	C,193
	PUSH	DE
	PUSH	BC
	LD	C,64
	LD	DE,1048576
	PUSH	DE
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-18),HL
;  109		faceArray[0] = *testFace;
	LD	DE,(_faceArray)
	LD	HL,(IX+-9)
	LD	BC,17
	LDIR	
;  110		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  111		faceArray[1] = *testFace2;
	LD	IY,(_faceArray)
	LEA	DE,IY+17
	LD	HL,(IX+-12)
	LD	BC,17
	LDIR	
;  112		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  113		faceArray[2] = *testFace3;
	LD	IY,(_faceArray)
	LEA	DE,IY+34
	LD	HL,(IX+-15)
	LD	BC,17
	LDIR	
;  114		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  115		faceArray[3] = *testFace4;
	LD	IY,(_faceArray)
	LEA	DE,IY+51
	LD	HL,(IX+-18)
	LD	BC,17
	LDIR	
;  116		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  117		//generateLookupTable(1000, 1);
;  118	
;  119	    loadLevel();
	CALL	_loadLevel
;  120		begin(); // No rendering allowed!
	CALL	_begin
;  121		
;  122	
;  123		
;  124		//sets up NYI error message
;  125		for (i = 0; i < 20; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_16
L_14:
;  126		{
;  127			os_AppErr1[i] =nyiError[i];
	LD	BC,(IX+-3)
	LD	HL,(_nyiError)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,13641129
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  128			
;  129		}
L_16:
	LD	BC,20
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;  130		
;  131		
;  132		//allocates and decompresses gun sprite
;  133		akSprite = gfx_MallocSprite(doomak2_width,doomak2_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,58
	PUSH	BC
	LD	BC,53
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_akSprite),HL
;  134		zx7_Decompress(akSprite, doomak2_compressed);
	LD	BC,_doomak2_compressed
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  135		
;  136	    gfx_Begin();
	CALL	_gfx_Begin
;  137	    gfx_SetDrawBuffer(); // Draw to the buffer to avoid rendering artifats
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  138		
;  139		kb_Scan();
	CALL	_kb_Scan
;  140		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  141			
;  142	    while (kb_Data[1] !=kb_2nd) { 
	JR	L_20
L_21:
;  143			step();// No rendering allowed in step!
	CALL	_step
;  144	        if (partial_redraw) // Only want to redraw part of the previous frame?
	LD	A,(_partial_redraw)
	OR	A,A
	JR	Z,L_19
;  145	            gfx_BlitScreen(); // Copy previous frame as a base for this frame
	LD	BC,0
	PUSH	BC
	CALL	_gfx_Blit
	POP	BC
L_19:
;  146	        draw(); // As little non-rendering logic as possible
	CALL	_draw
;  147	        gfx_SwapDraw(); // Queue the buffered frame to be displayed
	CALL	_gfx_SwapDraw
;  148	    }
L_20:
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_21
;  149	
;  150	    gfx_End();
	CALL	_gfx_End
;  151	    end();
	CALL	_end
;  152		
;  153		
;  154		os_ClrHome();
	LD	BC,_asm_ClrLCD
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_HomeUp
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_DrawStatusBar
	PUSH	BC
	CALL	__OS
	POP	BC
;  155		
;  156		
;  157		while (!os_GetCSC());
L_26:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_26
;  158		free(destination);
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_free
	POP	BC
;  159		free(testFace);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  160		free(testFace2);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  161		free(testFace3);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_free
	POP	BC
;  162		free(testRay);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  163		free(faceArray);
	LD	BC,(_faceArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  164		free(akSprite);
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_free
	POP	BC
;  165		//freeLookupTable();
;  166	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_asm_DrawStatusBar                  IMPORT  -----   function
;_asm_HomeUp                         IMPORT  -----   function
;_asm_ClrLCD                         IMPORT  -----   function
;__OS                                IMPORT  -----   function
;_end                                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_draw                               IMPORT  -----   function
;_gfx_Blit                           IMPORT  -----   function
;_partial_redraw                     STATIC      1   variable
;_step                               IMPORT  -----   function
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_doomak2_compressed                 IMPORT   1819   variable
;_zx7_Decompress                     IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_nyiError                           STATIC      3   variable
;_begin                              IMPORT  -----   function
;_loadLevel                          IMPORT  -----   function
;_faceArrayCurrentSize               STATIC      3   variable
;_mallocAndGenerateFace              IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_calloc                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;destination                          IX-21      3   variable
;testFace4                            IX-18      3   variable
;testFace3                            IX-15      3   variable
;testFace2                            IX-12      3   variable
;testFace                              IX-9      3   variable
;testRay                               IX-6      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 30 (bytes)
;       Spill Code: -1 (instruction)


;  167	
;  168	/* Put other functions here */
;  169	void begin() {	
_begin:
;  170			gfx_SetTransparentColor(gfx_group_transparent_color_index);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  171		
;  172	}
	RET	


;**************************** _begin ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetTransparentColor            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  173	
;  174	void end() {
_end:
;  175	    /* Implement me! */
;  176	}
	RET	


;**************************** _end ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT BSS
_movementRay:
	DS	16
;  177	Ray movementRay;
	SEGMENT CODE
;  178	void step() {
_step:
	LD	HL,-56
	CALL	__frameset
;  179	  	float distanceFromCam;
;  180		  bool hit;
;  181		movementRay.origin[0] = playerPosition[0];
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
;  182		movementRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-47),HL	; spill
	LD	(_movementRay),BC
	LD	(_movementRay+3),A
	LD	HL,_movementRay+4
	LD	(IX+-44),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+-44)	; unspill
	LD	(IX+-50),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-50)	; unspill
	LD	(IX+-53),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-53)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-56)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	A,(HL)
	LD	HL,(IX+-56)	; unspill
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  183		//keypad input
;  184		kb_Scan();
	CALL	_kb_Scan
;  185		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  186		//back
;  187		 if (kb_Data[4] & kb_2) {
	LD	A,(16056344)
	AND	A,2
	JR	Z,L_38
;  188			 	movementRay.direction[0] =  -lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-20),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(_movementRay+8),BC
;  189				movementRay.direction[1] =  -lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(_movementRay+11),A
	LD	(IX+-17),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	IY,(IX+-20)
;  190				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  191				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_33
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_38
L_33:
	OR	A,A
;  192				{
;  193	           		playerPosition[0] = playerPosition[0] + lookDirection[0] * -0.5;
	SBC	HL,HL
	LD	E,191
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  194					playerPosition[1] = playerPosition[1] + lookDirection[1] * -0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-23),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,191
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-23)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  195				}
;  196				
;  197	        } 
L_38:
;  198			//forward
;  199	        if (kb_Data[4] & kb_8) {
	LD	A,(16056344)
	AND	A,8
	JR	Z,L_42
;  200				movementRay.direction[0] =  lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-26),BC
	LD	HL,BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  201				movementRay.direction[1] =  lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(HL),A
	LD	(IX+-8),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-26)
;  202				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	INC	HL
	INC	HL
	LD	DE,_movementRay
	PUSH	DE
	INC	HL
	LD	A,(HL)
	LEA	HL,IY+4
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  203				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_42
L_36:
	OR	A,A
;  204				{
;  205	            	playerPosition[0] = playerPosition[0] + lookDirection[0] * 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  206					playerPosition[1] = playerPosition[1] + lookDirection[1] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-29),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-29)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  207				}
;  208				
;  209	        } 
L_42:
;  210			//left
;  211	        if (kb_Data[3] & kb_4) {
	LD	A,(16056342)
	AND	A,4
	JR	Z,L_46
;  212				movementRay.direction[0] =  -lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-32),BC
	LD	(IX+-11),DE
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fneg
	LD	IY,(IX+-32)
	LD	(IY),BC
	LD	(IY+3),A
;  213				movementRay.direction[1] =  lookDirection[0];
;  214				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LEA	HL,IY+4
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	LD	BC,_movementRay
	PUSH	BC
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  215				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_40
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_46
L_40:
;  216				{
;  217	            	playerPosition[0] = playerPosition[0] - lookDirection[1] * 0.5;
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fsub
	LD	(_playerPosition),BC
;  218					playerPosition[1] = playerPosition[1] + lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-35),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-35)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  219				}
;  220	        } 
L_46:
;  221			//right
;  222	        if (kb_Data[5] & kb_6) {
	LD	A,(16056346)
	AND	A,4
	JR	Z,L_48
;  223				movementRay.direction[0] =  lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-38),BC
	LD	(IX+-14),DE
	LD	HL,(IX+-14)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  224				movementRay.direction[1] =  -lookDirection[0];
	LD	IY,(IX+-38)
;  225				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  226				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_44
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_48
L_44:
;  227				{
;  228	            	playerPosition[0] = playerPosition[0] + lookDirection[1] * 0.5;
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  229					playerPosition[1] = playerPosition[1] - lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-41),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-41)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IY),BC
	LD	(IY+3),A
;  230				}
;  231				
;  232	        } 
L_48:
;  233			if (kb_Data[3] & kb_7)
	LD	A,(16056342)
	AND	A,8
	JR	Z,L_50
;  234			{
;  235				rotateVector(&lookDirection, 0.2);
	LD	C,62
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  236			}
L_50:
;  237			if (kb_Data[5] & kb_9)
	LD	A,(16056346)
	AND	A,8
	JR	Z,L_52
;  238			{
;  239				rotateVector(&lookDirection, -0.2);
	LD	C,190
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  240			}
L_52:
;  241			if (kb_Data[7] & kb_Up)
	LD	A,(16056350)
	AND	A,8
	JR	Z,L_54
;  242			{
;  243				fov+= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fadd
	LD	(_fov),BC
	LD	(_fov+3),A
;  244			}
L_54:
;  245			if (kb_Data[7] & kb_Down)
	LD	A,(16056350)
	AND	A,1
	JR	Z,L_57
;  246			{
;  247				fov-= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fsub
	LD	(_fov),BC
	LD	(_fov+3),A
;  248			}
L_57:
;  249			if (kb_Data[7] & kb_Left)
	LD	A,(16056350)
	AND	A,2
	JR	Z,L_61
;  250			{
;  251				lineSpacing++;
	LD	BC,(_lineSpacing)
	INC	BC
	LD	(_lineSpacing),BC
;  252			}
L_61:
;  253			if (kb_Data[7] & kb_Right)
	LD	A,(16056350)
	AND	A,4
	JR	Z,L_63
;  254			{
;  255				if (lineSpacing > 1)
	LD	BC,(_lineSpacing)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JP	P,L_63
;  256				{
;  257					lineSpacing--;
	LD	BC,(_lineSpacing)
	DEC	BC
	LD	(_lineSpacing),BC
;  258				}
;  259			}
L_63:
;  260			if (kb_Data[6] & kb_Add)
	LD	A,(16056348)
	AND	A,2
	JR	Z,L_66
;  261			{
;  262				multiplier+= 5;
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fadd
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  263			}
L_66:
;  264			if (kb_Data[6] & kb_Sub)
	LD	A,(16056348)
	AND	A,4
	JR	Z,L_68
;  265			{
;  266				if (multiplier > 5)
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fcmp
	JP	P,L_68
;  267				{
;  268					multiplier-= 5;
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fsub
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  269				}
;  270			}
L_68:
;  271			if (kb_Data[6] & kb_Mul)
	LD	A,(16056348)
	AND	A,8
	JR	Z,L_71
	OR	A,A
;  272			{
;  273				focalLength += 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fadd
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  274			}
L_71:
;  275			if (kb_Data[6] & kb_Div)
	LD	A,(16056348)
	AND	A,16
	JR	Z,L_72
	OR	A,A
;  276			{
;  277				if (focalLength > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fcmp
	JP	P,L_72
	OR	A,A
;  278				{
;  279					focalLength -= 0.5;
	SBC	HL,HL
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fsub
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  280				}
;  281			}
;  282	}
L_72:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _step ***************************
;Name                         Addr/Register   Size   Type
;_focalLength                        STATIC      4   variable
;_multiplier                         STATIC      4   variable
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_movementRay                        STATIC     16   variable
;_playerPosition                     STATIC      8   variable
;G_0                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;G_2                                  IX-11      3   variable
;G_1                                   IX-8      3   variable
;distanceFromCam                       IX-5      4   variable
;hit                                   IX-1      1   variable


; Stack Frame Size: 62 (bytes)
;       Spill Code: -1 (instruction)


;  283	
;  284	void draw() {
_draw:
	LD	HL,-61
	CALL	__frameset
;  285		int row = LCD_WIDTH/2;
;  286		int fillSpacing = 0;
;  287		int temp = 0;
;  288		float closeDist = -1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,191
	LD	(IX+-8),A
;  289		float fardist = 2;
;  290		float res[2];
;  291		char buf[10];
;  292		bool hmm = false;
	LD	(IX+-7),0
;  293		Face * hit ;
;  294		Ray  lookRay ;
;  295		float newClose;
;  296		float angleFromCenter = 0;
;  297		//145,156,255,221,205,190, or 165
;  298		gfx_FillScreen(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  299		
;  300		lookRay.direction[0] = lookDirection[0];
	LEA	BC,IX+-39
	LD	(IX+-53),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(IX+-39),BC
;  301		lookRay.direction[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-36),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LEA	IY,IX+-35
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+3),A
;  302		lookRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-47
	LD	(IX+-50),BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(IX+-47),BC
;  303		lookRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-44),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	IY,(IX+-50)
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
;  304		//rotate the ray to the very left in preparation for spinning it around
;  305		rotateVector(&lookRay.direction, fov/2);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+-53)
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
;  306		angleFromCenter = fov/2;
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  307		
;  308		//loop for each vertical line
;  309		
;  310		for (row = 0; row <LCD_WIDTH; row+= lineSpacing){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_83
L_81:
;  311		
;  312			//rotate ray by a small amount and then cast again
;  313			rotateVector(&(lookRay.direction), -((float)fov / LCD_WIDTH) * lineSpacing);
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-60),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-61),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-60)
	LD	A,(IX+-61)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-39
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  314			angleFromCenter += -((float)fov / LCD_WIDTH) * lineSpacing;
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-56),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-57),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-56)
	LD	A,(IX+-57)
	CALL	__fmul
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	CALL	__fadd
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  315			hit = ClosestFace(&lookRay, &closeDist, &hmm);
	PEA	IX+-7
	PEA	IX+-11
	PEA	IX+-47
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  316			
;  317			//if hit
;  318			if (hmm && hit != 0)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_82
	LD	HL,(IX+-17)
	CALL	__icmpzero
	JR	Z,L_82
;  319			{
;  320				
;  321				gfx_SetColor(hit->color);
	LD	IY,(IX+-17)
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  322				closeDist = closeDist * fastCos(angleFromCenter);
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
;  323				temp =(focalLength/closeDist) * multiplier;
	LD	HL,BC
	LD	BC,(_focalLength)
	LD	E,(IX+-8)
	LD	A,(_focalLength+3)
	CALL	__fdiv
	LD	H,A
	LD	A,(_multiplier+3)
	LD	E,A
	LD	A,H
	LD	HL,(_multiplier)
	CALL	__fmul
	CALL	__ftol
;  324				if (temp < 0)
	LD	HL,BC
	CALL	__icmpzero
	LD	(IX+-6),BC
	JP	P,L_76
;  325				{
;  326					temp = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  327				}
L_76:
;  328				if (temp > LCD_HEIGHT/2 -1)
	LD	BC,(IX+-6)
	LD	HL,119
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  329				{
;  330					temp = LCD_HEIGHT/2 -1;
	LD	BC,119
	LD	(IX+-6),BC
;  331				}
L_77:
;  332				/*
;  333					for (fillSpacing = 1; fillSpacing < lineSpacing && fillSpacing + row < LCD_WIDTH; fillSpacing++)
;  334					{
;  335						gfx_Line_NoClip(row+ fillSpacing, LCD_HEIGHT/2.0 + temp, row+ fillSpacing, LCD_HEIGHT/2.0 - temp);
;  336					}
;  337				*/
;  338				fillSpacing = lineSpacing;
	LD	BC,(_lineSpacing)
	LD	(IX+-14),BC
;  339				if (row + fillSpacing >= LCD_WIDTH)
	LD	HL,(IX+-3)
	ADD	HL,BC
	OR	A,A
	LD	BC,320
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  340				{
;  341					fillSpacing = LCD_WIDTH-row;
	LD	BC,(IX+-3)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	(IX+-14),HL
;  342				}
L_79:
;  343				
;  344				gfx_FillRectangle_NoClip(row,LCD_HEIGHT/2 - temp,fillSpacing, 2 * temp );
	LD	A,(IX+-6)
	ADD	A,A
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	A,120
	LD	BC,(IX+-14)
	PUSH	BC
	LD	B,(IX+-6)
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  345			}
;  346			
;  347			
;  348			
;  349		}
L_82:
	LD	BC,(IX+-3)
	LD	HL,(_lineSpacing)
	ADD	HL,BC
	LD	(IX+-3),HL
L_83:
	LD	BC,320
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_81
;  350			//draw position and rotation text
;  351			gcvt(playerPosition[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_playerPosition+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  352			gfx_SetTextFGColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  353			gfx_SetTextXY(0,0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  354			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  355			gcvt(playerPosition[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  356			gfx_SetTextXY(75,0);
	LD	BC,0
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  357			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  358			gcvt(lookDirection[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_lookDirection+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_lookDirection)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  359			gfx_SetTextXY(0,20);
	LD	BC,20
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  360			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  361			gcvt(lookDirection[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  362			gfx_SetTextXY(75,20);
	LD	BC,20
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  363			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  364			
;  365			//draw objects
;  366			drawObjects();
	CALL	_drawObjects
;  367			
;  368			//draw gun sprite
;  369			gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  370			gfx_ScaledTransparentSprite_NoClip(akSprite, (LCD_WIDTH /2) - 68 , LCD_HEIGHT - doomak2_height * 2, 2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	BC,124
	PUSH	BC
	LD	BC,92
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  371			
;  372			//draw crosshair
;  373			gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  374			gfx_Line_NoClip(LCD_WIDTH/2 - 2, LCD_HEIGHT/2, LCD_WIDTH/2 + 2, LCD_HEIGHT/2);
	LD	BC,120
	PUSH	BC
	LD	BC,162
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,158
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  375			gfx_Line_NoClip(LCD_WIDTH/2 , LCD_HEIGHT/2 - 2, LCD_WIDTH/2 , LCD_HEIGHT/2 + 2);
	LD	BC,122
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,118
	PUSH	BC
	LD	BC,160
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  376			
;  377	
;  378			//draw the overhead map
;  379			drawMap();
	CALL	_drawMap
;  380			
;  381	
;  382		
;  383	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _draw ***************************
;Name                         Addr/Register   Size   Type
;_drawMap                            IMPORT  -----   function
;_gfx_Line_NoClip                    IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_drawObjects                        IMPORT  -----   function
;_gfx_PrintString                    IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gcvt                               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_multiplier                         STATIC      4   variable
;_focalLength                        STATIC      4   variable
;_fastCos                            IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_lookDirection                      STATIC      8   variable
;_gfx_FillScreen                     IMPORT  -----   function
;lookRay                              IX-47     16   variable
;buf                                  IX-31     10   variable
;angleFromCenter                      IX-21      4   variable
;hit                                  IX-17      3   variable
;fillSpacing                          IX-14      3   variable
;closeDist                            IX-11      4   variable
;hmm                                   IX-7      1   variable
;temp                                  IX-6      3   variable
;row                                   IX-3      3   variable


; Stack Frame Size: 67 (bytes)
;       Spill Code: -1 (instruction)


;  384	Face *ClosestFace(Ray *ray, float *distance, bool * hitOrNot)
;  385	{
_ClosestFace:
	LD	HL,-26
	CALL	__frameset
;  386		float closestDist;
;  387		int i;
;  388		float hitpoint[2];
;  389		//float * hitpoint  = malloc(2 * sizeof(float));
;  390		float dist = 0;
	LD	BC,0
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  391		bool  didhit;
;  392		//pointer to the face in facearray that was hit
;  393		Face * outface = NULL;
	LD	(IX+-11),BC
;  394		*distance = -1;
	LD	HL,(IX+9)
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  395		closestDist = 999999;
	LD	BC,7611376
	LD	(IX+-7),BC
	LD	A,73
	LD	(IX+-4),A
;  396		*hitOrNot = false;
	LD	HL,(IX+12)
	LD	(HL),0
;  397		
;  398		//check if passed null pointers
;  399		if (ray == NULL || distance == NULL || hitOrNot == NULL)
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_97
L_88:
	OR	A,A
;  400		{
;  401			return outface;
	SBC	HL,HL
	JR	L_99
;  402		}
L_97:
;  403		
;  404		for (i = 0; i<faceArrayCurrentSize; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_96
L_94:
;  405		{
;  406			
;  407			GetRayToFaceIntersection(ray, &(faceArray[i]), &hitpoint, &didhit);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	(IX+-14),HL
	PEA	IX+-8
	PEA	IX+-26
	LD	BC,(_faceArray)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_GetRayToFaceIntersection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  408			
;  409			//if successfully hit something
;  410			if (didhit)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_93
;  411			{
;  412				
;  413				*hitOrNot = true;
	LD	HL,(IX+12)
;  414				dist = distanceBetween(ray->origin, hitpoint);
	PEA	IX+-26
	LD	(HL),1
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  415				//if closer than closest face so far, set face that its currently checking to be the closest face
;  416				if (dist < closestDist)
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	CALL	__fcmp
	JP	P,L_93
;  417				{
;  418					closestDist = dist;
	LD	BC,(IX+-18)
	LD	A,(IX+-15)
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  419					outface = &(faceArray[i]);
	LD	BC,(IX+-14)
	LD	HL,(_faceArray)
	ADD	HL,BC
	LD	(IX+-11),HL
;  420				}
;  421			}
L_93:
;  422			
;  423			//*distance = closestDist;
;  424			//if closest dist was changed
;  425			if (closestDist < 999999)
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,7611376
	LD	A,73
	CALL	__fcmp
	JP	P,L_95
;  426			{
;  427				
;  428				*hitOrNot = true;
	LD	HL,(IX+12)
	LD	(HL),1
;  429				*distance = closestDist;
	LD	HL,(IX+9)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  430				return outface;
	LD	HL,(IX+-11)
	JR	L_99
;  431			}
;  432		}
L_95:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_96:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
;  433		
;  434		return outface;
	LD	HL,(IX+-11)
;  435	}
L_99:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ClosestFace ***************************
;Name                         Addr/Register   Size   Type
;_faceArrayCurrentSize               STATIC      3   variable
;_distanceBetween                    IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_GetRayToFaceIntersection           IMPORT  -----   function
;hitpoint                             IX-26      8   variable
;dist                                 IX-18      4   variable
;G_4                                  IX-14      3   variable
;outface                              IX-11      3   variable
;didhit                                IX-8      1   variable
;closestDist                           IX-7      4   variable
;i                                     IX-3      3   variable
;hitOrNot                             IX+12      3   parameter
;distance                              IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


;  436	
;  437	void GetRayToFaceIntersection(Ray * ray, Face * face, float * result, bool * hit)
;  438	{
_GetRayToFaceIntersection:
	LD	HL,-72
	CALL	__frameset
;  439		float v1[2] = {0,0};
	LEA	DE,IX+-14
	LD	HL,_0temp100
	LD	BC,8
	LDIR	
;  440		float v2[2]= {0,0};
	LEA	DE,IX+-22
	LD	HL,_1temp101
	LD	BC,8
	LDIR	
;  441		float v3[2]= {0,0};
	LEA	DE,IX+-30
	LD	HL,_2temp102
	LD	BC,8
	LDIR	
;  442		float tOne = 0;
;  443		float tTwo = 0;
;  444		float dot = 0;
;  445		v1[0] =(ray->origin[0] - face->point1[0]);
	LD	IY,(IX+9)
	LEA	BC,IY+0
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-14),BC
	LD	(IX+-11),A
;  446		v1[1] = (ray->origin[1] - face->point1[1]);
	LD	IY,(IX+-6)
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-14
	LD	(IY+4),BC
	LD	(IY+7),A
;  447		v2[0] = (face->point2[0] - face->point1[0]);
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fsub
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  448		v2[1]= (face->point2[1] - face->point1[1]);
	LEA	BC,IY+12
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-22
	LD	(IY+4),BC
	LD	(IY+7),A
;  449		v3[0] = -(ray->direction[1]);
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	(IX+-30),BC
	LD	(IX+-27),A
;  450		v3[1] = (ray->direction[0]);
	LD	(IX+-45),BC	; spill
	LEA	HL,IX+-26
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	BC,(IY+8)
	LD	A,(IY+11)
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),BC
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
;  451		dot = (v2[0] * v3[0]) + (v2[1] * v3[1]);
	LD	(IX+-51),HL	; spill
	LEA	HL,IX+-18
	LD	(IX+-54),HL	; spill
	LD	HL,(IX+-51)	; unspill
	LEA	IY,IX+-30
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),A
	LD	HL,(IX+-45)	; unspill
	LD	E,(IX+-27)
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	CALL	__fmul
	LD	(IX+-71),BC
	LD	(IX+-72),A
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-51),HL	; spill
	LD	IY,(IX+-54)
	LD	HL,(IX+-51)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	A,(IX+-72)
	LD	HL,BC
	LD	BC,(IX+-71)
	CALL	__fadd
	LD	(IX+-38),BC
	LD	(IX+-35),A
;  452		
;  453		*hit = false;
	LD	HL,(IX+15)
	LD	(HL),0
;  454		if (abs(dot) < 0.000001)
	LD	A,(IX+-35)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8796093
	LD	A,53
	CALL	__fcmp
	JP	M,L_108
;  455		{
;  456			return;
;  457		}
;  458		tOne = ((v2[0] * v1[1]) - (v2[1] * v1[0])) / dot;
	LEA	IY,IX+-14
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fmul
	LD	(IX+-65),BC
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LEA	IY,IX+-22
	LD	BC,(IY+4)
	LD	(IX+-62),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-65)
	LD	A,(IX+-62)
	CALL	__fsub
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-34),BC
	LD	(IX+-31),A
;  459		tTwo = ((v1[0] * v3[0])+ (v1[1] * v3[1])) / dot;
	LEA	HL,IX+-10
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-30)
	LD	E,(IX+-27)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fmul
	LEA	IY,IX+-30
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-45),HL	; spill
	LD	IY,(IX+-61)
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-58)
	LD	A,(IX+-55)
	CALL	__fadd
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-42),BC
	LD	(IX+-39),A
;  460		
;  461		if (tOne>0.0 && (tTwo >=0.0 && tTwo <= 1.0))
	LD	BC,(IX+-34)
	LD	A,(IX+-31)
	OR	A,A
	SBC	HL,HL
	LD	E,0
	CALL	__fcmp
	JP	P,L_108
	LD	HL,(IX+-42)
	LD	E,(IX+-39)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_108
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-42)
	LD	A,(IX+-39)
	CALL	__fcmp
	JP	M,L_108
;  462		{
;  463			
;  464			*hit = true;
	LD	HL,(IX+15)
	LD	(HL),1
;  465			
;  466			//tOne is distance to point1
;  467			//multiply by normalized direction and add to origin to get point
;  468			(result)[0] = ray->origin[0] + (ray->direction[0] * tOne);
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	IY,(IX+6)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fmul
	LD	HL,BC
	LD	BC,(IY+0)
	LD	E,A
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY),BC
	LD	(IY+3),A
;  469			(result)[1] = ray->origin[1] + (ray->direction[1] * tOne);
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fmul
	LD	E,A
	LD	(IX+-45),BC	; spill
	LD	IY,(IX+-68)
	LD	HL,BC	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  470			
;  471		}
;  472		
;  473	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetRayToFaceIntersection ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;_2temp102                           STATIC      8   variable
;_1temp101                           STATIC      8   variable
;_0temp100                           STATIC      8   variable
;tTwo                                 IX-42      4   variable
;dot                                  IX-38      4   variable
;tOne                                 IX-34      4   variable
;v3                                   IX-30      8   variable
;v2                                   IX-22      8   variable
;v1                                   IX-14      8   variable
;hit                                  IX+15      3   parameter
;result                               IX+12      3   parameter
;face                                  IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: -4 (instruction)


	SEGMENT TEXT
_0temp100:
	DF	0.0
	DF	0.0
_1temp101:
	DF	0.0
	DF	0.0
_2temp102:
	DF	0.0
	DF	0.0
	SEGMENT CODE
;  474	
;  475	int root(int x)
;  476	{
_root:
	LD	HL,-6
	CALL	__frameset
;  477		
;  478		 int a,b;
;  479		b = x;
	LD	BC,(IX+6)
	LD	(IX+-6),BC
;  480		a = x = 0x3f;
;  481		x = b/x;
	LD	HL,BC
	LD	BC,63
	CALL	__idivs
	LD	(IX+6),HL
;  482		a = x = (x+a)>>1;
	LD	IY,(IX+6)
	LEA	HL,IY+63
	LD	A,1
	CALL	__ishrs_b
	LD	BC,HL
	LD	(IX+6),BC
	LD	DE,(IX+6)
	LD	(IX+-3),DE
;  483		x = b/x;
	LD	HL,(IX+-6)
	CALL	__idivs
	LD	(IX+6),HL
;  484		a = x = (x+a)>>1;
	LD	BC,(IX+-3)
	LD	HL,(IX+6)
	ADD	HL,BC
	LD	A,1
	CALL	__ishrs_b
	LD	BC,HL
	LD	(IX+6),BC
	LD	DE,(IX+6)
	LD	(IX+-3),DE
;  485		x = b/x;
	LD	HL,(IX+-6)
	CALL	__idivs
	LD	(IX+6),HL
;  486		x = (x+a)>>1;
	LD	BC,(IX+-3)
	LD	HL,(IX+6)
	ADD	HL,BC
	LD	A,1
	CALL	__ishrs_b
	LD	(IX+6),HL
;  487		return(x); 
;  488		
;  489	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _root ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX-6      3   variable
;a                                     IX-3      3   variable
;x                                     IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -4 (instruction)


;  490	void rotateVector(float * vector, float angle)
;  491	{
_rotateVector:
	LD	HL,-28
	CALL	__frameset
;  492		float oldX,oldY;
;  493		//oldX =(vector[0] *cos(angle)) - (vector[1] * sin(angle));
;  494		//oldY = (vector[0] * sin(angle)) + (vector[1] *cos(angle));
;  495		oldX =(vector[0] *fastCos(angle)) - (vector[1] * fastSin(angle));
	LD	C,(IX+12)
	LD	B,0
	LD	IY,(IX+6)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	(IX+-28),IY
	CALL	_fastCos
	LD	IY,(IX+-28)
	POP	BC
	POP	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-21),BC
	LD	C,(IX+12)
	LD	B,0
	LD	IY,(IX+6)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	(IX+-22),A
	LEA	HL,IY+4
	LD	(IX+-25),HL	; spill
	CALL	_fastSin
	POP	BC
	POP	BC
	LD	(IX+-15),HL	; spill
	LD	IY,(IX+-25)
	LD	HL,(IX+-15)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-21)
	LD	A,(IX+-22)
	CALL	__fsub
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  496		oldY = (vector[0] * fastSin(angle)) + (vector[1] *fastCos(angle));
	LD	C,(IX+12)
	LD	B,0
	LD	IY,(IX+6)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	(IX+-28),IY
	CALL	_fastSin
	LD	IY,(IX+-28)
	POP	BC
	POP	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	C,(IX+12)
	LD	B,0
	LD	IY,(IX+6)
	PUSH	BC
	LD	BC,(IX+9)
	PUSH	BC
	LD	(IX+-12),A
	LEA	HL,IY+4
	LD	(IX+-18),HL	; spill
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	(IX+-15),HL	; spill
	LD	IY,(IX+-18)
	LD	HL,(IX+-15)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-11)
	LD	A,(IX+-12)
	CALL	__fadd
	LD	(IX+-8),BC
	LD	(IX+-5),A
;  497		vector[0] = oldX;
	LD	HL,(IX+6)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  498		vector[1] = oldY;
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  499	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _rotateVector ***************************
;Name                         Addr/Register   Size   Type
;_fastSin                            IMPORT  -----   function
;_fastCos                            IMPORT  -----   function
;oldY                                  IX-8      4   variable
;oldX                                  IX-4      4   variable
;angle                                 IX+9      4   parameter
;vector                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -6 (instruction)


;  500	void normalizeVector(float * vector)
;  501	{
_normalizeVector:
	LD	HL,-14
	CALL	__frameset
;  502		float dist = sqrt((vector[0] * vector[0]) + (vector[1]	* vector[1]));	
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	(IX+-6),BC
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	(IX+-14),BC
	LD	(IX+-11),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-10),HL
	LD	(IX+-7),E
;  503		vector[0] = vector[0] / dist;
	LD	IY,(IX+6)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__fdiv
	LD	(IY),BC
	LD	(IY+3),A
;  504		vector[1] = vector[1] /dist;
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,(IX+-10)
	LD	E,(IX+-7)
	CALL	__fdiv
	LD	(IY),BC
	LD	(IY+3),A
;  505	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _normalizeVector ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;dist                                 IX-10      4   variable
;vector                                IX+6      3   parameter


; Stack Frame Size: 23 (bytes)
;       Spill Code: -6 (instruction)


;  506	#include <stdio.h>
;  507	
;  508	#define PSH(X) (*(buf++)=(X))
;  509	#define PSH1(X) (*(buf--)=(X))
;  510	#define PEEK() buf[-1]
;  511	#define POP() *(--buf) = '\0'
;  512	
;  513	#define PLUS 1
;  514	#define SPACE 2
;  515	
;  516	char * gcvt(double f, size_t ndigit, char * buf)
;  517	{
_gcvt:
	LD	HL,-44
	CALL	__frameset
;  518	  int i;
;  519		unsigned long z,k;
;  520	  int exp = 0;
;  521	  char *c = buf;
	LD	BC,(IX+15)
	LD	(IX+-14),BC
;  522	  double f2,t,scal;
;  523	  int   sign = 0;
	LD	BC,0
	LD	(IX+-21),BC
;  524	
;  525	  if((int)ndigit == -1)
	LD	HL,(IX+12)
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_114
;  526	    ndigit = 5;
	LD	BC,5
	LD	(IX+12),BC
L_114:
;  527	
;  528	  /* Unsigned long long only allows for 20 digits of precision
;  529	   * which is already more than double supports, so we limit the
;  530	   * digits to this.  long double might require an increase if it is ever
;  531	   * implemented.
;  532	   */
;  533	  if (ndigit > 20)
	LD	BC,(IX+12)
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	NC,L_117
;  534		  ndigit = 20;
	LD	BC,20
	LD	(IX+12),BC
L_117:
;  535	  
;  536	  if (f < 0.0) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_118
;  537	    sign = 1;
	LD	BC,1
	LD	(IX+-21),BC
;  538	    f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  539		 buf++;
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  540	  }
L_118:
;  541	
;  542	  scal = 1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,63
	LD	(IX+-8),A
;  543	  for (i=ndigit; i>0; i--)
	LD	BC,(IX+12)
	LD	(IX+-3),BC
	JR	L_122
L_120:
;  544		  scal *= 10;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+-11)
	LD	A,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
L_122:
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_120
;  545	  k = f + 0.1 / scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,13421773
	LD	A,61
	CALL	__fdiv
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  546	  f2 = f - k;
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-29),BC
	LD	(IX+-26),A
;  547	  if (!f) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	XOR	A,A
	LD	BC,0
	CALL	__fcmp
	JR	NZ,L_136
;  548	    PSH('0');
	LD	HL,(IX+15)
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  549	    if(ndigit > 0)
	LD	BC,(IX+12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_132
;  550	      PSH('.');
	LD	HL,(IX+15)
	LD	(HL),46
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
L_132:
;  551	    for (i=0;i<ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_131
L_129:
;  552	      PSH('0');
	LD	BC,(IX+15)
	LD	(IX+-32),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_131:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_129
;  553	  	   PSH(0);
	LD	BC,(IX+15)
	LD	(IX+-35),BC
	LD	HL,BC
	LD	(HL),0
;  554	  	 return c;
	LD	HL,(IX+-14)
	JR	L_160
;  555	  }
L_136:
;  556	
;  557	  i = 1;
	LD	BC,1
	LD	(IX+-3),BC
;  558	  while (f >= 10.0) {
	JR	L_138
L_139:
;  559	  	f /= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  560	  	i++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  561	  }
L_138:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_139
;  562	
;  563	  buf += i + ndigit + 1; 	
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(IX+15),HL
;  564	
;  565	  PSH1(0);
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  566	
;  567	  if(ndigit > 0) {	
	OR	A,A
	LD	BC,(IX+12)
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_151
;  568		  t = f2 * scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,(IX+-29)
	LD	A,(IX+-26)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-22),A
	OR	A,A
;  569		 z = t + 0.5;
	SBC	HL,HL
	LD	E,63
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-18),BC
	LD	(IX+-15),A
;  570	    for (i = 0;i < ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_146
L_144:
;  571	    {
;  572	      PSH1('0'+ (z % 10));
	LD	BC,(IX+15)
	LD	(IX+-38),BC
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-38)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  573		   z /= 10;
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-18),HL
	LD	(IX+-15),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  574	    }
L_146:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_144
;  575	    PSH1('.');
	LD	BC,(IX+15)
	LD	(IX+-41),BC
	LD	HL,BC
	LD	(HL),46
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  576	  }
;  577	  else
	JR	L_153
L_151:
;  578	    PSH1(0);
	LD	HL,(IX+15)
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  579	
;  580	  do {
L_153:
;  581	    PSH1('0'+ (k % 10));
	LD	BC,(IX+15)
	LD	(IX+-44),BC
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-44)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  582	    k /= 10;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-7),HL
	LD	(IX+-4),E
;  583	  }while (k);
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__lcmpzero
	JR	NZ,L_153
;  584	
;  585	  if (sign)
	LD	HL,(IX+-21)
	CALL	__icmpzero
	JR	Z,L_159
;  586	    PSH1('-');
	LD	HL,(IX+15)
	LD	(HL),45
L_159:
;  587	  return c;
	LD	HL,(IX+-14)
;  588	}
L_160:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gcvt ***************************
;Name                         Addr/Register   Size   Type
;f2                                   IX-29      4   variable
;t                                    IX-25      4   variable
;sign                                 IX-21      3   variable
;z                                    IX-18      4   variable
;c                                    IX-14      3   variable
;scal                                 IX-11      4   variable
;k                                     IX-7      4   variable
;i                                     IX-3      3   variable
;buf                                  IX+15      3   parameter
;ndigit                               IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: -6 (instruction)


;  589	
;  590	 float distanceBetween(float * vec1, float * vec2)
;  591	 {
_distanceBetween:
	LD	HL,-26
	CALL	__frameset
;  592		//return  lookupSqrt( (vec1[0] - vec2[0]) * (vec1[0] - vec2[0]) + (vec1[1] - vec2[1]) * (vec1[1] - vec2[1]) );
;  593		return  sqrt( (vec1[0] - vec2[0]) * (vec1[0] - vec2[0]) + (vec1[1] - vec2[1]) * (vec1[1] - vec2[1]) );
	LD	IY,(IX+9)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	(IX+-16),HL	; spill
	LEA	HL,IY+4
	LD	(IX+-22),HL	; spill
	LD	HL,(IX+-16)	; unspill
	LD	(IX+-16),HL	; spill
	LD	HL,(IX+-22)	; unspill
	LD	(IX+-6),HL
	LD	HL,(IX+-16)	; unspill
	LD	IY,(IX+9)
	LD	(IX+-16),HL	; spill
	LEA	HL,IY+4
	LD	(IX+-19),HL	; spill
	LD	HL,(IX+-16)	; unspill
	LD	(IX+-16),HL	; spill
	LD	HL,(IX+-19)	; unspill
	LD	(IX+-3),HL
	LD	HL,(IX+-16)	; unspill
	LD	IY,(IX+-3)
	CALL	__fsub
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-6)
	LD	(IX+-13),BC
	LD	D,A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fsub
	LD	(IX+-10),BC
	LD	(IX+-7),A
	LD	A,D
	LD	BC,(IX+-13)
	LD	E,D
	LD	HL,(IX+-13)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-26),A
	LD	A,(IX+-7)
	LD	BC,(IX+-10)
	LD	E,(IX+-7)
	LD	HL,(IX+-10)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-25)
	LD	A,(IX+-26)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
;  594		
;  595	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _distanceBetween ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;vec2                                  IX+9      3   parameter
;vec1                                  IX+6      3   parameter


; Stack Frame Size: 38 (bytes)
;       Spill Code: -6 (instruction)


;  596	 float fastCos(float x)
;  597	 {
_fastCos:
	LD	HL,-8
	CALL	__frameset
;  598		 float cos = 0;
;  599		 while ( x < -3.14159265 )
	JR	L_162
L_163:
;  600		 {
;  601			  x += 6.28318531;
	LD	HL,13176795
	LD	E,64
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fadd
	LD	(IX+6),BC
	LD	(IX+9),A
;  602		 }
L_162:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,4788187
	LD	A,192
	CALL	__fcmp
	JP	M,L_163
;  603		 while (x > 3.14159265)
	JR	L_164
L_165:
;  604		 {
;  605			  x -= 6.28318531;
	LD	HL,13176795
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  606		 }
L_164:
	LD	HL,4788187
	LD	E,64
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	M,L_165
;  607		 
;  608		 x += 1.57079632;
	LD	HL,13176795
	LD	E,63
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fadd
	LD	(IX+6),BC
	LD	(IX+9),A
;  609		if (x >  3.14159265)
	LD	HL,4788187
	LD	E,64
	CALL	__fcmp
	JP	P,L_175
;  610		{
;  611			x -= 6.28318531;
	LD	HL,13176795
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  612		}
L_175:
;  613		if (x < 0)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_174
;  614		{
;  615	    cos = 1.27323954 * x + 0.405284735 * x * x;
	LD	HL,13599099
	LD	E,62
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	HL,10680707
	LD	E,63
	CALL	__fadd
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  616	    
;  617	    if (cos < 0)
	LD	HL,BC
	LD	BC,0
	LD	E,(IX+-1)
	XOR	A,A
	CALL	__fcmp
	JP	P,L_170
;  618	        cos = .225 * (cos *-cos - cos) + cos;
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fneg
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  619	    else
	JR	L_176
L_170:
;  620	        cos = .225 * (cos * cos - cos) + cos;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  621		}
;  622		else
	JR	L_176
L_174:
;  623		{
;  624	    cos = 1.27323954 * x - 0.405284735 * x * x;
	LD	HL,10680707
	LD	E,63
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	(IX+-8),BC
	LD	(IX+-5),A
	LD	A,(IX+9)
	LD	BC,(IX+6)
	LD	HL,13599099
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__fsub
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  625	
;  626	    if (cos < 0)
	LD	HL,BC
	LD	BC,0
	LD	E,(IX+-1)
	XOR	A,A
	CALL	__fcmp
	JP	P,L_172
;  627	        cos = .225 * (cos *-cos - cos) + cos;
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fneg
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  628	    else
	JR	L_176
L_172:
;  629	        cos = .225 * (cos * cos - cos) + cos;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  630		}
L_176:
;  631		return cos;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
;  632	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fastCos ***************************
;Name                         Addr/Register   Size   Type
;cos                                   IX-4      4   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: -6 (instruction)


;  633	 float fastSin(float x)
;  634	 {
_fastSin:
	LD	HL,-8
	CALL	__frameset
;  635		 float sin = 0;
;  636		 while ( x < -3.14159265 )
	JR	L_178
L_179:
;  637		 {
;  638			  x += 6.28318531;
	LD	HL,13176795
	LD	E,64
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fadd
	LD	(IX+6),BC
	LD	(IX+9),A
;  639		 }
L_178:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,4788187
	LD	A,192
	CALL	__fcmp
	JP	M,L_179
;  640		 while (x > 3.14159265)
	JR	L_180
L_181:
;  641		 {
;  642			  x -= 6.28318531;
	LD	HL,13176795
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+6),BC
	LD	(IX+9),A
;  643		 }
L_180:
	LD	HL,4788187
	LD	E,64
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	M,L_181
;  644		  
;  645		if (x < 0)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_188
;  646		{
;  647	    sin = 1.27323954 * x + .405284735 * x * x;
	LD	HL,13599099
	LD	E,62
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	HL,10680707
	LD	E,63
	CALL	__fadd
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  648	    
;  649	    if (sin < 0)
	LD	HL,BC
	LD	BC,0
	LD	E,(IX+-1)
	XOR	A,A
	CALL	__fcmp
	JP	P,L_184
;  650	        sin = .225 * (sin *-sin - sin) + sin;
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fneg
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  651	    else
	JR	L_190
L_184:
;  652	        sin = .225 * (sin * sin - sin) + sin;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  653		}
;  654		else
	JR	L_190
L_188:
;  655		{
;  656	    sin = 1.27323954 * x - 0.405284735 * x * x;
	LD	HL,10680707
	LD	E,63
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	(IX+-8),BC
	LD	(IX+-5),A
	LD	A,(IX+9)
	LD	BC,(IX+6)
	LD	HL,13599099
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-8)
	LD	A,(IX+-5)
	CALL	__fsub
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  657	    
;  658	    if (sin < 0)
	LD	HL,BC
	LD	BC,0
	LD	E,(IX+-1)
	XOR	A,A
	CALL	__fcmp
	JP	P,L_186
;  659	        sin = .225 * (sin *-sin - sin) + sin;
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fneg
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  660	    else
	JR	L_190
L_186:
;  661	        sin = .225 * (sin * sin - sin) + sin;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fsub
	LD	HL,6710886
	LD	E,62
	CALL	__fmul
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
	CALL	__fadd
	LD	(IX+-4),BC
	LD	(IX+-1),A
;  662		}
L_190:
;  663		return sin;
	LD	HL,(IX+-4)
	LD	E,(IX+-1)
;  664	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fastSin ***************************
;Name                         Addr/Register   Size   Type
;sin                                   IX-4      4   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 20 (bytes)
;       Spill Code: -6 (instruction)


;  665	 void drawMap()
;  666	 {
_drawMap:
	LD	HL,-44
	CALL	__frameset
;  667		 float lookview[2];
;  668		int face = 0;
;  669		float scale = 1.25;
;  670		lookview[0] = lookDirection[0];
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
;  671		lookview[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LEA	IY,IX+-11
;  672		//draw map box
;  673		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_gfx_SetColor
	POP	BC
;  674		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  675		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 50, 5);
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  676		gfx_Line_NoClip(LCD_WIDTH -50, 5, LCD_WIDTH - 50, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  677		gfx_Line_NoClip(LCD_WIDTH -50, 50, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  678	
;  679		//draw faces
;  680		for (face = 0; face < faceArrayCurrentSize; face++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_195
L_193:
;  681		{
;  682			gfx_SetColor(faceArray[face].color);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	IY,HL
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  683			gfx_Line_NoClip(faceArray[face].point1[0] * scale + LCD_WIDTH-25,  faceArray[face].point1[1]* -scale + 25,  faceArray[face].point2[0]* scale+ LCD_WIDTH-25,  faceArray[face].point2[1]* -scale + 25 );
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-20)
	LEA	BC,IY+8
	LD	(IX+-17),BC
	LEA	BC,IY+0
	LD	(IX+-14),BC
	LD	IY,(IX+-17)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	IY,(IX+-14)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  684		
;  685		}
L_195:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_193
;  686	
;  687		//draw player
;  688		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25 - 1,  playerPosition[1]* -scale +25,  playerPosition[0]* scale + LCD_WIDTH-25 + 1, playerPosition[1]* -scale +25);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-34),BC
	LD	(IX+-44),A
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,9699328
	LD	E,67
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-34)
	LD	A,(IX+-44)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13631488
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  689		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1]* -scale +25 -1,  playerPosition[0]* scale + LCD_WIDTH-25, playerPosition[1]* -scale +25 +1);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	(IX+-31),BC
	LD	(IX+-43),A
	LD	HL,13631488
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-31)
	LD	A,(IX+-43)
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  690		
;  691		//draw view
;  692		//
;  693		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
	OR	A,A
;  694		rotateVector(&lookview, fov/2);
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  695		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-27),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-28),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-28)
	LD	HL,(IX+-27)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-41),BC
	LD	(IX+-42),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-41)
	LD	A,(IX+-42)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-27)
	LD	A,(IX+-28)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  696		rotateVector(&lookview, -fov);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  697		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-23),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-24),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-24)
	LD	HL,(IX+-23)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-37),BC
	LD	(IX+-38),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-37)
	LD	A,(IX+-38)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-23)
	LD	A,(IX+-24)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  698		
;  699	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawMap ***************************
;Name                         Addr/Register   Size   Type
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_faceArrayCurrentSize               STATIC      3   variable
;_faceArray                          STATIC      3   variable
;_gfx_Line_NoClip                    IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;lookview                             IX-11      8   variable
;face                                  IX-3      3   variable


; Stack Frame Size: 50 (bytes)
;       Spill Code: -6 (instruction)


;  700	 //HAX
;  701	float fastSqrt( float n )
;  702	{
_fastSqrt:
	LD	HL,-7
	CALL	__frameset
;  703		// double a = (eventually the main method will plug values into a)
;  704		//double a = (double) n;
;  705		int i;
;  706		float a =n;
;  707		float x = 1;
	LD	BC,8388608
	LD	(IX+-7),BC
	LD	A,63
	LD	(IX+-4),A
;  708	 
;  709		// For loop to get the square root value of the entered number.
;  710		for(  i = 0; i < n; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_201
L_199:
;  711		{
;  712			x = 0.5 * ( x+a / x );
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	(IX+-7),BC
	LD	(IX+-4),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  713		}
L_201:
	LD	BC,(IX+-3)
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	M,L_199
;  714	 
;  715		return x;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
;  716	} 
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fastSqrt ***************************
;Name                         Addr/Register   Size   Type
;x                                     IX-7      4   variable
;i                                     IX-3      3   variable
;n                                     IX+6      4   parameter


; Stack Frame Size: 19 (bytes)
;       Spill Code: -6 (instruction)


;  717	void drawObjects()
;  718	{
_drawObjects:
	LD	HL,-77
	CALL	__frameset
;  719		
;  720		int num =0;
;  721		float dot;
;  722		float dist;
;  723		float distToFace;
;  724		bool hit;
;  725		int scale;
;  726		float angleFromCenter=0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  727		Ray testRay;
;  728		float toObject[2];
;  729		for (num = 0; num<numberOfObjects; num++)
	LD	(IX+-7),BC
	JR	L_211
L_209:
;  730		{
;  731			
;  732			toObject[0] = objectArray[num].position[0] - playerPosition[0];
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	IY,(IX+-46)
	LD	HL,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	E,A
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-20),BC
;  733			toObject[1] = objectArray[num].position[1] - playerPosition[1];
	LEA	BC,IX+-16
	LD	(IX+-17),A
	LD	(IX+-43),BC
	LEA	BC,IY+4
	LD	IY,_playerPosition
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	IY,(IX+-43)
	LD	(IY),BC
	LD	(IY+3),A
;  734			dot = (lookDirection[0] * toObject[0]) + (lookDirection[1] * toObject[1]);
	LD	BC,_lookDirection+4
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-72),BC
	LD	(IX+-73),A
;  735	
;  736			//get the angle of the sprite from the center 
;  737			angleFromCenter = -atan2((lookDirection[0]) *toObject[1] - (lookDirection[1]) * toObject[0], (lookDirection[0]) * toObject[0] + (lookDirection[1]) * toObject[1]);
	LD	A,(_lookDirection+3)
	LD	BC,(_lookDirection)
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	CALL	__fmul
	LD	E,(IX+-73)
	LD	HL,(IX+-72)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	A,(_lookDirection+3)
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	IY,(IX+-43)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(_lookDirection)
	CALL	__fmul
	LD	(IX+-76),BC
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	(IX+-77),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-76)
	LD	A,(IX+-77)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan2
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__fneg
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  738			
;  739			if (floatAbs(angleFromCenter) <= (fov/2))
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	(IX+-68),BC
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-69),A
	CALL	_floatAbs
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-68)
	LD	E,(IX+-69)
	CALL	__fcmp
	JP	M,L_210
;  740			{
;  741				//get distance to object
;  742				dist = (distanceBetween(&playerPosition, &objectArray[num].position));
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,_playerPosition
	PUSH	BC
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  743				//cast ray to nearest face and compare with distance to object
;  744				testRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-40
	LD	(IX+-52),BC
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  745				testRay.origin[1] = playerPosition[1];
	LD	IY,_playerPosition
	LEA	IY,IY+4
	LD	(IX+-61),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-61)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	LD	IY,(IX+-52)
	LEA	HL,IY+4
	LD	IY,(IX+-61)	; unspill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  746				testRay.direction[0] = toObject[0];
	LEA	BC,IX+-32
	LD	(IX+-49),BC
	LD	HL,BC
	LD	BC,(IX+-20)
	LD	A,(IX+-17)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  747				testRay.direction[1] = toObject[1];
	LEA	IY,IX+-16
	LD	(IX+-58),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-49)
;  748				ClosestFace(&testRay, &distToFace, &hit);
	PEA	IX+-8
	PEA	IX+-24
	PEA	IX+-40
	LEA	HL,IY+4
	LD	IY,(IX+-58)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  749				if (hit && dist >distToFace)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_207
	LD	HL,(IX+-24)
	LD	E,(IX+-21)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_210
;  750				{
;  751					//if the ray hit a face and that face is closer than the object, skip drawing it (it's obscured).
;  752					continue;
;  753				}
L_207:
;  754	
;  755				//change distance to the scale factor
;  756				dist =abs(1/((dist+3) *0.025)-2);
	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	HL,13421773
	LD	E,60
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fdiv
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
;  757				//limit dist to a minimum scale of 1
;  758				dist = max(dist,1);
	LD	C,63
	LD	B,0
	LD	(IX+-1),A
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  759				//set the color pallete
;  760				gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  761				//draw the scaled sprite.
;  762				gfx_ScaledTransparentSprite_NoClip(objectArray[num].sprite, (LCD_WIDTH/2) + (angleFromCenter *100 * fov) - (enemy1_width *dist)/2 ,LCD_HEIGHT/2 - (enemy1_height *dist)/2 ,dist,dist);
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	HL,12058624
	LD	E,65
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,15728640
	LD	A,66
	CALL	__fsub
	CALL	__ftol
	LD	HL,13107200
	LD	E,66
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fmul
	LD	H,A
	LD	A,(_fov+3)
	LD	E,A
	LD	A,H
	LD	HL,(_fov)
	CALL	__fmul
	LD	HL,2097152
	LD	E,67
	CALL	__fadd
	LD	(IX+-64),BC
	LD	(IX+-65),A
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	HL,7340032
	LD	E,65
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-64)
	LD	A,(IX+-65)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  763				
;  764			}
;  765		}
L_210:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_211:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_209
;  766		
;  767	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawObjects ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_max                                IMPORT  -----   function
;_abs                                IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_distanceBetween                    IMPORT  -----   function
;_floatAbs                           IMPORT  -----   function
;_fov                                STATIC      4   variable
;_atan2                              IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_playerPosition                     STATIC      8   variable
;_objectArray                        STATIC      3   variable
;testRay                              IX-40     16   variable
;distToFace                           IX-24      4   variable
;toObject                             IX-20      8   variable
;angleFromCenter                      IX-12      4   variable
;hit                                   IX-8      1   variable
;num                                   IX-7      3   variable
;dist                                  IX-4      4   variable


; Stack Frame Size: 83 (bytes)
;       Spill Code: -13 (instruction)


;  768	
;  769	
;  770	Face * mallocAndGenerateFace(float  point1x, float  point1y, float point2x, float point2y, uint8_t colorIndex)
;  771	{
_mallocAndGenerateFace:
	LD	HL,-6
	CALL	__frameset
;  772		Face * newFace = malloc(sizeof(Face));
	LD	BC,17
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;  773		newFace->point1[0] = point1x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+-6)
	LD	(IY+0),BC
	LD	(IY+3),A
;  774		newFace->point1[1] = point1y;
	LEA	HL,IY+4
	LD	BC,(IX+12)
	LD	A,(IX+15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  775		newFace->point2[0] = point2x;
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	BC,(IX+18)
	LD	A,(IX+21)
	LD	(IY+8),BC
	LD	(IY+11),A
;  776		newFace->point2[1] = point2y;
	LD	IY,(IX+-3)
	LEA	HL,IY+4
	LD	BC,(IX+24)
	LD	A,(IX+27)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  777		newFace->color = colorIndex;
	LD	A,(IX+30)
	LD	IY,(IX+-6)
	LD	(IY+16),A
;  778		return newFace;
	LD	HL,(IX+-6)
;  779	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mallocAndGenerateFace ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;newFace                               IX-6      3   variable
;colorIndex                           IX+30      1   parameter
;point2y                              IX+24      4   parameter
;point2x                              IX+18      4   parameter
;point1y                              IX+12      4   parameter
;point1x                               IX+6      4   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -13 (instruction)


;  780	
;  781	void loadLevel()
;  782	{
_loadLevel:
	LD	HL,-11
	CALL	__frameset
;  783		Object newObj;
;  784		numberOfObjects++;
	LD	BC,(_numberOfObjects)
	INC	BC
	LD	(_numberOfObjects),BC
;  785		//alloc object array
;  786		objectArray = malloc(sizeof(Object) * numberOfObjects);
	LD	HL,(_numberOfObjects)
	LD	A,11
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
;  787		//malloc sprite image
;  788		enemy1Sprite = gfx_MallocSprite(enemy1_width,enemy1_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	(_objectArray),HL
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_enemy1Sprite),HL
;  789		//decompress sprite image
;  790		zx7_Decompress(enemy1Sprite, enemy1_compressed);
	LD	BC,_enemy1_compressed
	PUSH	BC
	LD	BC,(_enemy1Sprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  791		newObj.sprite =  enemy1Sprite;
	LD	BC,(_enemy1Sprite)
	LD	(IX+-3),BC
;  792		
;  793		//set position
;  794		newObj.position[0] = -2;
	LD	BC,0
	LD	(IX+-11),BC
	LD	A,192
	LD	(IX+-8),A
;  795		newObj.position[1] = 2;
	LEA	IY,IX+-11
;  796		//add to array
;  797		objectArray[0] =newObj;
	LEA	HL,IX+-11
	LD	(IY+4),BC
	LD	(IY+7),64
	LD	DE,(_objectArray)
	LD	BC,11
	LDIR	
;  798		
;  799		
;  800	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadLevel ***************************
;Name                         Addr/Register   Size   Type
;_enemy1_compressed                  IMPORT    258   variable
;_zx7_Decompress                     IMPORT  -----   function
;_enemy1Sprite                       STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_objectArray                        STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_numberOfObjects                    STATIC      3   variable
;newObj                               IX-11     11   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: -13 (instruction)


;  801	
;  802	void unloadLevel()
;  803	{
_unloadLevel:
	LD	HL,-3
	CALL	__frameset
;  804		int j =0;
;  805		for (j=0;j<numberOfObjects;j++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_219
L_217:
;  806		{
;  807			free(objectArray[j].sprite);
	LD	HL,(IX+-3)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  808		}
L_219:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_217
;  809		free(objectArray);
	LD	BC,(_objectArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  810	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _unloadLevel ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_objectArray                        STATIC      3   variable
;_free                               IMPORT  -----   function
;j                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: -13 (instruction)


;  811	
;  812	void printText(const char *text, uint8_t xpos, uint8_t ypos) {
_printText:
	CALL	__frameset0
;  813	    os_SetCursorPos(ypos, xpos);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+12)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  814	    os_PutStrFull(text);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  815	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -13 (instruction)


;  816	
;  817	/* Draw small text at the given X/Y location */
;  818	void printTextSmall(const char *text, uint8_t xpos, uint8_t ypos) {
_printTextSmall:
	CALL	__frameset0
;  819	    os_FontSelect(0); // sets small font (1 == big, see docs)
	LD	BC,0
	PUSH	BC
	CALL	_os_FontSelect
	POP	BC
;  820	    os_FontDrawText(text, xpos, ypos);
	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_FontDrawText
	POP	BC
	POP	BC
	POP	BC
;  821	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printTextSmall ***************************
;Name                         Addr/Register   Size   Type
;_os_FontDrawText                    IMPORT  -----   function
;_os_FontSelect                      IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -13 (instruction)


;  822	
;  823	float fastACos(float x)
;  824	{
_fastACos:
	CALL	__frameset0
;  825		return (-0.69813170079773 * x * x - 0.87266462599716) * x + 1.5707963267948;
	LD	HL,3324098
	LD	E,191
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fmul
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	HL,6252275
	LD	E,63
	CALL	__fsub
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fmul
	LD	HL,13176795
	LD	E,63
	CALL	__fadd
	LD	E,A
	LD	HL,BC
;  826	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _fastACos ***************************
;Name                         Addr/Register   Size   Type
;x                                     IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -13 (instruction)


;  827	float floatAbs(float x)
;  828	{
_floatAbs:
	CALL	__frameset0
;  829		if (x<0)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_226
;  830		{
;  831			return -x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	E,A
	LD	HL,BC
	JR	L_227
;  832		}
L_226:
;  833		return x;
	LD	HL,(IX+6)
	LD	E,(IX+9)
;  834	}
L_227:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _floatAbs ***************************
;Name                         Addr/Register   Size   Type
;x                                     IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: -13 (instruction)


;  835	float max(float x, float y)
;  836	{
_max:
	CALL	__frameset0
;  837		if (x>y)
	LD	HL,(IX+12)
	LD	E,(IX+15)
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fcmp
	JP	P,L_229
;  838		{
;  839			return x;
	LD	HL,(IX+6)
	LD	E,(IX+9)
	JR	L_230
;  840		}
L_229:
;  841		return y;
	LD	HL,(IX+12)
	LD	E,(IX+15)
;  842	}
L_230:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _max ***************************
;Name                         Addr/Register   Size   Type
;y                                    IX+12      4   parameter
;x                                     IX+6      4   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -13 (instruction)


;  843	float min(float x, float y)
;  844	{
_min:
	CALL	__frameset0
;  845		if (x<y)
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,(IX+12)
	LD	A,(IX+15)
	CALL	__fcmp
	JP	P,L_232
;  846		{
;  847			return x;
	LD	HL,(IX+6)
	LD	E,(IX+9)
	JR	L_233
;  848		}
L_232:
;  849		return y;
	LD	HL,(IX+12)
	LD	E,(IX+15)
L_233:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _min ***************************
;Name                         Addr/Register   Size   Type
;y                                    IX+12      4   parameter
;x                                     IX+6      4   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -13 (instruction)


	XREF _gfx_group_pal:ROM
	XREF _enemy1_compressed:ROM
	XREF _doomak2_compressed:ROM
	XREF _zx7_Decompress:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_ScaledTransparentSprite_NoClip:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintString:ROM
	XREF _gfx_Blit:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_Line_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _calloc:ROM
	XREF _sqrt:ROM
	XREF _atan2:ROM
	XREF _asm_DrawStatusBar:ROM
	XREF _asm_ClrLCD:ROM
	XREF _asm_HomeUp:ROM
	XREF __OS:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_FontDrawText:ROM
	XREF _os_FontSelect:ROM
	XREF _os_SetCursorPos:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __lremu:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __imul_b:ROM
	XREF __ishrs_b:ROM
	XDEF _min
	XDEF _max
	XDEF _floatAbs
	XDEF _fastACos
	XDEF _printTextSmall
	XDEF _printText
	XDEF _unloadLevel
	XDEF _loadLevel
	XDEF _mallocAndGenerateFace
	XDEF _drawObjects
	XDEF _fastSqrt
	XDEF _drawMap
	XDEF _fastSin
	XDEF _fastCos
	XDEF _distanceBetween
	XDEF _gcvt
	XDEF _normalizeVector
	XDEF _rotateVector
	XDEF _root
	XDEF _GetRayToFaceIntersection
	XDEF _ClosestFace
	XDEF _draw
	XDEF _step
	XDEF _movementRay
	XDEF _end
	XDEF _begin
	XDEF _main
	XDEF _enemy1Sprite
	XDEF _enemy1Sprite_data
	XDEF _akSprite
	XDEF _akSprite_data
	XDEF _nyiError
	XDEF _key
	XDEF _partial_redraw
	XDEF _objectArray
	XDEF _faceArray
	XDEF _FACEARRAYMAXSIZE
	XDEF _playerPosition
	XDEF _lookDirection
	XDEF _MAX_DISTANCE
	XDEF _RENDER_WIDTH
	XDEF _DISTANCE_FOG
	XDEF _fov
	XDEF _multiplier
	XDEF _focalLength
	XDEF _lineSpacing
	XDEF _freeLookupTable
	XDEF _lookupSqrt
	XDEF _generateLookupTable
	XDEF _lut
	END
