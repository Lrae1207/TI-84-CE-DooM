; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_lut:
	DS	3
	SEGMENT DATA
_lookupTableSize:
	DW	0
	DB	0
_skip:
	DW	0
	DB	0
	SEGMENT CODE
_generateLookupTable:
	LD	HL,-9
	CALL	__frameset
	LD	BC,(IX+6)
	LD	(_lookupTableSize),BC
	LD	BC,(IX+9)
	LD	(_skip),BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(_lut),HL
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
	LD	HL,(_skip)
	LD	BC,(IX+-3)
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-6),HL	; spill
	LD	(IX+-9),HL	; spill
	LD	HL,(IX+-3)
	LD	BC,(_lut)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-9)	; unspill
	LD	(IY),HL
	LD	(IY+3),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_3:
	LD	BC,(IX+6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _generateLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;_lut                                STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_skip                               STATIC      3   variable
;_lookupTableSize                    STATIC      3   variable
;i                                     IX-3      3   variable
;ski                                   IX+9      3   parameter
;size                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


_lookupSqrt:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(_lookupTableSize)
	DEC	BC
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fcmp
	JP	M,L_6
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	JR	L_7
L_6:
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	HL,(_skip)
	CALL	__imuls
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(_lut)
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,BC
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_lut)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupSqrt ***************************
;Name                         Addr/Register   Size   Type
;_lut                                STATIC      3   variable
;_skip                               STATIC      3   variable
;_sqrt                               IMPORT  -----   function
;_lookupTableSize                    STATIC      3   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


_freeLookupTable:
	LD	BC,(_lut)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,0
	LD	(_lookupTableSize),BC
	RET	


;**************************** _freeLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTableSize                    STATIC      3   variable
;_lut                                STATIC      3   variable
;_free                               IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT DATA
_lineSpacing:
	DW	20
	DB	0
_focalLength:
	DF	5.0
_multiplier:
	DF	50.0
_fov:
	DF	1.57079637050629
	SEGMENT TEXT
_DISTANCE_FOG:
	DB	1
_RENDER_WIDTH:
	DW	100
	DB	0
_MAX_DISTANCE:
	DF	2.0
	SEGMENT DATA
_lookDirection:
	DF	0.0
	DF	1.0
_playerPosition:
	DF	0.0
	DF	0.0
	SEGMENT TEXT
_FACEARRAYMAXSIZE:
	DW	10
	DB	0
	SEGMENT BSS
_faceArray:
	DS	3
	SEGMENT DATA
_faceArrayCurrentSize:
	DW	0
	DB	0
_numberOfObjects:
	DW	0
	DB	0
	SEGMENT BSS
_objectArray:
	DS	3
_partial_redraw:
	DS	1
_key:
	DS	1
	SEGMENT STRSECT
L__5:
	DB	"Not Yet Implemented"
	DB	0
	SEGMENT DATA
_nyiError:
	DW24	L__5
	SEGMENT BSS
_akSprite_data:
	DS	3076
	SEGMENT DATA
_akSprite:
	DW24	_akSprite_data
	SEGMENT BSS
_enemy1Sprite_data:
	DS	347
	SEGMENT DATA
_enemy1Sprite:
	DW24	_enemy1Sprite_data
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <graphx.h>
;   10	#include <debug.h>
;   11	#include <keypadc.h>
;   12	#include <assert.h>
;   13	#include <compression.h>
;   14	#include "gfx/gfx_group.h"
;   15	#include "lookup_table.h"
;   16	#include "helpers.h"
;   17	typedef struct 
;   18	{
;   19		float origin[2];
;   20		float direction[2];
;   21	
;   22	}Ray;
;   23	typedef struct 
;   24	{
;   25		uint8_t r,g,b;
;   26	}Color;
;   27	typedef struct 
;   28	{
;   29		float point1[2];
;   30		float point2[2];
;   31		uint8_t color;
;   32	}Face;
;   33	typedef struct{
;   34		float position[2];
;   35		gfx_sprite_t * sprite;	
;   36	}Object;
;   37	
;   38	int lineSpacing = 20;
;   39	float focalLength = 5.0;
;   40	float multiplier = 50;
;   41	
;   42	float fov = M_PI/2;
;   43	const bool DISTANCE_FOG = true;
;   44	const int RENDER_WIDTH = 100;
;   45	const float MAX_DISTANCE = 2;
;   46	float lookDirection[] = {0,1};
;   47	float playerPosition[] = {0,0};
;   48	const int FACEARRAYMAXSIZE = 10;
;   49	Face * faceArray;
;   50	static int faceArrayCurrentSize = 0;
;   51	static int numberOfObjects = 0;
;   52	#define OBJECTARRAYMAXSIZE  10
;   53	
;   54	Object * objectArray;
;   55	
;   56	
;   57	void loadLevel();
;   58	void printTextSmall(const char *, uint8_t , uint8_t);
;   59	void printText(const char *, uint8_t, uint8_t );
;   60	Face * mallocAndGenerateFace(float , float, float, float , uint8_t);
;   61	void drawObjects();
;   62	void drawMap();
;   63	
;   64	Face *ClosestFace(Ray*, float*, bool*);
;   65	void GetRayToFaceIntersection(Ray*, Face*, float * ,bool *);
;   66	
;   67	char * gcvt(float, size_t, char *);
;   68	void begin();
;   69	void end();
;   70	void step();
;   71	void draw();
;   72	bool partial_redraw;
;   73	kb_key_t key;
;   74	
;   75	
;   76	
;   77	char * nyiError = "Not Yet Implemented";
;   78	gfx_UninitedSprite(akSprite, doomak2_width,doomak2_height);
;   79	gfx_UninitedSprite(enemy1Sprite, enemy1_width, enemy1_height);
	SEGMENT CODE
;   80	void main() {
_main:
	LD	HL,-18
	CALL	__frameset
;   81		
;   82		int i;
;   83		Face * testFace;
;   84		Face * testFace2;	
;   85		Face * testFace3;
;   86		Face * testFace4;
;   87		
;   88		float  * destination  = calloc(2 , sizeof(float));
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(IX+-18),HL
;   89		bool  hit = false;
;   90		faceArray = calloc(FACEARRAYMAXSIZE ,sizeof(Face));
	LD	BC,17
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
;   91	
;   92		
;   93	
;   94	
;   95		//create test walls
;   96		testFace = mallocAndGenerateFace(-5,6,5,6, 65);
	LD	BC,65
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	LD	(_faceArray),HL
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-6),HL
;   97		testFace2 = mallocAndGenerateFace(-5,-5,5,-5,12);
	LD	BC,12
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	C,64
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-9),HL
;   98		testFace3 = mallocAndGenerateFace(-7,7,-7,-7,02);
	LD	BC,2
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	DE,14680064
	PUSH	DE
	PUSH	BC
	LD	C,64
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	LD	BC,14680064
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-12),HL
;   99		testFace4 = mallocAndGenerateFace(4,-9,8,2,196);
	LD	BC,196
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	C,65
	LD	DE,0
	PUSH	DE
	PUSH	BC
	LD	C,193
	PUSH	DE
	PUSH	BC
	LD	C,64
	LD	DE,1048576
	PUSH	DE
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-15),HL
;  100		faceArray[0] = *testFace;
	LD	DE,(_faceArray)
	LD	HL,(IX+-6)
	LD	BC,17
	LDIR	
;  101		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  102		faceArray[1] = *testFace2;
	LD	IY,(_faceArray)
	LEA	DE,IY+17
	LD	HL,(IX+-9)
	LD	BC,17
	LDIR	
;  103		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  104		faceArray[2] = *testFace3;
	LD	IY,(_faceArray)
	LEA	DE,IY+34
	LD	HL,(IX+-12)
	LD	BC,17
	LDIR	
;  105		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  106		faceArray[3] = *testFace4;
	LD	IY,(_faceArray)
	LEA	DE,IY+51
	LD	HL,(IX+-15)
	LD	BC,17
	LDIR	
;  107		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  108		//generateLookupTable(1000, 1);
;  109	
;  110	    loadLevel();
	CALL	_loadLevel
;  111		begin(); // No rendering allowed!
	CALL	_begin
;  112		
;  113	
;  114		
;  115		//sets up NYI error message
;  116		for (i = 0; i < 20; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_16
L_14:
;  117		{
;  118			os_AppErr1[i] =nyiError[i];
	LD	BC,(IX+-3)
	LD	HL,(_nyiError)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,13641129
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  119			
;  120		}
L_16:
	LD	BC,20
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;  121		
;  122		
;  123		//allocates and decompresses gun sprite
;  124		akSprite = gfx_MallocSprite(doomak2_width,doomak2_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,58
	PUSH	BC
	LD	BC,53
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_akSprite),HL
;  125		zx7_Decompress(akSprite, doomak2_compressed);
	LD	BC,_doomak2_compressed
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  126		
;  127	    gfx_Begin();
	CALL	_gfx_Begin
;  128	    gfx_SetDrawBuffer(); // Draw to the buffer to avoid rendering artifats
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  129		
;  130		kb_Scan();
	CALL	_kb_Scan
;  131		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  132			
;  133	    while (kb_Data[1] !=kb_2nd) { 
	JR	L_20
L_21:
;  134			step();// No rendering allowed in step!
	CALL	_step
;  135	        if (partial_redraw) // Only want to redraw part of the previous frame?
	LD	A,(_partial_redraw)
	OR	A,A
	JR	Z,L_19
;  136	            gfx_BlitScreen(); // Copy previous frame as a base for this frame
	LD	BC,0
	PUSH	BC
	CALL	_gfx_Blit
	POP	BC
L_19:
;  137	        draw(); // As little non-rendering logic as possible
	CALL	_draw
;  138	        gfx_SwapDraw(); // Queue the buffered frame to be displayed
	CALL	_gfx_SwapDraw
;  139	    }
L_20:
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_21
;  140	
;  141	    gfx_End();
	CALL	_gfx_End
;  142	    end();
	CALL	_end
;  143		
;  144		
;  145		os_ClrHome();
	LD	BC,_asm_ClrLCD
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_HomeUp
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_DrawStatusBar
	PUSH	BC
	CALL	__OS
	POP	BC
;  146		
;  147		
;  148		while (!os_GetCSC());
L_26:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_26
;  149		free(destination);
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_free
	POP	BC
;  150		free(testFace);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  151		free(testFace2);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  152		free(testFace3);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  153		free(faceArray);
	LD	BC,(_faceArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  154		free(akSprite);
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_free
	POP	BC
;  155		//freeLookupTable();
;  156	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_asm_DrawStatusBar                  IMPORT  -----   function
;_asm_HomeUp                         IMPORT  -----   function
;_asm_ClrLCD                         IMPORT  -----   function
;__OS                                IMPORT  -----   function
;_end                                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_draw                               IMPORT  -----   function
;_gfx_Blit                           IMPORT  -----   function
;_partial_redraw                     STATIC      1   variable
;_step                               IMPORT  -----   function
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_doomak2_compressed                 IMPORT   1819   variable
;_zx7_Decompress                     IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_nyiError                           STATIC      3   variable
;_begin                              IMPORT  -----   function
;_loadLevel                          IMPORT  -----   function
;_faceArrayCurrentSize               STATIC      3   variable
;_mallocAndGenerateFace              IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_calloc                             IMPORT  -----   function
;destination                          IX-18      3   variable
;testFace4                            IX-15      3   variable
;testFace3                            IX-12      3   variable
;testFace2                             IX-9      3   variable
;testFace                              IX-6      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 24 (bytes)
;       Spill Code: -1 (instruction)


;  157	
;  158	/* Put other functions here */
;  159	void begin() {	
_begin:
;  160			gfx_SetTransparentColor(gfx_group_transparent_color_index);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  161		
;  162	}
	RET	


;**************************** _begin ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetTransparentColor            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  163	
;  164	void end() {
_end:
;  165	    /* Implement me! */
;  166	}
	RET	


;**************************** _end ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT BSS
_movementRay:
	DS	16
;  167	Ray movementRay;
	SEGMENT CODE
;  168	void step() {
_step:
	LD	HL,-56
	CALL	__frameset
;  169	  	float distanceFromCam;
;  170		  bool hit;
;  171		movementRay.origin[0] = playerPosition[0];
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
;  172		movementRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-47),HL	; spill
	LD	(_movementRay),BC
	LD	(_movementRay+3),A
	LD	HL,_movementRay+4
	LD	(IX+-44),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+-44)	; unspill
	LD	(IX+-50),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-50)	; unspill
	LD	(IX+-53),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-53)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	INC	HL
	LD	(IX+-47),HL	; spill
	LD	HL,(IX+-56)	; unspill
	LD	(IX+-56),HL	; spill
	LD	HL,(IX+-47)	; unspill
	LD	A,(HL)
	LD	HL,(IX+-56)	; unspill
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  173		//keypad input
;  174		kb_Scan();
	CALL	_kb_Scan
;  175		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  176		//back
;  177		 if (kb_Data[4] & kb_2) {
	LD	A,(16056344)
	AND	A,2
	JR	Z,L_38
;  178			 	movementRay.direction[0] =  -lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-20),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(_movementRay+8),BC
;  179				movementRay.direction[1] =  -lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(_movementRay+11),A
	LD	(IX+-17),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	IY,(IX+-20)
;  180				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  181				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_33
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_38
L_33:
	OR	A,A
;  182				{
;  183	           		playerPosition[0] = playerPosition[0] + lookDirection[0] * -0.5;
	SBC	HL,HL
	LD	E,191
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  184					playerPosition[1] = playerPosition[1] + lookDirection[1] * -0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-23),BC
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,191
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-23)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  185				}
;  186				
;  187	        } 
L_38:
;  188			//forward
;  189	        if (kb_Data[4] & kb_8) {
	LD	A,(16056344)
	AND	A,8
	JR	Z,L_42
;  190				movementRay.direction[0] =  lookDirection[0];
	LD	BC,_movementRay+8
	LD	(IX+-26),BC
	LD	HL,BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  191				movementRay.direction[1] =  lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(HL),A
	LD	(IX+-8),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-26)
;  192				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	INC	HL
	INC	HL
	LD	DE,_movementRay
	PUSH	DE
	INC	HL
	LD	A,(HL)
	LEA	HL,IY+4
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  193				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_42
L_36:
	OR	A,A
;  194				{
;  195	            	playerPosition[0] = playerPosition[0] + lookDirection[0] * 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  196					playerPosition[1] = playerPosition[1] + lookDirection[1] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-29),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-29)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  197				}
;  198				
;  199	        } 
L_42:
;  200			//left
;  201	        if (kb_Data[3] & kb_4) {
	LD	A,(16056342)
	AND	A,4
	JR	Z,L_46
;  202				movementRay.direction[0] =  -lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-32),BC
	LD	(IX+-11),DE
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fneg
	LD	IY,(IX+-32)
	LD	(IY),BC
	LD	(IY+3),A
;  203				movementRay.direction[1] =  lookDirection[0];
;  204				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LEA	HL,IY+4
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	LD	BC,_movementRay
	PUSH	BC
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  205				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_40
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_46
L_40:
;  206				{
;  207	            	playerPosition[0] = playerPosition[0] - lookDirection[1] * 0.5;
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fsub
	LD	(_playerPosition),BC
;  208					playerPosition[1] = playerPosition[1] + lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-35),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-35)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  209				}
;  210	        } 
L_46:
;  211			//right
;  212	        if (kb_Data[5] & kb_6) {
	LD	A,(16056346)
	AND	A,4
	JR	Z,L_48
;  213				movementRay.direction[0] =  lookDirection[1];
	LD	BC,_movementRay+8
	LD	DE,_lookDirection+4
	LD	(IX+-38),BC
	LD	(IX+-14),DE
	LD	HL,(IX+-14)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	HL,(IX+-38)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  214				movementRay.direction[1] =  -lookDirection[0];
	LD	IY,(IX+-38)
;  215				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	DE,_movementRay
	PUSH	DE
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  216				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_44
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_48
L_44:
;  217				{
;  218	            	playerPosition[0] = playerPosition[0] + lookDirection[1] * 0.5;
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  219					playerPosition[1] = playerPosition[1] - lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-41),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-41)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IY),BC
	LD	(IY+3),A
;  220				}
;  221				
;  222	        } 
L_48:
;  223			if (kb_Data[3] & kb_7)
	LD	A,(16056342)
	AND	A,8
	JR	Z,L_50
;  224			{
;  225				rotateVector(&lookDirection, 0.2);
	LD	C,62
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  226			}
L_50:
;  227			if (kb_Data[5] & kb_9)
	LD	A,(16056346)
	AND	A,8
	JR	Z,L_52
;  228			{
;  229				rotateVector(&lookDirection, -0.2);
	LD	C,190
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  230			}
L_52:
;  231			if (kb_Data[7] & kb_Up)
	LD	A,(16056350)
	AND	A,8
	JR	Z,L_54
;  232			{
;  233				fov+= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fadd
	LD	(_fov),BC
	LD	(_fov+3),A
;  234			}
L_54:
;  235			if (kb_Data[7] & kb_Down)
	LD	A,(16056350)
	AND	A,1
	JR	Z,L_57
;  236			{
;  237				fov-= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fsub
	LD	(_fov),BC
	LD	(_fov+3),A
;  238			}
L_57:
;  239			if (kb_Data[7] & kb_Left)
	LD	A,(16056350)
	AND	A,2
	JR	Z,L_61
;  240			{
;  241				lineSpacing++;
	LD	BC,(_lineSpacing)
	INC	BC
	LD	(_lineSpacing),BC
;  242			}
L_61:
;  243			if (kb_Data[7] & kb_Right)
	LD	A,(16056350)
	AND	A,4
	JR	Z,L_63
;  244			{
;  245				if (lineSpacing > 1)
	LD	BC,(_lineSpacing)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JP	P,L_63
;  246				{
;  247					lineSpacing--;
	LD	BC,(_lineSpacing)
	DEC	BC
	LD	(_lineSpacing),BC
;  248				}
;  249			}
L_63:
;  250			if (kb_Data[6] & kb_Add)
	LD	A,(16056348)
	AND	A,2
	JR	Z,L_66
;  251			{
;  252				multiplier+= 5;
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fadd
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  253			}
L_66:
;  254			if (kb_Data[6] & kb_Sub)
	LD	A,(16056348)
	AND	A,4
	JR	Z,L_68
;  255			{
;  256				if (multiplier > 5)
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fcmp
	JP	P,L_68
;  257				{
;  258					multiplier-= 5;
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fsub
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  259				}
;  260			}
L_68:
;  261			if (kb_Data[6] & kb_Mul)
	LD	A,(16056348)
	AND	A,8
	JR	Z,L_71
	OR	A,A
;  262			{
;  263				focalLength += 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fadd
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  264			}
L_71:
;  265			if (kb_Data[6] & kb_Div)
	LD	A,(16056348)
	AND	A,16
	JR	Z,L_72
	OR	A,A
;  266			{
;  267				if (focalLength > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fcmp
	JP	P,L_72
	OR	A,A
;  268				{
;  269					focalLength -= 0.5;
	SBC	HL,HL
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fsub
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  270				}
;  271			}
;  272	}
L_72:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _step ***************************
;Name                         Addr/Register   Size   Type
;_focalLength                        STATIC      4   variable
;_multiplier                         STATIC      4   variable
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_movementRay                        STATIC     16   variable
;_playerPosition                     STATIC      8   variable
;G_0                                  IX-17      3   variable
;G_3                                  IX-14      3   variable
;G_2                                  IX-11      3   variable
;G_1                                   IX-8      3   variable
;distanceFromCam                       IX-5      4   variable
;hit                                   IX-1      1   variable


; Stack Frame Size: 62 (bytes)
;       Spill Code: -1 (instruction)


;  273	
;  274	void draw() {
_draw:
	LD	HL,-61
	CALL	__frameset
;  275		int row = LCD_WIDTH/2;
;  276		int fillSpacing = 0;
;  277		int temp = 0;
;  278		float closeDist = -1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,191
	LD	(IX+-8),A
;  279		float fardist = 2;
;  280		float res[2];
;  281		char buf[10];
;  282		bool hmm = false;
	LD	(IX+-7),0
;  283		Face * hit ;
;  284		Ray  lookRay ;
;  285		float newClose;
;  286		float angleFromCenter = 0;
;  287		//145,156,255,221,205,190, or 165
;  288		gfx_FillScreen(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  289		
;  290		lookRay.direction[0] = lookDirection[0];
	LEA	BC,IX+-39
	LD	(IX+-53),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(IX+-39),BC
;  291		lookRay.direction[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-36),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LEA	IY,IX+-35
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+3),A
;  292		lookRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-47
	LD	(IX+-50),BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(IX+-47),BC
;  293		lookRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-44),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	IY,(IX+-50)
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
;  294		//rotate the ray to the very left in preparation for spinning it around
;  295		rotateVector(&lookRay.direction, fov/2);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+-53)
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
;  296		angleFromCenter = fov/2;
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  297		
;  298		//loop for each vertical line
;  299		
;  300		for (row = 0; row <LCD_WIDTH; row+= lineSpacing){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_83
L_81:
;  301		
;  302			//rotate ray by a small amount and then cast again
;  303			rotateVector(&(lookRay.direction), -((float)fov / LCD_WIDTH) * lineSpacing);
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-60),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-61),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-60)
	LD	A,(IX+-61)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-39
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  304			angleFromCenter += -((float)fov / LCD_WIDTH) * lineSpacing;
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-56),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-57),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-56)
	LD	A,(IX+-57)
	CALL	__fmul
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	CALL	__fadd
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  305			hit = ClosestFace(&lookRay, &closeDist, &hmm);
	PEA	IX+-7
	PEA	IX+-11
	PEA	IX+-47
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  306			
;  307			//if hit
;  308			if (hmm && hit != 0)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_82
	LD	HL,(IX+-17)
	CALL	__icmpzero
	JR	Z,L_82
;  309			{
;  310				
;  311				gfx_SetColor(hit->color);
	LD	IY,(IX+-17)
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  312				closeDist = closeDist * fastCos(angleFromCenter);
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
;  313				temp =(focalLength/closeDist) * multiplier;
	LD	HL,BC
	LD	BC,(_focalLength)
	LD	E,(IX+-8)
	LD	A,(_focalLength+3)
	CALL	__fdiv
	LD	H,A
	LD	A,(_multiplier+3)
	LD	E,A
	LD	A,H
	LD	HL,(_multiplier)
	CALL	__fmul
	CALL	__ftol
;  314				if (temp < 0)
	LD	HL,BC
	CALL	__icmpzero
	LD	(IX+-6),BC
	JP	P,L_76
;  315				{
;  316					temp = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  317				}
L_76:
;  318				if (temp > LCD_HEIGHT/2 -1)
	LD	BC,(IX+-6)
	LD	HL,119
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  319				{
;  320					temp = LCD_HEIGHT/2 -1;
	LD	BC,119
	LD	(IX+-6),BC
;  321				}
L_77:
;  322				/*
;  323					for (fillSpacing = 1; fillSpacing < lineSpacing && fillSpacing + row < LCD_WIDTH; fillSpacing++)
;  324					{
;  325						gfx_Line_NoClip(row+ fillSpacing, LCD_HEIGHT/2.0 + temp, row+ fillSpacing, LCD_HEIGHT/2.0 - temp);
;  326					}
;  327				*/
;  328				fillSpacing = lineSpacing;
	LD	BC,(_lineSpacing)
	LD	(IX+-14),BC
;  329				if (row + fillSpacing >= LCD_WIDTH)
	LD	HL,(IX+-3)
	ADD	HL,BC
	OR	A,A
	LD	BC,320
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  330				{
;  331					fillSpacing = LCD_WIDTH-row;
	LD	BC,(IX+-3)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	(IX+-14),HL
;  332				}
L_79:
;  333				
;  334				gfx_FillRectangle_NoClip(row,LCD_HEIGHT/2 - temp,fillSpacing, 2 * temp );
	LD	A,(IX+-6)
	ADD	A,A
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	A,120
	LD	BC,(IX+-14)
	PUSH	BC
	LD	B,(IX+-6)
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  335			}
;  336			
;  337			
;  338			
;  339		}
L_82:
	LD	BC,(IX+-3)
	LD	HL,(_lineSpacing)
	ADD	HL,BC
	LD	(IX+-3),HL
L_83:
	LD	BC,320
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_81
;  340			//draw position and rotation text
;  341			gcvt(playerPosition[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_playerPosition+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  342			gfx_SetTextFGColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  343			gfx_SetTextXY(0,0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  344			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  345			gcvt(playerPosition[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  346			gfx_SetTextXY(75,0);
	LD	BC,0
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  347			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  348			gcvt(lookDirection[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_lookDirection+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_lookDirection)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  349			gfx_SetTextXY(0,20);
	LD	BC,20
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  350			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  351			gcvt(lookDirection[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  352			gfx_SetTextXY(75,20);
	LD	BC,20
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  353			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  354			
;  355			//draw objects
;  356			drawObjects();
	CALL	_drawObjects
;  357			
;  358			//draw gun sprite
;  359			gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  360			gfx_ScaledTransparentSprite_NoClip(akSprite, (LCD_WIDTH /2) - 68 , LCD_HEIGHT - doomak2_height * 2, 2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	BC,124
	PUSH	BC
	LD	BC,92
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  361			
;  362			//draw crosshair
;  363			gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  364			gfx_Line_NoClip(LCD_WIDTH/2 - 2, LCD_HEIGHT/2, LCD_WIDTH/2 + 2, LCD_HEIGHT/2);
	LD	BC,120
	PUSH	BC
	LD	BC,162
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,158
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  365			gfx_Line_NoClip(LCD_WIDTH/2 , LCD_HEIGHT/2 - 2, LCD_WIDTH/2 , LCD_HEIGHT/2 + 2);
	LD	BC,122
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,118
	PUSH	BC
	LD	BC,160
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  366			
;  367	
;  368			//draw the overhead map
;  369			drawMap();
	CALL	_drawMap
;  370			
;  371	
;  372		
;  373	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _draw ***************************
;Name                         Addr/Register   Size   Type
;_drawMap                            IMPORT  -----   function
;_gfx_Line_NoClip                    IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_drawObjects                        IMPORT  -----   function
;_gfx_PrintString                    IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gcvt                               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_multiplier                         STATIC      4   variable
;_focalLength                        STATIC      4   variable
;_fastCos                            IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_lookDirection                      STATIC      8   variable
;_gfx_FillScreen                     IMPORT  -----   function
;lookRay                              IX-47     16   variable
;buf                                  IX-31     10   variable
;angleFromCenter                      IX-21      4   variable
;hit                                  IX-17      3   variable
;fillSpacing                          IX-14      3   variable
;closeDist                            IX-11      4   variable
;hmm                                   IX-7      1   variable
;temp                                  IX-6      3   variable
;row                                   IX-3      3   variable


; Stack Frame Size: 67 (bytes)
;       Spill Code: -1 (instruction)


;  374	Face *ClosestFace(Ray *ray, float *distance, bool * hitOrNot)
;  375	{
_ClosestFace:
	LD	HL,-26
	CALL	__frameset
;  376		float closestDist;
;  377		int i;
;  378		float hitpoint[2];
;  379		//float * hitpoint  = malloc(2 * sizeof(float));
;  380		float dist = 0;
	LD	BC,0
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  381		bool  didhit;
;  382		//pointer to the face in facearray that was hit
;  383		Face * outface = NULL;
	LD	(IX+-11),BC
;  384		*distance = -1;
	LD	HL,(IX+9)
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  385		closestDist = 999999;
	LD	BC,7611376
	LD	(IX+-7),BC
	LD	A,73
	LD	(IX+-4),A
;  386		*hitOrNot = false;
	LD	HL,(IX+12)
	LD	(HL),0
;  387		
;  388		//check if passed null pointers
;  389		if (ray == NULL || distance == NULL || hitOrNot == NULL)
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_97
L_88:
	OR	A,A
;  390		{
;  391			return outface;
	SBC	HL,HL
	JR	L_99
;  392		}
L_97:
;  393		
;  394		for (i = 0; i<faceArrayCurrentSize; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_96
L_94:
;  395		{
;  396			
;  397			GetRayToFaceIntersection(ray, &(faceArray[i]), &hitpoint, &didhit);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	(IX+-14),HL
	PEA	IX+-8
	PEA	IX+-26
	LD	BC,(_faceArray)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_GetRayToFaceIntersection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  398			
;  399			//if successfully hit something
;  400			if (didhit)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_93
;  401			{
;  402				
;  403				*hitOrNot = true;
	LD	HL,(IX+12)
;  404				dist = distanceBetween(ray->origin, hitpoint);
	PEA	IX+-26
	LD	(HL),1
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  405				//if closer than closest face so far, set face that its currently checking to be the closest face
;  406				if (dist < closestDist)
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	CALL	__fcmp
	JP	P,L_93
;  407				{
;  408					closestDist = dist;
	LD	BC,(IX+-18)
	LD	A,(IX+-15)
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  409					outface = &(faceArray[i]);
	LD	BC,(IX+-14)
	LD	HL,(_faceArray)
	ADD	HL,BC
	LD	(IX+-11),HL
;  410				}
;  411			}
L_93:
;  412			
;  413			//*distance = closestDist;
;  414			//if closest dist was changed
;  415			if (closestDist < 999999)
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,7611376
	LD	A,73
	CALL	__fcmp
	JP	P,L_95
;  416			{
;  417				
;  418				*hitOrNot = true;
	LD	HL,(IX+12)
	LD	(HL),1
;  419				*distance = closestDist;
	LD	HL,(IX+9)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  420				return outface;
	LD	HL,(IX+-11)
	JR	L_99
;  421			}
;  422		}
L_95:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_96:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
;  423		
;  424		return outface;
	LD	HL,(IX+-11)
;  425	}
L_99:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ClosestFace ***************************
;Name                         Addr/Register   Size   Type
;_faceArrayCurrentSize               STATIC      3   variable
;_distanceBetween                    IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_GetRayToFaceIntersection           IMPORT  -----   function
;hitpoint                             IX-26      8   variable
;dist                                 IX-18      4   variable
;G_4                                  IX-14      3   variable
;outface                              IX-11      3   variable
;didhit                                IX-8      1   variable
;closestDist                           IX-7      4   variable
;i                                     IX-3      3   variable
;hitOrNot                             IX+12      3   parameter
;distance                              IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


;  426	
;  427	void GetRayToFaceIntersection(Ray * ray, Face * face, float * result, bool * hit)
;  428	{
_GetRayToFaceIntersection:
	LD	HL,-72
	CALL	__frameset
;  429		float v1[2] = {0,0};
	LEA	DE,IX+-14
	LD	HL,_0temp100
	LD	BC,8
	LDIR	
;  430		float v2[2]= {0,0};
	LEA	DE,IX+-22
	LD	HL,_1temp101
	LD	BC,8
	LDIR	
;  431		float v3[2]= {0,0};
	LEA	DE,IX+-30
	LD	HL,_2temp102
	LD	BC,8
	LDIR	
;  432		float tOne = 0;
;  433		float tTwo = 0;
;  434		float dot = 0;
;  435		v1[0] =(ray->origin[0] - face->point1[0]);
	LD	IY,(IX+9)
	LEA	BC,IY+0
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-14),BC
	LD	(IX+-11),A
;  436		v1[1] = (ray->origin[1] - face->point1[1]);
	LD	IY,(IX+-6)
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-14
	LD	(IY+4),BC
	LD	(IY+7),A
;  437		v2[0] = (face->point2[0] - face->point1[0]);
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fsub
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  438		v2[1]= (face->point2[1] - face->point1[1]);
	LEA	BC,IY+12
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-22
	LD	(IY+4),BC
	LD	(IY+7),A
;  439		v3[0] = -(ray->direction[1]);
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	(IX+-30),BC
	LD	(IX+-27),A
;  440		v3[1] = (ray->direction[0]);
	LD	(IX+-45),BC	; spill
	LEA	HL,IX+-26
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	BC,(IY+8)
	LD	A,(IY+11)
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),BC
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
;  441		dot = (v2[0] * v3[0]) + (v2[1] * v3[1]);
	LD	(IX+-51),HL	; spill
	LEA	HL,IX+-18
	LD	(IX+-54),HL	; spill
	LD	HL,(IX+-51)	; unspill
	LEA	IY,IX+-30
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),A
	LD	HL,(IX+-45)	; unspill
	LD	E,(IX+-27)
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	CALL	__fmul
	LD	(IX+-71),BC
	LD	(IX+-72),A
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-51),HL	; spill
	LD	IY,(IX+-54)
	LD	HL,(IX+-51)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	A,(IX+-72)
	LD	HL,BC
	LD	BC,(IX+-71)
	CALL	__fadd
	LD	(IX+-38),BC
	LD	(IX+-35),A
;  442		
;  443		*hit = false;
	LD	HL,(IX+15)
	LD	(HL),0
;  444		if (abs(dot) < 0.000001)
	LD	A,(IX+-35)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8796093
	LD	A,53
	CALL	__fcmp
	JP	M,L_108
;  445		{
;  446			return;
;  447		}
;  448		tOne = ((v2[0] * v1[1]) - (v2[1] * v1[0])) / dot;
	LEA	IY,IX+-14
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fmul
	LD	(IX+-65),BC
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LEA	IY,IX+-22
	LD	BC,(IY+4)
	LD	(IX+-62),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-65)
	LD	A,(IX+-62)
	CALL	__fsub
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-34),BC
	LD	(IX+-31),A
;  449		tTwo = ((v1[0] * v3[0])+ (v1[1] * v3[1])) / dot;
	LEA	HL,IX+-10
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-30)
	LD	E,(IX+-27)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fmul
	LEA	IY,IX+-30
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-45),HL	; spill
	LD	IY,(IX+-61)
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-58)
	LD	A,(IX+-55)
	CALL	__fadd
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-42),BC
	LD	(IX+-39),A
;  450		
;  451		if (tOne>0.0 && (tTwo >=0.0 && tTwo <= 1.0))
	LD	BC,(IX+-34)
	LD	A,(IX+-31)
	OR	A,A
	SBC	HL,HL
	LD	E,0
	CALL	__fcmp
	JP	P,L_108
	LD	HL,(IX+-42)
	LD	E,(IX+-39)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_108
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-42)
	LD	A,(IX+-39)
	CALL	__fcmp
	JP	M,L_108
;  452		{
;  453			
;  454			*hit = true;
	LD	HL,(IX+15)
	LD	(HL),1
;  455			
;  456			//tOne is distance to point1
;  457			//multiply by normalized direction and add to origin to get point
;  458			(result)[0] = ray->origin[0] + (ray->direction[0] * tOne);
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	IY,(IX+6)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fmul
	LD	HL,BC
	LD	BC,(IY+0)
	LD	E,A
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY),BC
	LD	(IY+3),A
;  459			(result)[1] = ray->origin[1] + (ray->direction[1] * tOne);
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fmul
	LD	E,A
	LD	(IX+-45),BC	; spill
	LD	IY,(IX+-68)
	LD	HL,BC	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  460			
;  461		}
;  462		
;  463	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetRayToFaceIntersection ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;_2temp102                           STATIC      8   variable
;_1temp101                           STATIC      8   variable
;_0temp100                           STATIC      8   variable
;tTwo                                 IX-42      4   variable
;dot                                  IX-38      4   variable
;tOne                                 IX-34      4   variable
;v3                                   IX-30      8   variable
;v2                                   IX-22      8   variable
;v1                                   IX-14      8   variable
;hit                                  IX+15      3   parameter
;result                               IX+12      3   parameter
;face                                  IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: -4 (instruction)


	SEGMENT TEXT
_0temp100:
	DF	0.0
	DF	0.0
_1temp101:
	DF	0.0
	DF	0.0
_2temp102:
	DF	0.0
	DF	0.0
	SEGMENT CODE
;  464	
;  465	
;  466	#include <stdio.h>
;  467	
;  468	#define PSH(X) (*(buf++)=(X))
;  469	#define PSH1(X) (*(buf--)=(X))
;  470	#define PEEK() buf[-1]
;  471	#define POP() *(--buf) = '\0'
;  472	
;  473	#define PLUS 1
;  474	#define SPACE 2
;  475	
;  476	char * gcvt(double f, size_t ndigit, char * buf)
;  477	{
_gcvt:
	LD	HL,-44
	CALL	__frameset
;  478	  int i;
;  479		unsigned long z,k;
;  480	  int exp = 0;
;  481	  char *c = buf;
	LD	BC,(IX+15)
	LD	(IX+-14),BC
;  482	  double f2,t,scal;
;  483	  int   sign = 0;
	LD	BC,0
	LD	(IX+-21),BC
;  484	
;  485	  if((int)ndigit == -1)
	LD	HL,(IX+12)
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  486	    ndigit = 5;
	LD	BC,5
	LD	(IX+12),BC
L_111:
;  487	
;  488	  /* Unsigned long long only allows for 20 digits of precision
;  489	   * which is already more than double supports, so we limit the
;  490	   * digits to this.  long double might require an increase if it is ever
;  491	   * implemented.
;  492	   */
;  493	  if (ndigit > 20)
	LD	BC,(IX+12)
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	NC,L_114
;  494		  ndigit = 20;
	LD	BC,20
	LD	(IX+12),BC
L_114:
;  495	  
;  496	  if (f < 0.0) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_115
;  497	    sign = 1;
	LD	BC,1
	LD	(IX+-21),BC
;  498	    f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  499		 buf++;
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  500	  }
L_115:
;  501	
;  502	  scal = 1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,63
	LD	(IX+-8),A
;  503	  for (i=ndigit; i>0; i--)
	LD	BC,(IX+12)
	LD	(IX+-3),BC
	JR	L_119
L_117:
;  504		  scal *= 10;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+-11)
	LD	A,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
L_119:
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_117
;  505	  k = f + 0.1 / scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,13421773
	LD	A,61
	CALL	__fdiv
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  506	  f2 = f - k;
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-29),BC
	LD	(IX+-26),A
;  507	  if (!f) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	XOR	A,A
	LD	BC,0
	CALL	__fcmp
	JR	NZ,L_133
;  508	    PSH('0');
	LD	HL,(IX+15)
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  509	    if(ndigit > 0)
	LD	BC,(IX+12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_129
;  510	      PSH('.');
	LD	HL,(IX+15)
	LD	(HL),46
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
L_129:
;  511	    for (i=0;i<ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  512	      PSH('0');
	LD	BC,(IX+15)
	LD	(IX+-32),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_126
;  513	  	   PSH(0);
	LD	BC,(IX+15)
	LD	(IX+-35),BC
	LD	HL,BC
	LD	(HL),0
;  514	  	 return c;
	LD	HL,(IX+-14)
	JR	L_157
;  515	  }
L_133:
;  516	
;  517	  i = 1;
	LD	BC,1
	LD	(IX+-3),BC
;  518	  while (f >= 10.0) {
	JR	L_135
L_136:
;  519	  	f /= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  520	  	i++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  521	  }
L_135:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_136
;  522	
;  523	  buf += i + ndigit + 1; 	
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(IX+15),HL
;  524	
;  525	  PSH1(0);
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  526	
;  527	  if(ndigit > 0) {	
	OR	A,A
	LD	BC,(IX+12)
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_148
;  528		  t = f2 * scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,(IX+-29)
	LD	A,(IX+-26)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-22),A
	OR	A,A
;  529		 z = t + 0.5;
	SBC	HL,HL
	LD	E,63
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-18),BC
	LD	(IX+-15),A
;  530	    for (i = 0;i < ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_143
L_141:
;  531	    {
;  532	      PSH1('0'+ (z % 10));
	LD	BC,(IX+15)
	LD	(IX+-38),BC
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-38)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  533		   z /= 10;
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-18),HL
	LD	(IX+-15),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  534	    }
L_143:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_141
;  535	    PSH1('.');
	LD	BC,(IX+15)
	LD	(IX+-41),BC
	LD	HL,BC
	LD	(HL),46
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  536	  }
;  537	  else
	JR	L_150
L_148:
;  538	    PSH1(0);
	LD	HL,(IX+15)
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  539	
;  540	  do {
L_150:
;  541	    PSH1('0'+ (k % 10));
	LD	BC,(IX+15)
	LD	(IX+-44),BC
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-44)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  542	    k /= 10;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-7),HL
	LD	(IX+-4),E
;  543	  }while (k);
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__lcmpzero
	JR	NZ,L_150
;  544	
;  545	  if (sign)
	LD	HL,(IX+-21)
	CALL	__icmpzero
	JR	Z,L_156
;  546	    PSH1('-');
	LD	HL,(IX+15)
	LD	(HL),45
L_156:
;  547	  return c;
	LD	HL,(IX+-14)
;  548	}
L_157:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gcvt ***************************
;Name                         Addr/Register   Size   Type
;f2                                   IX-29      4   variable
;t                                    IX-25      4   variable
;sign                                 IX-21      3   variable
;z                                    IX-18      4   variable
;c                                    IX-14      3   variable
;scal                                 IX-11      4   variable
;k                                     IX-7      4   variable
;i                                     IX-3      3   variable
;buf                                  IX+15      3   parameter
;ndigit                               IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: -4 (instruction)


;  549	
;  550	 
;  551	 void drawMap()
;  552	 {
_drawMap:
	LD	HL,-44
	CALL	__frameset
;  553		 float lookview[2];
;  554		int face = 0;
;  555		float scale = 1.25;
;  556		lookview[0] = lookDirection[0];
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
;  557		lookview[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LEA	IY,IX+-11
;  558		//draw map box
;  559		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_gfx_SetColor
	POP	BC
;  560		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  561		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 50, 5);
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  562		gfx_Line_NoClip(LCD_WIDTH -50, 5, LCD_WIDTH - 50, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  563		gfx_Line_NoClip(LCD_WIDTH -50, 50, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  564	
;  565		//draw faces
;  566		for (face = 0; face < faceArrayCurrentSize; face++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_161
L_159:
;  567		{
;  568			gfx_SetColor(faceArray[face].color);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	IY,HL
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  569			gfx_Line_NoClip(faceArray[face].point1[0] * scale + LCD_WIDTH-25,  faceArray[face].point1[1]* -scale + 25,  faceArray[face].point2[0]* scale+ LCD_WIDTH-25,  faceArray[face].point2[1]* -scale + 25 );
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-20)
	LEA	BC,IY+8
	LD	(IX+-17),BC
	LEA	BC,IY+0
	LD	(IX+-14),BC
	LD	IY,(IX+-17)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	IY,(IX+-14)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  570		
;  571		}
L_161:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_159
;  572	
;  573		//draw player
;  574		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25 - 1,  playerPosition[1]* -scale +25,  playerPosition[0]* scale + LCD_WIDTH-25 + 1, playerPosition[1]* -scale +25);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-34),BC
	LD	(IX+-44),A
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,9699328
	LD	E,67
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-34)
	LD	A,(IX+-44)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13631488
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  575		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1]* -scale +25 -1,  playerPosition[0]* scale + LCD_WIDTH-25, playerPosition[1]* -scale +25 +1);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	(IX+-31),BC
	LD	(IX+-43),A
	LD	HL,13631488
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-31)
	LD	A,(IX+-43)
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  576		
;  577		//draw view
;  578		//
;  579		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
	OR	A,A
;  580		rotateVector(&lookview, fov/2);
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  581		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-27),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-28),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-28)
	LD	HL,(IX+-27)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-41),BC
	LD	(IX+-42),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-41)
	LD	A,(IX+-42)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-27)
	LD	A,(IX+-28)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  582		rotateVector(&lookview, -fov);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  583		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-23),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-24),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-24)
	LD	HL,(IX+-23)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-37),BC
	LD	(IX+-38),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-37)
	LD	A,(IX+-38)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-23)
	LD	A,(IX+-24)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  584		
;  585	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawMap ***************************
;Name                         Addr/Register   Size   Type
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_faceArrayCurrentSize               STATIC      3   variable
;_faceArray                          STATIC      3   variable
;_gfx_Line_NoClip                    IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;lookview                             IX-11      8   variable
;face                                  IX-3      3   variable


; Stack Frame Size: 50 (bytes)
;       Spill Code: -4 (instruction)


;  586	
;  587	void drawObjects()
;  588	{
_drawObjects:
	LD	HL,-77
	CALL	__frameset
;  589		
;  590		int num =0;
;  591		float dot;
;  592		float dist;
;  593		float distToFace;
;  594		bool hit;
;  595		int scale;
;  596		float angleFromCenter=0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  597		Ray testRay;
;  598		float toObject[2];
;  599		for (num = 0; num<numberOfObjects; num++)
	LD	(IX+-7),BC
	JR	L_171
L_169:
;  600		{
;  601			
;  602			toObject[0] = objectArray[num].position[0] - playerPosition[0];
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	IY,(IX+-46)
	LD	HL,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	E,A
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-20),BC
;  603			toObject[1] = objectArray[num].position[1] - playerPosition[1];
	LEA	BC,IX+-16
	LD	(IX+-17),A
	LD	(IX+-43),BC
	LEA	BC,IY+4
	LD	IY,_playerPosition
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	IY,(IX+-43)
	LD	(IY),BC
	LD	(IY+3),A
;  604			dot = (lookDirection[0] * toObject[0]) + (lookDirection[1] * toObject[1]);
	LD	BC,_lookDirection+4
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-72),BC
	LD	(IX+-73),A
;  605	
;  606			//get the angle of the sprite from the center 
;  607			angleFromCenter = -atan2((lookDirection[0]) *toObject[1] - (lookDirection[1]) * toObject[0], (lookDirection[0]) * toObject[0] + (lookDirection[1]) * toObject[1]);
	LD	A,(_lookDirection+3)
	LD	BC,(_lookDirection)
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	CALL	__fmul
	LD	E,(IX+-73)
	LD	HL,(IX+-72)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	A,(_lookDirection+3)
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	IY,(IX+-43)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(_lookDirection)
	CALL	__fmul
	LD	(IX+-76),BC
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	(IX+-77),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-76)
	LD	A,(IX+-77)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan2
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__fneg
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  608			
;  609			if (floatAbs(angleFromCenter) <= (fov/2))
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	(IX+-68),BC
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-69),A
	CALL	_floatAbs
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-68)
	LD	E,(IX+-69)
	CALL	__fcmp
	JP	M,L_170
;  610			{
;  611				//get distance to object
;  612				dist = (distanceBetween(&playerPosition, &objectArray[num].position));
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,_playerPosition
	PUSH	BC
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  613				//cast ray to nearest face and compare with distance to object
;  614				testRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-40
	LD	(IX+-52),BC
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  615				testRay.origin[1] = playerPosition[1];
	LD	IY,_playerPosition
	LEA	IY,IY+4
	LD	(IX+-61),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-61)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	LD	IY,(IX+-52)
	LEA	HL,IY+4
	LD	IY,(IX+-61)	; unspill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  616				testRay.direction[0] = toObject[0];
	LEA	BC,IX+-32
	LD	(IX+-49),BC
	LD	HL,BC
	LD	BC,(IX+-20)
	LD	A,(IX+-17)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  617				testRay.direction[1] = toObject[1];
	LEA	IY,IX+-16
	LD	(IX+-58),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-49)
;  618				ClosestFace(&testRay, &distToFace, &hit);
	PEA	IX+-8
	PEA	IX+-24
	PEA	IX+-40
	LEA	HL,IY+4
	LD	IY,(IX+-58)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  619				if (hit && dist >distToFace)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_167
	LD	HL,(IX+-24)
	LD	E,(IX+-21)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_170
;  620				{
;  621					//if the ray hit a face and that face is closer than the object, skip drawing it (it's obscured).
;  622					continue;
;  623				}
L_167:
;  624	
;  625				//change distance to the scale factor
;  626				dist =abs(1/((dist+3) *0.025)-2);
	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	HL,13421773
	LD	E,60
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fdiv
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
;  627				//limit dist to a minimum scale of 1
;  628				dist = max(dist,1);
	LD	C,63
	LD	B,0
	LD	(IX+-1),A
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  629				//set the color pallete
;  630				gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  631				//draw the scaled sprite.
;  632				gfx_ScaledTransparentSprite_NoClip(objectArray[num].sprite, (LCD_WIDTH/2) + (angleFromCenter *100 * fov) - (enemy1_width *dist)/2 ,LCD_HEIGHT/2 - (enemy1_height *dist)/2 ,dist,dist);
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	HL,12058624
	LD	E,65
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,15728640
	LD	A,66
	CALL	__fsub
	CALL	__ftol
	LD	HL,13107200
	LD	E,66
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fmul
	LD	H,A
	LD	A,(_fov+3)
	LD	E,A
	LD	A,H
	LD	HL,(_fov)
	CALL	__fmul
	LD	HL,2097152
	LD	E,67
	CALL	__fadd
	LD	(IX+-64),BC
	LD	(IX+-65),A
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	HL,7340032
	LD	E,65
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-64)
	LD	A,(IX+-65)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  633				
;  634			}
;  635		}
L_170:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_171:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_169
;  636		
;  637	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawObjects ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_max                                IMPORT  -----   function
;_abs                                IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_distanceBetween                    IMPORT  -----   function
;_floatAbs                           IMPORT  -----   function
;_fov                                STATIC      4   variable
;_atan2                              IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_playerPosition                     STATIC      8   variable
;_objectArray                        STATIC      3   variable
;testRay                              IX-40     16   variable
;distToFace                           IX-24      4   variable
;toObject                             IX-20      8   variable
;angleFromCenter                      IX-12      4   variable
;hit                                   IX-8      1   variable
;num                                   IX-7      3   variable
;dist                                  IX-4      4   variable


; Stack Frame Size: 83 (bytes)
;       Spill Code: -11 (instruction)


;  638	
;  639	
;  640	Face * mallocAndGenerateFace(float  point1x, float  point1y, float point2x, float point2y, uint8_t colorIndex)
;  641	{
_mallocAndGenerateFace:
	LD	HL,-6
	CALL	__frameset
;  642		Face * newFace = malloc(sizeof(Face));
	LD	BC,17
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;  643		newFace->point1[0] = point1x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+-6)
	LD	(IY+0),BC
	LD	(IY+3),A
;  644		newFace->point1[1] = point1y;
	LEA	HL,IY+4
	LD	BC,(IX+12)
	LD	A,(IX+15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  645		newFace->point2[0] = point2x;
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	BC,(IX+18)
	LD	A,(IX+21)
	LD	(IY+8),BC
	LD	(IY+11),A
;  646		newFace->point2[1] = point2y;
	LD	IY,(IX+-3)
	LEA	HL,IY+4
	LD	BC,(IX+24)
	LD	A,(IX+27)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  647		newFace->color = colorIndex;
	LD	A,(IX+30)
	LD	IY,(IX+-6)
	LD	(IY+16),A
;  648		return newFace;
	LD	HL,(IX+-6)
;  649	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mallocAndGenerateFace ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;newFace                               IX-6      3   variable
;colorIndex                           IX+30      1   parameter
;point2y                              IX+24      4   parameter
;point2x                              IX+18      4   parameter
;point1y                              IX+12      4   parameter
;point1x                               IX+6      4   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -11 (instruction)


;  650	
;  651	void loadLevel()
;  652	{
_loadLevel:
	LD	HL,-11
	CALL	__frameset
;  653		Object newObj;
;  654		numberOfObjects++;
	LD	BC,(_numberOfObjects)
	INC	BC
	LD	(_numberOfObjects),BC
;  655		//alloc object array
;  656		objectArray = malloc(sizeof(Object) * numberOfObjects);
	LD	HL,(_numberOfObjects)
	LD	A,11
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
;  657		//malloc sprite image
;  658		enemy1Sprite = gfx_MallocSprite(enemy1_width,enemy1_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	(_objectArray),HL
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_enemy1Sprite),HL
;  659		//decompress sprite image
;  660		zx7_Decompress(enemy1Sprite, enemy1_compressed);
	LD	BC,_enemy1_compressed
	PUSH	BC
	LD	BC,(_enemy1Sprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  661		newObj.sprite =  enemy1Sprite;
	LD	BC,(_enemy1Sprite)
	LD	(IX+-3),BC
;  662		
;  663		//set position
;  664		newObj.position[0] = -2;
	LD	BC,0
	LD	(IX+-11),BC
	LD	A,192
	LD	(IX+-8),A
;  665		newObj.position[1] = 2;
	LEA	IY,IX+-11
;  666		//add to array
;  667		objectArray[0] =newObj;
	LEA	HL,IX+-11
	LD	(IY+4),BC
	LD	(IY+7),64
	LD	DE,(_objectArray)
	LD	BC,11
	LDIR	
;  668		
;  669		
;  670	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadLevel ***************************
;Name                         Addr/Register   Size   Type
;_enemy1_compressed                  IMPORT    258   variable
;_zx7_Decompress                     IMPORT  -----   function
;_enemy1Sprite                       STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_objectArray                        STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_numberOfObjects                    STATIC      3   variable
;newObj                               IX-11     11   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: -11 (instruction)


;  671	
;  672	void unloadLevel()
;  673	{
_unloadLevel:
	LD	HL,-3
	CALL	__frameset
;  674		int j =0;
;  675		for (j=0;j<numberOfObjects;j++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_179
L_177:
;  676		{
;  677			free(objectArray[j].sprite);
	LD	HL,(IX+-3)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  678		}
L_179:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_177
;  679		free(objectArray);
	LD	BC,(_objectArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  680	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _unloadLevel ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_objectArray                        STATIC      3   variable
;_free                               IMPORT  -----   function
;j                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: -11 (instruction)


;  681	
;  682	void printText(const char *text, uint8_t xpos, uint8_t ypos) {
_printText:
	CALL	__frameset0
;  683	    os_SetCursorPos(ypos, xpos);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+12)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  684	    os_PutStrFull(text);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  685	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


;  686	
;  687	/* Draw small text at the given X/Y location */
;  688	void printTextSmall(const char *text, uint8_t xpos, uint8_t ypos) {
_printTextSmall:
	CALL	__frameset0
;  689	    os_FontSelect(0); // sets small font (1 == big, see docs)
	LD	BC,0
	PUSH	BC
	CALL	_os_FontSelect
	POP	BC
;  690	    os_FontDrawText(text, xpos, ypos);
	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_FontDrawText
	POP	BC
	POP	BC
	POP	BC
;  691	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printTextSmall ***************************
;Name                         Addr/Register   Size   Type
;_os_FontDrawText                    IMPORT  -----   function
;_os_FontSelect                      IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


	XREF _rotateVector:ROM
	XREF _distanceBetween:ROM
	XREF _fastCos:ROM
	XREF _floatAbs:ROM
	XREF _max:ROM
	XREF _gfx_group_pal:ROM
	XREF _enemy1_compressed:ROM
	XREF _doomak2_compressed:ROM
	XREF _zx7_Decompress:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_ScaledTransparentSprite_NoClip:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintString:ROM
	XREF _gfx_Blit:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_Line_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _calloc:ROM
	XREF _sqrt:ROM
	XREF _atan2:ROM
	XREF _asm_DrawStatusBar:ROM
	XREF _asm_ClrLCD:ROM
	XREF _asm_HomeUp:ROM
	XREF __OS:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_FontDrawText:ROM
	XREF _os_FontSelect:ROM
	XREF _os_SetCursorPos:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __lremu:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __imul_b:ROM
	XDEF _printTextSmall
	XDEF _printText
	XDEF _unloadLevel
	XDEF _loadLevel
	XDEF _mallocAndGenerateFace
	XDEF _drawObjects
	XDEF _drawMap
	XDEF _gcvt
	XDEF _GetRayToFaceIntersection
	XDEF _ClosestFace
	XDEF _draw
	XDEF _step
	XDEF _movementRay
	XDEF _end
	XDEF _begin
	XDEF _main
	XDEF _enemy1Sprite
	XDEF _enemy1Sprite_data
	XDEF _akSprite
	XDEF _akSprite_data
	XDEF _nyiError
	XDEF _key
	XDEF _partial_redraw
	XDEF _objectArray
	XDEF _faceArray
	XDEF _FACEARRAYMAXSIZE
	XDEF _playerPosition
	XDEF _lookDirection
	XDEF _MAX_DISTANCE
	XDEF _RENDER_WIDTH
	XDEF _DISTANCE_FOG
	XDEF _fov
	XDEF _multiplier
	XDEF _focalLength
	XDEF _lineSpacing
	XDEF _freeLookupTable
	XDEF _lookupSqrt
	XDEF _generateLookupTable
	XDEF _lut
	END
