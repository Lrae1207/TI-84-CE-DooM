; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"..\SRC\MAIN.C"
	.assume ADL=1
	SEGMENT BSS
_lut:
	DS	3
	SEGMENT DATA
_lookupTableSize:
	DW	0
	DB	0
_skip:
	DW	0
	DB	0
	SEGMENT CODE
_generateLookupTable:
	LD	HL,-9
	CALL	__frameset
	LD	BC,(IX+6)
	LD	(_lookupTableSize),BC
	LD	BC,(IX+9)
	LD	(_skip),BC
	LD	HL,(IX+6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(_lut),HL
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_3
L_1:
	LD	HL,(_skip)
	LD	BC,(IX+-3)
	CALL	__imuls
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_sqrt
	POP	BC
	POP	BC
	LD	(IX+-6),HL	; spill
	LD	(IX+-9),HL	; spill
	LD	HL,(IX+-3)
	LD	BC,(_lut)
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-9)	; unspill
	LD	(IY),HL
	LD	(IY+3),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_3:
	LD	BC,(IX+6)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
	LD	SP,IX
	POP	IX
	RET	


;**************************** _generateLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_sqrt                               IMPORT  -----   function
;_lut                                STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_skip                               STATIC      3   variable
;_lookupTableSize                    STATIC      3   variable
;i                                     IX-3      3   variable
;ski                                   IX+9      3   parameter
;size                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: -1 (instruction)


_lookupSqrt:
	LD	HL,-3
	CALL	__frameset
	LD	BC,(_lookupTableSize)
	DEC	BC
	CALL	__itol
	CALL	__ltof
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fcmp
	JP	M,L_6
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_sqrt
	POP	BC
	POP	BC
	JR	L_7
L_6:
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__ftol
	LD	HL,(_skip)
	CALL	__imuls
	LD	BC,HL
	LD	HL,BC
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(_lut)
	ADD	HL,DE
	LD	(IX+-3),HL
	LD	HL,BC
	INC	HL
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(_lut)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+-3)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
L_7:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _lookupSqrt ***************************
;Name                         Addr/Register   Size   Type
;_lut                                STATIC      3   variable
;_skip                               STATIC      3   variable
;_sqrt                               IMPORT  -----   function
;_lookupTableSize                    STATIC      3   variable
;x                                     IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -1 (instruction)


_freeLookupTable:
	LD	BC,(_lut)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,0
	LD	(_lookupTableSize),BC
	RET	


;**************************** _freeLookupTable ***************************
;Name                         Addr/Register   Size   Type
;_lookupTableSize                    STATIC      3   variable
;_lut                                STATIC      3   variable
;_free                               IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT DATA
_lineSpacing:
	DW	20
	DB	0
_focalLength:
	DF	5.0
_multiplier:
	DF	50.0
_fov:
	DF	1.57079637050629
	SEGMENT TEXT
_DISTANCE_FOG:
	DB	1
_RENDER_WIDTH:
	DW	100
	DB	0
_MAX_DISTANCE:
	DF	2.0
	SEGMENT DATA
_lookDirection:
	DF	0.0
	DF	1.0
_playerPosition:
	DF	0.0
	DF	0.0
	SEGMENT TEXT
_FACEARRAYMAXSIZE:
	DW	10
	DB	0
	SEGMENT BSS
_faceArray:
	DS	3
	SEGMENT DATA
_faceArrayCurrentSize:
	DW	0
	DB	0
_numberOfObjects:
	DW	0
	DB	0
	SEGMENT BSS
_objectArray:
	DS	3
_partial_redraw:
	DS	1
_key:
	DS	1
	SEGMENT STRSECT
L__5:
	DB	"Not Yet Implemented"
	DB	0
	SEGMENT DATA
_nyiError:
	DW24	L__5
	SEGMENT BSS
_akSprite_data:
	DS	3076
	SEGMENT DATA
_akSprite:
	DW24	_akSprite_data
	SEGMENT BSS
_enemy1Sprite_data:
	DS	347
	SEGMENT DATA
_enemy1Sprite:
	DW24	_enemy1Sprite_data
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	#include <math.h>
;    6	#include <stdio.h>
;    7	#include <stdlib.h>
;    8	#include <string.h>
;    9	#include <graphx.h>
;   10	#include <debug.h>
;   11	#include <keypadc.h>
;   12	#include <assert.h>
;   13	#include <compression.h>
;   14	#include "gfx/gfx_group.h"
;   15	#include "lookup_table.h"
;   16	#include "helpers.h"
;   17	
;   18	//A ray is defined by two float tuples, its origin and its direction.
;   19	typedef struct 
;   20	{
;   21		float origin[2];
;   22		float direction[2];
;   23	
;   24	}Ray;
;   25	//An rgb color.
;   26	//Unusued right now (AFAIK)
;   27	typedef struct 
;   28	{
;   29		uint8_t r,g,b;
;   30	}Color;
;   31	//A face is defined by two points and a color index.
;   32	typedef struct 
;   33	{
;   34		float point1[2];
;   35		float point2[2];
;   36		uint8_t color;
;   37	}Face;
;   38	//An object (or sprite) is defined by its position and a pointer to the graphics sprite that it uses.
;   39	typedef struct{
;   40		float position[2];
;   41		gfx_sprite_t * sprite;	
;   42	}Object;
;   43	
;   44	//The distance between cast rays
;   45	int lineSpacing = 20;
;   46	float focalLength = 5.0;
;   47	//Height of walls
;   48	float multiplier = 50;
;   49	
;   50	//The horizontal FOV, measured in radians. The default is 0.5pi, or 90 degrees
;   51	float fov = M_PI/2;
;   52	//Whether or not father faces are rendered darker than closer ones. Not yet implemented
;   53	const bool DISTANCE_FOG = true;
;   54	//Idk why I made this variable, and it isnt used.
;   55	const int RENDER_WIDTH = 100;
;   56	//Ditto.
;   57	const float MAX_DISTANCE = 2;
;   58	//The vector that defines what direction the camera is looking at. 
;   59	//Should be normalized, but its not the end of the world if it isn't.
;   60	float lookDirection[] = {0,1};
;   61	//The vector that defines where the camera is.
;   62	float playerPosition[] = {0,0};
;   63	
;   64	const int FACEARRAYMAXSIZE = 10;
;   65	//A pointer to the list of faces. It is dynamically allocated on the beginning of the program, with a size of FACEARRAYMAXSIZE
;   66	Face * faceArray;
;   67	//Current number of faces in the list of faces.
;   68	static int faceArrayCurrentSize = 0;
;   69	//Current number of objects in the list of objects.
;   70	static int numberOfObjects = 0;
;   71	
;   72	#define OBJECTARRAYMAXSIZE  10
;   73	
;   74	//A pointer to the list of objects. It is dynamically allocated on the beginning of the program, with a size of OBJECTARRAYMAXSIZE
;   75	Object * objectArray;
;   76	
;   77	
;   78	void loadLevel();
;   79	void printTextSmall(const char *, uint8_t , uint8_t);
;   80	void printText(const char *, uint8_t, uint8_t );
;   81	Face * mallocAndGenerateFace(float , float, float, float , uint8_t);
;   82	void drawObjects();
;   83	void drawMap();
;   84	
;   85	Face *ClosestFace(Ray*, float*, bool*);
;   86	void GetRayToFaceIntersection(Ray*, Face*, float * ,bool *);
;   87	
;   88	char * gcvt(float, size_t, char *);
;   89	void begin();
;   90	void end();
;   91	void step();
;   92	void draw();
;   93	bool partial_redraw;
;   94	kb_key_t key;
;   95	
;   96	
;   97	//The string displayed when the Not Yet Implemented error is thrown.
;   98	char * nyiError = "Not Yet Implemented";
;   99	//Creates sprites for enemy1 and the gun.
;  100	gfx_UninitedSprite(akSprite, doomak2_width,doomak2_height);
;  101	gfx_UninitedSprite(enemy1Sprite, enemy1_width, enemy1_height);
	SEGMENT CODE
;  102	void main() {
_main:
	LD	HL,-18
	CALL	__frameset
;  103		
;  104		int i;
;  105		Face * testFace;
;  106		Face * testFace2;	
;  107		Face * testFace3;
;  108		Face * testFace4;
;  109		
;  110		float  * destination  = calloc(2 , sizeof(float));
	LD	BC,4
	PUSH	BC
	LD	BC,2
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
	LD	(IX+-18),HL
;  111		bool  hit = false;
;  112		faceArray = calloc(FACEARRAYMAXSIZE ,sizeof(Face));
	LD	BC,17
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_calloc
	POP	BC
	POP	BC
;  113	
;  114		//create test walls
;  115		testFace = mallocAndGenerateFace(-5,6,5,6, 65);
	LD	BC,65
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	LD	DE,12582912
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	LD	(_faceArray),HL
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-6),HL
;  116		testFace2 = mallocAndGenerateFace(-5,-5,5,-5,12);
	LD	BC,12
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	C,64
	LD	DE,10485760
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	PUSH	DE
	PUSH	BC
	LD	BC,10485760
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-9),HL
;  117		testFace3 = mallocAndGenerateFace(-7,7,-7,-7,02);
	LD	BC,2
	PUSH	BC
	LD	C,192
	LD	B,0
	PUSH	BC
	LD	DE,14680064
	PUSH	DE
	PUSH	BC
	LD	C,64
	PUSH	DE
	PUSH	BC
	LD	C,192
	PUSH	DE
	PUSH	BC
	LD	BC,14680064
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-12),HL
;  118		testFace4 = mallocAndGenerateFace(4,-9,8,2,196);
	LD	BC,196
	PUSH	BC
	LD	C,64
	LD	B,0
	PUSH	BC
	LD	C,65
	LD	DE,0
	PUSH	DE
	PUSH	BC
	LD	C,193
	PUSH	DE
	PUSH	BC
	LD	C,64
	LD	DE,1048576
	PUSH	DE
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	CALL	_mallocAndGenerateFace
	LD	IY,27
	ADD	IY,SP
	LD	SP,IY
	LD	(IX+-15),HL
;  119		faceArray[0] = *testFace;
	LD	DE,(_faceArray)
	LD	HL,(IX+-6)
	LD	BC,17
	LDIR	
;  120		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  121		faceArray[1] = *testFace2;
	LD	IY,(_faceArray)
	LEA	DE,IY+17
	LD	HL,(IX+-9)
	LD	BC,17
	LDIR	
;  122		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  123		faceArray[2] = *testFace3;
	LD	IY,(_faceArray)
	LEA	DE,IY+34
	LD	HL,(IX+-12)
	LD	BC,17
	LDIR	
;  124		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  125		faceArray[3] = *testFace4;
	LD	IY,(_faceArray)
	LEA	DE,IY+51
	LD	HL,(IX+-15)
	LD	BC,17
	LDIR	
;  126		faceArrayCurrentSize++;
	LD	BC,(_faceArrayCurrentSize)
	INC	BC
	LD	(_faceArrayCurrentSize),BC
;  127	    loadLevel();
	CALL	_loadLevel
;  128		begin(); // No rendering allowed!
	CALL	_begin
;  129	
;  130		
;  131		//sets up not yet implemented error message
;  132		for (i = 0; i < 20; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_16
L_14:
;  133		{
;  134			os_AppErr1[i] =nyiError[i];
	LD	BC,(IX+-3)
	LD	HL,(_nyiError)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,13641129
	ADD	HL,BC
	LD	A,(IY)
	LD	(HL),A
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  135			
;  136		}
L_16:
	LD	BC,20
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;  137		
;  138		
;  139		//allocates and decompresses gun sprite
;  140		akSprite = gfx_MallocSprite(doomak2_width,doomak2_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,58
	PUSH	BC
	LD	BC,53
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_akSprite),HL
;  141		zx7_Decompress(akSprite, doomak2_compressed);
	LD	BC,_doomak2_compressed
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  142		
;  143	    gfx_Begin();
	CALL	_gfx_Begin
;  144	    gfx_SetDrawBuffer(); // Draw to the buffer to avoid rendering artifats
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  145		
;  146		
;  147		kb_Scan();
	CALL	_kb_Scan
;  148		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  149			
;  150		//runs until 2nd is pressed
;  151	    while (kb_Data[1] !=kb_2nd) { 
	JR	L_20
L_21:
;  152			step();// No rendering allowed in step!
	CALL	_step
;  153	        if (partial_redraw) // Only want to redraw part of the previous frame?
	LD	A,(_partial_redraw)
	OR	A,A
	JR	Z,L_19
;  154	            gfx_BlitScreen(); // Copy previous frame as a base for this frame
	LD	BC,0
	PUSH	BC
	CALL	_gfx_Blit
	POP	BC
L_19:
;  155	        draw(); // As little non-rendering logic as possible
	CALL	_draw
;  156	        gfx_SwapDraw(); // Queue the buffered frame to be displayed
	CALL	_gfx_SwapDraw
;  157	    }
L_20:
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_21
;  158	
;  159	    gfx_End();
	CALL	_gfx_End
;  160	    end();
	CALL	_end
;  161		
;  162		
;  163		os_ClrHome();
	LD	BC,_asm_ClrLCD
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_HomeUp
	PUSH	BC
	CALL	__OS
	POP	BC
	LD	BC,_asm_DrawStatusBar
	PUSH	BC
	CALL	__OS
	POP	BC
;  164		
;  165		
;  166		while (!os_GetCSC());
L_26:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_26
;  167		//free memory
;  168		free(destination);
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_free
	POP	BC
;  169		free(testFace);
	LD	BC,(IX+-6)
	PUSH	BC
	CALL	_free
	POP	BC
;  170		free(testFace2);
	LD	BC,(IX+-9)
	PUSH	BC
	CALL	_free
	POP	BC
;  171		free(testFace3);
	LD	BC,(IX+-12)
	PUSH	BC
	CALL	_free
	POP	BC
;  172		free(faceArray);
	LD	BC,(_faceArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  173		free(akSprite);
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_free
	POP	BC
;  174	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_asm_DrawStatusBar                  IMPORT  -----   function
;_asm_HomeUp                         IMPORT  -----   function
;_asm_ClrLCD                         IMPORT  -----   function
;__OS                                IMPORT  -----   function
;_end                                IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_draw                               IMPORT  -----   function
;_gfx_Blit                           IMPORT  -----   function
;_partial_redraw                     STATIC      1   variable
;_step                               IMPORT  -----   function
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_doomak2_compressed                 IMPORT   1819   variable
;_zx7_Decompress                     IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_nyiError                           STATIC      3   variable
;_begin                              IMPORT  -----   function
;_loadLevel                          IMPORT  -----   function
;_faceArrayCurrentSize               STATIC      3   variable
;_mallocAndGenerateFace              IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_calloc                             IMPORT  -----   function
;destination                          IX-18      3   variable
;testFace4                            IX-15      3   variable
;testFace3                            IX-12      3   variable
;testFace2                             IX-9      3   variable
;testFace                              IX-6      3   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 24 (bytes)
;       Spill Code: -1 (instruction)


;  175	
;  176	/* Put other functions here */
;  177	void begin() {	
_begin:
;  178			gfx_SetTransparentColor(gfx_group_transparent_color_index);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  179		
;  180	}
	RET	


;**************************** _begin ***************************
;Name                         Addr/Register   Size   Type
;_gfx_SetTransparentColor            IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  181	
;  182	void end() {
_end:
;  183	    /* Implement me! */
;  184	}
	RET	


;**************************** _end ***************************
;Name                         Addr/Register   Size   Type


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


;  185	
;  186	
;  187	
;  188	void step() {
_step:
	LD	HL,-72
	CALL	__frameset
;  189	  	float distanceFromCam;
;  190		bool hit;
;  191		Ray movementRay;
;  192		movementRay.origin[0] = playerPosition[0];
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
;  193		movementRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-63),HL	; spill
	LD	(IX+-33),BC
	LD	(IX+-30),A
	LEA	HL,IX+-29
	LD	(IX+-60),HL	; spill
	LD	HL,(IX+-63)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+-60)	; unspill
	LD	(IX+-66),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-66)	; unspill
	LD	(IX+-69),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-69)	; unspill
	LD	(IX+-72),HL	; spill
	LD	HL,(IX+-63)	; unspill
	INC	HL
	LD	(IX+-63),HL	; spill
	LD	HL,(IX+-72)	; unspill
	LD	(IX+-72),HL	; spill
	LD	HL,(IX+-63)	; unspill
	LD	A,(HL)
	LD	HL,(IX+-72)	; unspill
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  194		
;  195		//keypad input
;  196		kb_Scan();
	CALL	_kb_Scan
;  197		key = kb_Data[7];
	LD	A,(16056350)
	LD	(_key),A
;  198		
;  199		//back
;  200		 if (kb_Data[4] & kb_2) {
	LD	A,(16056344)
	AND	A,2
	JR	Z,L_38
;  201			 	movementRay.direction[0] =  -lookDirection[0];
	LEA	BC,IX+-25
	LD	(IX+-36),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(IX+-25),BC
;  202				movementRay.direction[1] =  -lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(IX+-22),A
	LD	(IX+-8),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	IY,(IX+-36)
;  203				ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  204				if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_33
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_38
L_33:
	OR	A,A
;  205				{
;  206	           		playerPosition[0] = playerPosition[0] + lookDirection[0] * -0.5;
	SBC	HL,HL
	LD	E,191
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  207					playerPosition[1] = playerPosition[1] + lookDirection[1] * -0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-39),BC
	LD	IY,(IX+-8)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,191
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-39)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  208				}
;  209				
;  210	        } 
L_38:
;  211			//forward
;  212	    if (kb_Data[4] & kb_8) {
	LD	A,(16056344)
	AND	A,8
	JR	Z,L_42
;  213			movementRay.direction[0] =  lookDirection[0];
	LEA	BC,IX+-25
	LD	(IX+-42),BC
	LD	HL,BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  214			movementRay.direction[1] =  lookDirection[1];
	LD	BC,_lookDirection+4
	LD	(HL),A
	LD	(IX+-11),BC
	LD	HL,BC
	LD	BC,(HL)
	LD	IY,(IX+-42)
;  215			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LEA	HL,IY+4
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  216			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_36
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_42
L_36:
	OR	A,A
;  217			{
;  218	        	playerPosition[0] = playerPosition[0] + lookDirection[0] * 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  219				playerPosition[1] = playerPosition[1] + lookDirection[1] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-45),BC
	LD	IY,(IX+-11)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-45)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  220			}
;  221				
;  222	    } 
L_42:
;  223		//left
;  224	    if (kb_Data[3] & kb_4) {
	LD	A,(16056342)
	AND	A,4
	JR	Z,L_46
;  225			movementRay.direction[0] =  -lookDirection[1];
	LEA	BC,IX+-25
	LD	DE,_lookDirection+4
	LD	(IX+-48),BC
	LD	(IX+-14),DE
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fneg
	LD	IY,(IX+-48)
	LD	(IY),BC
	LD	(IY+3),A
;  226			movementRay.direction[1] =  lookDirection[0];
;  227			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	LEA	HL,IY+4
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  228			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_40
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_46
L_40:
;  229			{
;  230	           	playerPosition[0] = playerPosition[0] - lookDirection[1] * 0.5;
	LD	IY,(IX+-14)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fsub
	LD	(_playerPosition),BC
;  231				playerPosition[1] = playerPosition[1] + lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-51),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-51)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	(IY),BC
	LD	(IY+3),A
;  232			}
;  233	    } 
L_46:
;  234		//right
;  235	    if (kb_Data[5] & kb_6) {
	LD	A,(16056346)
	AND	A,4
	JR	Z,L_48
;  236			movementRay.direction[0] =  lookDirection[1];
	LEA	BC,IX+-25
	LD	DE,_lookDirection+4
	LD	(IX+-54),BC
	LD	(IX+-17),DE
	LD	HL,(IX+-17)
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	HL,(IX+-54)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  237			movementRay.direction[1] =  -lookDirection[0];
	LD	IY,(IX+-54)
;  238			ClosestFace(&movementRay, &distanceFromCam, &hit);
	PEA	IX+-1
	PEA	IX+-5
	PEA	IX+-33
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	CALL	__fneg
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  239			if  ( !hit || distanceFromCam > 0.5 )
	LD	A,(IX+-1)
	OR	A,A
	JR	Z,L_44
	OR	A,A
	SBC	HL,HL
	LD	E,63
	LD	BC,(IX+-5)
	LD	A,(IX+-2)
	CALL	__fcmp
	JP	P,L_48
L_44:
;  240			{
;  241	           	playerPosition[0] = playerPosition[0] + lookDirection[1] * 0.5;
	LD	IY,(IX+-17)
	LD	BC,(IY)
	LD	A,(IY+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	CALL	__fadd
	LD	(_playerPosition),BC
;  242				playerPosition[1] = playerPosition[1] - lookDirection[0] * 0.5;
	LD	BC,_playerPosition+4
	LD	(_playerPosition+3),A
	LD	(IX+-57),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	OR	A,A
	SBC	HL,HL
	LD	E,63
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	IY,(IX+-57)
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IY),BC
	LD	(IY+3),A
;  243			}
;  244		} 
L_48:
;  245		//rotation
;  246		if (kb_Data[3] & kb_7)
	LD	A,(16056342)
	AND	A,8
	JR	Z,L_50
;  247		{
;  248			rotateVector(&lookDirection, 0.2);
	LD	C,62
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  249		}
L_50:
;  250		if (kb_Data[5] & kb_9)
	LD	A,(16056346)
	AND	A,8
	JR	Z,L_52
;  251		{
;  252			rotateVector(&lookDirection, -0.2);
	LD	C,190
	LD	B,0
	PUSH	BC
	LD	BC,5033165
	PUSH	BC
	LD	BC,_lookDirection
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  253		}
L_52:
;  254		if (kb_Data[7] & kb_Up)
	LD	A,(16056350)
	AND	A,8
	JR	Z,L_54
;  255		{
;  256			fov+= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fadd
	LD	(_fov),BC
	LD	(_fov+3),A
;  257		}
L_54:
;  258		if (kb_Data[7] & kb_Down)
	LD	A,(16056350)
	AND	A,1
	JR	Z,L_57
;  259		{
;  260			fov-= 0.1;
	LD	HL,13421773
	LD	E,61
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fsub
	LD	(_fov),BC
	LD	(_fov+3),A
;  261		}
L_57:
;  262		if (kb_Data[7] & kb_Left)
	LD	A,(16056350)
	AND	A,2
	JR	Z,L_61
;  263		{
;  264			lineSpacing++;
	LD	BC,(_lineSpacing)
	INC	BC
	LD	(_lineSpacing),BC
;  265		}
L_61:
;  266		if (kb_Data[7] & kb_Right)
	LD	A,(16056350)
	AND	A,4
	JR	Z,L_63
;  267		{
;  268			if (lineSpacing > 1)
	LD	BC,(_lineSpacing)
	LD	HL,1
	OR	A,A
	SBC	HL,BC
	JP	P,L_63
;  269			{
;  270				lineSpacing--;
	LD	BC,(_lineSpacing)
	DEC	BC
	LD	(_lineSpacing),BC
;  271			}
;  272		}
L_63:
;  273		if (kb_Data[6] & kb_Add)
	LD	A,(16056348)
	AND	A,2
	JR	Z,L_66
;  274		{
;  275			multiplier+= 5;
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fadd
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  276		}
L_66:
;  277		if (kb_Data[6] & kb_Sub)
	LD	A,(16056348)
	AND	A,4
	JR	Z,L_68
;  278		{
;  279			if (multiplier > 5)
	LD	HL,10485760
	LD	E,64
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fcmp
	JP	P,L_68
;  280			{
;  281				multiplier-= 5;
	LD	BC,(_multiplier)
	LD	A,(_multiplier+3)
	CALL	__fsub
	LD	(_multiplier),BC
	LD	(_multiplier+3),A
;  282			}
;  283		}
L_68:
;  284		if (kb_Data[6] & kb_Mul)
	LD	A,(16056348)
	AND	A,8
	JR	Z,L_71
	OR	A,A
;  285		{
;  286			focalLength += 0.5;
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fadd
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  287		}
L_71:
;  288		if (kb_Data[6] & kb_Div)
	LD	A,(16056348)
	AND	A,16
	JR	Z,L_72
	OR	A,A
;  289		{
;  290			if (focalLength > 0.5)
	SBC	HL,HL
	LD	E,63
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fcmp
	JP	P,L_72
	OR	A,A
;  291			{
;  292				focalLength -= 0.5;
	SBC	HL,HL
	LD	BC,(_focalLength)
	LD	A,(_focalLength+3)
	CALL	__fsub
	LD	(_focalLength),BC
	LD	(_focalLength+3),A
;  293			}
;  294		}
;  295	}
L_72:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _step ***************************
;Name                         Addr/Register   Size   Type
;_focalLength                        STATIC      4   variable
;_multiplier                         STATIC      4   variable
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_key                                STATIC      1   variable
;_kb_Scan                            IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;movementRay                          IX-33     16   variable
;G_3                                  IX-17      3   variable
;G_2                                  IX-14      3   variable
;G_1                                  IX-11      3   variable
;G_0                                   IX-8      3   variable
;distanceFromCam                       IX-5      4   variable
;hit                                   IX-1      1   variable


; Stack Frame Size: 78 (bytes)
;       Spill Code: -1 (instruction)


;  296	
;  297	//does the main drawing
;  298	void draw() {
_draw:
	LD	HL,-61
	CALL	__frameset
;  299		int row = LCD_WIDTH/2;
;  300		int fillSpacing = 0;
;  301		int temp = 0;
;  302		float closeDist = -1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,191
	LD	(IX+-8),A
;  303		float fardist = 2;
;  304		float res[2];
;  305		char buf[10];
;  306		bool hmm = false;
	LD	(IX+-7),0
;  307		Face * hit ;
;  308		Ray  lookRay ;
;  309		float newClose;
;  310		float angleFromCenter = 0;
;  311		
;  312		//clear the screen
;  313		gfx_FillScreen(255);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  314		
;  315		//center lookray
;  316		lookRay.direction[0] = lookDirection[0];
	LEA	BC,IX+-39
	LD	(IX+-53),BC
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
	LD	(IX+-39),BC
;  317		lookRay.direction[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-36),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LEA	IY,IX+-35
	LD	A,(HL)
	LD	(IY),BC
	LD	(IY+3),A
;  318		lookRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-47
	LD	(IX+-50),BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(IX+-47),BC
;  319		lookRay.origin[1] = playerPosition[1];
	LD	HL,_playerPosition+4
	LD	(IX+-44),A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	IY,(IX+-50)
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
;  320		//rotate the ray to the very left in preparation for spinning it around
;  321		rotateVector(&lookRay.direction, fov/2);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	BC,(IX+-53)
	PUSH	BC
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
;  322		angleFromCenter = fov/2;
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  323		
;  324		//loop for each vertical line
;  325		
;  326		for (row = 0; row <LCD_WIDTH; row+= lineSpacing){
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_83
L_81:
;  327		
;  328			//rotate ray by a small amount
;  329			rotateVector(&(lookRay.direction), -((float)fov / LCD_WIDTH) * lineSpacing);
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-60),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-61),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-60)
	LD	A,(IX+-61)
	CALL	__fmul
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-39
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  330			angleFromCenter += -((float)fov / LCD_WIDTH) * lineSpacing;
	LD	HL,10485760
	LD	E,67
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	CALL	__fneg
	LD	(IX+-56),BC
	LD	BC,(_lineSpacing)
	LD	(IX+-57),A
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-56)
	LD	A,(IX+-57)
	CALL	__fmul
	LD	HL,(IX+-21)
	LD	E,(IX+-18)
	CALL	__fadd
	LD	(IX+-21),BC
	LD	(IX+-18),A
;  331			//cast the ray
;  332			hit = ClosestFace(&lookRay, &closeDist, &hmm);
	PEA	IX+-7
	PEA	IX+-11
	PEA	IX+-47
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-17),HL
;  333			
;  334			//if hit
;  335			if (hmm && hit != 0)
	LD	A,(IX+-7)
	OR	A,A
	JR	Z,L_82
	LD	HL,(IX+-17)
	CALL	__icmpzero
	JR	Z,L_82
;  336			{
;  337				
;  338				gfx_SetColor(hit->color);
	LD	IY,(IX+-17)
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  339				closeDist = closeDist * fastCos(angleFromCenter);
	LD	C,(IX+-18)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_fastCos
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
;  340				temp =(focalLength/closeDist) * multiplier;
	LD	HL,BC
	LD	BC,(_focalLength)
	LD	E,(IX+-8)
	LD	A,(_focalLength+3)
	CALL	__fdiv
	LD	H,A
	LD	A,(_multiplier+3)
	LD	E,A
	LD	A,H
	LD	HL,(_multiplier)
	CALL	__fmul
	CALL	__ftol
;  341				if (temp < 0)
	LD	HL,BC
	CALL	__icmpzero
	LD	(IX+-6),BC
	JP	P,L_76
;  342				{
;  343					temp = 0;
	LD	BC,0
	LD	(IX+-6),BC
;  344				}
L_76:
;  345				if (temp > LCD_HEIGHT/2 -1)
	LD	BC,(IX+-6)
	LD	HL,119
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  346				{
;  347					temp = LCD_HEIGHT/2 -1;
	LD	BC,119
	LD	(IX+-6),BC
;  348				}
L_77:
;  349				
;  350				fillSpacing = lineSpacing;
	LD	BC,(_lineSpacing)
	LD	(IX+-14),BC
;  351				if (row + fillSpacing >= LCD_WIDTH)
	LD	HL,(IX+-3)
	ADD	HL,BC
	OR	A,A
	LD	BC,320
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  352				{
;  353					fillSpacing = LCD_WIDTH-row;
	LD	BC,(IX+-3)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	LD	(IX+-14),HL
;  354				}
L_79:
;  355				
;  356				
;  357				gfx_FillRectangle_NoClip(row,LCD_HEIGHT/2 - temp,fillSpacing, 2 * temp );
	LD	A,(IX+-6)
	ADD	A,A
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	A,120
	LD	BC,(IX+-14)
	PUSH	BC
	LD	B,(IX+-6)
	SUB	A,B
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_gfx_FillRectangle_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  358			}
;  359			
;  360			
;  361			
;  362		}
L_82:
	LD	BC,(IX+-3)
	LD	HL,(_lineSpacing)
	ADD	HL,BC
	LD	(IX+-3),HL
L_83:
	LD	BC,320
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_81
;  363			//draw position and rotation text
;  364			gcvt(playerPosition[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_playerPosition+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  365			gfx_SetTextFGColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  366			gfx_SetTextXY(0,0);
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  367			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  368			gcvt(playerPosition[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  369			gfx_SetTextXY(75,0);
	LD	BC,0
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  370			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  371			gcvt(lookDirection[0], 3, &buf);
	PEA	IX+-31
	LD	A,(_lookDirection+3)
	LD	C,A
	LD	DE,3
	PUSH	DE
	LD	B,0
	PUSH	BC
	LD	BC,(_lookDirection)
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  372			gfx_SetTextXY(0,20);
	LD	BC,20
	PUSH	BC
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  373			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  374			gcvt(lookDirection[1], 3, &buf);
	PEA	IX+-31
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	DE,3
	PUSH	DE
	LD	H,0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	_gcvt
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  375			gfx_SetTextXY(75,20);
	LD	BC,20
	PUSH	BC
	LD	BC,75
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  376			gfx_PrintString(&buf);
	PEA	IX+-31
	CALL	_gfx_PrintString
	POP	BC
;  377			
;  378			//draw objects
;  379			drawObjects();
	CALL	_drawObjects
;  380			
;  381			//draw gun sprite
;  382			gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  383			gfx_ScaledTransparentSprite_NoClip(akSprite, (LCD_WIDTH /2) - 68 , LCD_HEIGHT - doomak2_height * 2, 2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	BC,124
	PUSH	BC
	LD	BC,92
	PUSH	BC
	LD	BC,(_akSprite)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  384			
;  385			//draw crosshair
;  386			gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  387			gfx_Line_NoClip(LCD_WIDTH/2 - 2, LCD_HEIGHT/2, LCD_WIDTH/2 + 2, LCD_HEIGHT/2);
	LD	BC,120
	PUSH	BC
	LD	BC,162
	PUSH	BC
	LD	BC,120
	PUSH	BC
	LD	BC,158
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  388			gfx_Line_NoClip(LCD_WIDTH/2 , LCD_HEIGHT/2 - 2, LCD_WIDTH/2 , LCD_HEIGHT/2 + 2);
	LD	BC,122
	PUSH	BC
	LD	BC,160
	PUSH	BC
	LD	BC,118
	PUSH	BC
	LD	BC,160
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  389			
;  390	
;  391			//draw the overhead map
;  392			drawMap();
	CALL	_drawMap
;  393			
;  394	
;  395		
;  396	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _draw ***************************
;Name                         Addr/Register   Size   Type
;_drawMap                            IMPORT  -----   function
;_gfx_Line_NoClip                    IMPORT  -----   function
;_akSprite                           STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_drawObjects                        IMPORT  -----   function
;_gfx_PrintString                    IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gcvt                               IMPORT  -----   function
;_gfx_FillRectangle_NoClip           IMPORT  -----   function
;_multiplier                         STATIC      4   variable
;_focalLength                        STATIC      4   variable
;_fastCos                            IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_lineSpacing                        STATIC      3   variable
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_lookDirection                      STATIC      8   variable
;_gfx_FillScreen                     IMPORT  -----   function
;lookRay                              IX-47     16   variable
;buf                                  IX-31     10   variable
;angleFromCenter                      IX-21      4   variable
;hit                                  IX-17      3   variable
;fillSpacing                          IX-14      3   variable
;closeDist                            IX-11      4   variable
;hmm                                   IX-7      1   variable
;temp                                  IX-6      3   variable
;row                                   IX-3      3   variable


; Stack Frame Size: 67 (bytes)
;       Spill Code: -1 (instruction)


;  397	
;  398	//returns the closest face a ray hits, and sets the distance and whether or not the ray hit anything
;  399	Face *ClosestFace(Ray *ray, float *distance, bool * hitOrNot)
;  400	{
_ClosestFace:
	LD	HL,-26
	CALL	__frameset
;  401		float closestDist;
;  402		int i;
;  403		float hitpoint[2];
;  404		//float * hitpoint  = malloc(2 * sizeof(float));
;  405		float dist = 0;
	LD	BC,0
	LD	(IX+-18),BC
	XOR	A,A
	LD	(IX+-15),A
;  406		bool  didhit;
;  407		//pointer to the face in facearray that was hit
;  408		Face * outface = NULL;
	LD	(IX+-11),BC
;  409		*distance = -1;
	LD	HL,(IX+9)
	LD	BC,8388608
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),191
;  410		closestDist = 999999;
	LD	BC,7611376
	LD	(IX+-7),BC
	LD	A,73
	LD	(IX+-4),A
;  411		*hitOrNot = false;
	LD	HL,(IX+12)
	LD	(HL),0
;  412		
;  413		//check if passed null pointers
;  414		if (ray == NULL || distance == NULL || hitOrNot == NULL)
	LD	HL,(IX+6)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+9)
	CALL	__icmpzero
	JR	Z,L_88
	LD	HL,(IX+12)
	CALL	__icmpzero
	JR	NZ,L_97
L_88:
	OR	A,A
;  415		{
;  416			return outface;
	SBC	HL,HL
	JR	L_99
;  417		}
L_97:
;  418		
;  419		for (i = 0; i<faceArrayCurrentSize; i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_96
L_94:
;  420		{
;  421			
;  422			GetRayToFaceIntersection(ray, &(faceArray[i]), &hitpoint, &didhit);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	(IX+-14),HL
	PEA	IX+-8
	PEA	IX+-26
	LD	BC,(_faceArray)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_GetRayToFaceIntersection
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  423			
;  424			//if successfully hit something
;  425			if (didhit)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_93
;  426			{
;  427				
;  428				*hitOrNot = true;
	LD	HL,(IX+12)
;  429				dist = distanceBetween(ray->origin, hitpoint);
	PEA	IX+-26
	LD	(HL),1
	LD	IY,(IX+6)
	PEA	IY+0
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-18),HL
	LD	(IX+-15),E
;  430				//if closer than closest face so far, set face that its currently checking to be the closest face
;  431				if (dist < closestDist)
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	CALL	__fcmp
	JP	P,L_93
;  432				{
;  433					closestDist = dist;
	LD	BC,(IX+-18)
	LD	A,(IX+-15)
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  434					outface = &(faceArray[i]);
	LD	BC,(IX+-14)
	LD	HL,(_faceArray)
	ADD	HL,BC
	LD	(IX+-11),HL
;  435				}
;  436			}
L_93:
;  437			
;  438			//*distance = closestDist;
;  439			//if closest dist was changed
;  440			if (closestDist < 999999)
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,7611376
	LD	A,73
	CALL	__fcmp
	JP	P,L_95
;  441			{
;  442				
;  443				*hitOrNot = true;
	LD	HL,(IX+12)
	LD	(HL),1
;  444				*distance = closestDist;
	LD	HL,(IX+9)
	LD	BC,(IX+-7)
	LD	A,(IX+-4)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  445				return outface;
	LD	HL,(IX+-11)
	JR	L_99
;  446			}
;  447		}
L_95:
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_96:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JP	M,L_94
;  448		
;  449		return outface;
	LD	HL,(IX+-11)
;  450	}
L_99:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _ClosestFace ***************************
;Name                         Addr/Register   Size   Type
;_faceArrayCurrentSize               STATIC      3   variable
;_distanceBetween                    IMPORT  -----   function
;_faceArray                          STATIC      3   variable
;_GetRayToFaceIntersection           IMPORT  -----   function
;hitpoint                             IX-26      8   variable
;dist                                 IX-18      4   variable
;G_4                                  IX-14      3   variable
;outface                              IX-11      3   variable
;didhit                                IX-8      1   variable
;closestDist                           IX-7      4   variable
;i                                     IX-3      3   variable
;hitOrNot                             IX+12      3   parameter
;distance                              IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 41 (bytes)
;       Spill Code: -1 (instruction)


;  451	
;  452	//outputs whether or not a ray hit a certain face, and if so the distance
;  453	void GetRayToFaceIntersection(Ray * ray, Face * face, float * result, bool * hit)
;  454	{
_GetRayToFaceIntersection:
	LD	HL,-72
	CALL	__frameset
;  455		float v1[2] = {0,0};
	LEA	DE,IX+-14
	LD	HL,_0temp100
	LD	BC,8
	LDIR	
;  456		float v2[2]= {0,0};
	LEA	DE,IX+-22
	LD	HL,_1temp101
	LD	BC,8
	LDIR	
;  457		float v3[2]= {0,0};
	LEA	DE,IX+-30
	LD	HL,_2temp102
	LD	BC,8
	LDIR	
;  458		float tOne = 0;
;  459		float tTwo = 0;
;  460		float dot = 0;
;  461		v1[0] =(ray->origin[0] - face->point1[0]);
	LD	IY,(IX+9)
	LEA	BC,IY+0
	LD	(IX+-6),BC
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+6)
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-14),BC
	LD	(IX+-11),A
;  462		v1[1] = (ray->origin[1] - face->point1[1]);
	LD	IY,(IX+-6)
	LEA	BC,IY+4
	LD	(IX+-3),BC
	LD	IY,(IX+6)
	LEA	BC,IY+4
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-14
	LD	(IY+4),BC
	LD	(IY+7),A
;  463		v2[0] = (face->point2[0] - face->point1[0]);
	LD	IY,(IX+-6)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,(IX+9)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fsub
	LD	(IX+-22),BC
	LD	(IX+-19),A
;  464		v2[1]= (face->point2[1] - face->point1[1]);
	LEA	BC,IY+12
	LD	IY,(IX+-3)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LEA	IY,IX+-22
	LD	(IY+4),BC
	LD	(IY+7),A
;  465		v3[0] = -(ray->direction[1]);
	LD	IY,(IX+6)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fneg
	LD	(IX+-30),BC
	LD	(IX+-27),A
;  466		v3[1] = (ray->direction[0]);
	LD	(IX+-45),BC	; spill
	LEA	HL,IX+-26
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	BC,(IY+8)
	LD	A,(IY+11)
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),BC
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
;  467		dot = (v2[0] * v3[0]) + (v2[1] * v3[1]);
	LD	(IX+-51),HL	; spill
	LEA	HL,IX+-18
	LD	(IX+-54),HL	; spill
	LD	HL,(IX+-51)	; unspill
	LEA	IY,IX+-30
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	INC	HL
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-45),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(HL),A
	LD	HL,(IX+-45)	; unspill
	LD	E,(IX+-27)
	LD	BC,(IX+-22)
	LD	A,(IX+-19)
	CALL	__fmul
	LD	(IX+-71),BC
	LD	(IX+-72),A
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-51),HL	; spill
	LD	IY,(IX+-54)
	LD	HL,(IX+-51)	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	E,A
	LD	A,(IX+-72)
	LD	HL,BC
	LD	BC,(IX+-71)
	CALL	__fadd
	LD	(IX+-38),BC
	LD	(IX+-35),A
;  468		
;  469		*hit = false;
	LD	HL,(IX+15)
	LD	(HL),0
;  470		if (abs(dot) < 0.000001)
	LD	A,(IX+-35)
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	E,A
	LD	HL,BC
	LD	BC,8796093
	LD	A,53
	CALL	__fcmp
	JP	M,L_108
;  471		{
;  472			return;
;  473		}
;  474		tOne = ((v2[0] * v1[1]) - (v2[1] * v1[0])) / dot;
	LEA	IY,IX+-14
	LD	HL,(IX+-22)
	LD	E,(IX+-19)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	CALL	__fmul
	LD	(IX+-65),BC
	LD	HL,(IX+-14)
	LD	E,(IX+-11)
	LEA	IY,IX+-22
	LD	BC,(IY+4)
	LD	(IX+-62),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-65)
	LD	A,(IX+-62)
	CALL	__fsub
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-34),BC
	LD	(IX+-31),A
;  475		tTwo = ((v1[0] * v3[0])+ (v1[1] * v3[1])) / dot;
	LEA	HL,IX+-10
	LD	(IX+-61),HL	; spill
	LD	HL,(IX+-30)
	LD	E,(IX+-27)
	LD	BC,(IX+-14)
	LD	A,(IX+-11)
	CALL	__fmul
	LEA	IY,IX+-30
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	(IX+-45),HL	; spill
	LD	IY,(IX+-61)
	LD	HL,(IX+-45)	; unspill
	LD	(IX+-58),BC
	LD	(IX+-55),A
	LD	A,(IY+3)
	LD	BC,(IY)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-58)
	LD	A,(IX+-55)
	CALL	__fadd
	LD	HL,(IX+-38)
	LD	E,(IX+-35)
	CALL	__fdiv
	LD	(IX+-42),BC
	LD	(IX+-39),A
;  476		
;  477		if (tOne>0.0 && (tTwo >=0.0 && tTwo <= 1.0))
	LD	BC,(IX+-34)
	LD	A,(IX+-31)
	OR	A,A
	SBC	HL,HL
	LD	E,0
	CALL	__fcmp
	JP	P,L_108
	LD	HL,(IX+-42)
	LD	E,(IX+-39)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	M,L_108
	LD	HL,8388608
	LD	E,63
	LD	BC,(IX+-42)
	LD	A,(IX+-39)
	CALL	__fcmp
	JP	M,L_108
;  478		{
;  479			
;  480			*hit = true;
	LD	HL,(IX+15)
	LD	(HL),1
;  481			
;  482			//tOne is distance to point1
;  483			//multiply by normalized direction and add to origin to get point
;  484			(result)[0] = ray->origin[0] + (ray->direction[0] * tOne);
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	IY,(IX+6)
	LD	BC,(IY+8)
	LD	A,(IY+11)
	CALL	__fmul
	LD	HL,BC
	LD	BC,(IY+0)
	LD	E,A
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY),BC
	LD	(IY+3),A
;  485			(result)[1] = ray->origin[1] + (ray->direction[1] * tOne);
	LD	IY,(IX+6)
	LEA	HL,IY+4
	LD	(IX+-68),HL	; spill
	LD	HL,(IX+-34)
	LD	E,(IX+-31)
	LD	BC,(IY+12)
	LD	A,(IY+15)
	CALL	__fmul
	LD	E,A
	LD	(IX+-45),BC	; spill
	LD	IY,(IX+-68)
	LD	HL,BC	; unspill
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fadd
	LD	IY,(IX+12)
	LD	(IY+4),BC
	LD	(IY+7),A
;  486			
;  487		}
;  488		
;  489	}
L_108:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _GetRayToFaceIntersection ***************************
;Name                         Addr/Register   Size   Type
;_abs                                IMPORT  -----   function
;_2temp102                           STATIC      8   variable
;_1temp101                           STATIC      8   variable
;_0temp100                           STATIC      8   variable
;tTwo                                 IX-42      4   variable
;dot                                  IX-38      4   variable
;tOne                                 IX-34      4   variable
;v3                                   IX-30      8   variable
;v2                                   IX-22      8   variable
;v1                                   IX-14      8   variable
;hit                                  IX+15      3   parameter
;result                               IX+12      3   parameter
;face                                  IX+9      3   parameter
;ray                                   IX+6      3   parameter


; Stack Frame Size: 90 (bytes)
;       Spill Code: -4 (instruction)


	SEGMENT TEXT
_0temp100:
	DF	0.0
	DF	0.0
_1temp101:
	DF	0.0
	DF	0.0
_2temp102:
	DF	0.0
	DF	0.0
	SEGMENT CODE
;  490	
;  491	
;  492	
;  493	//copied from online, changes a float into a string
;  494	#include <stdio.h>
;  495	#define PSH(X) (*(buf++)=(X))
;  496	#define PSH1(X) (*(buf--)=(X))
;  497	#define PEEK() buf[-1]
;  498	#define POP() *(--buf) = '\0'
;  499	#define PLUS 1
;  500	#define SPACE 2
;  501	char * gcvt(double f, size_t ndigit, char * buf)
;  502	{
_gcvt:
	LD	HL,-44
	CALL	__frameset
;  503	  int i;
;  504		unsigned long z,k;
;  505	  int exp = 0;
;  506	  char *c = buf;
	LD	BC,(IX+15)
	LD	(IX+-14),BC
;  507	  double f2,t,scal;
;  508	  int   sign = 0;
	LD	BC,0
	LD	(IX+-21),BC
;  509	
;  510	  if((int)ndigit == -1)
	LD	HL,(IX+12)
	LD	BC,16777215
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_111
;  511	    ndigit = 5;
	LD	BC,5
	LD	(IX+12),BC
L_111:
;  512	
;  513	  /* Unsigned long long only allows for 20 digits of precision
;  514	   * which is already more than double supports, so we limit the
;  515	   * digits to this.  long double might require an increase if it is ever
;  516	   * implemented.
;  517	   */
;  518	  if (ndigit > 20)
	LD	BC,(IX+12)
	LD	HL,20
	OR	A,A
	SBC	HL,BC
	JR	NC,L_114
;  519		  ndigit = 20;
	LD	BC,20
	LD	(IX+12),BC
L_114:
;  520	  
;  521	  if (f < 0.0) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,0
	XOR	A,A
	CALL	__fcmp
	JP	P,L_115
;  522	    sign = 1;
	LD	BC,1
	LD	(IX+-21),BC
;  523	    f = -f;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fneg
	LD	(IX+6),BC
	LD	(IX+9),A
;  524		 buf++;
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  525	  }
L_115:
;  526	
;  527	  scal = 1;
	LD	BC,8388608
	LD	(IX+-11),BC
	LD	A,63
	LD	(IX+-8),A
;  528	  for (i=ndigit; i>0; i--)
	LD	BC,(IX+12)
	LD	(IX+-3),BC
	JR	L_119
L_117:
;  529		  scal *= 10;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+-11)
	LD	A,(IX+-8)
	CALL	__fmul
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LD	BC,(IX+-3)
	DEC	BC
	LD	(IX+-3),BC
L_119:
	LD	BC,(IX+-3)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_117
;  530	  k = f + 0.1 / scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,13421773
	LD	A,61
	CALL	__fdiv
	LD	HL,(IX+6)
	LD	E,(IX+9)
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-7),BC
	LD	(IX+-4),A
;  531	  f2 = f - k;
	CALL	__ultof
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fsub
	LD	(IX+-29),BC
	LD	(IX+-26),A
;  532	  if (!f) {
	LD	HL,(IX+6)
	LD	E,(IX+9)
	XOR	A,A
	LD	BC,0
	CALL	__fcmp
	JR	NZ,L_133
;  533	    PSH('0');
	LD	HL,(IX+15)
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
;  534	    if(ndigit > 0)
	LD	BC,(IX+12)
	OR	A,A
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_129
;  535	      PSH('.');
	LD	HL,(IX+15)
	LD	(HL),46
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
L_129:
;  536	    for (i=0;i<ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_128
L_126:
;  537	      PSH('0');
	LD	BC,(IX+15)
	LD	(IX+-32),BC
	LD	HL,BC
	LD	(HL),48
	LD	BC,(IX+15)
	INC	BC
	LD	(IX+15),BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
L_128:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_126
;  538	  	   PSH(0);
	LD	BC,(IX+15)
	LD	(IX+-35),BC
	LD	HL,BC
	LD	(HL),0
;  539	  	 return c;
	LD	HL,(IX+-14)
	JR	L_157
;  540	  }
L_133:
;  541	
;  542	  i = 1;
	LD	BC,1
	LD	(IX+-3),BC
;  543	  while (f >= 10.0) {
	JR	L_135
L_136:
;  544	  	f /= 10.0;
	LD	HL,2097152
	LD	E,65
	LD	BC,(IX+6)
	LD	A,(IX+9)
	CALL	__fdiv
	LD	(IX+6),BC
	LD	(IX+9),A
;  545	  	i++;
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  546	  }
L_135:
	LD	HL,(IX+6)
	LD	E,(IX+9)
	LD	BC,2097152
	LD	A,65
	CALL	__fcmp
	JP	P,L_136
;  547	
;  548	  buf += i + ndigit + 1; 	
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,(IX+15)
	ADD	HL,BC
	LD	(IX+15),HL
;  549	
;  550	  PSH1(0);
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  551	
;  552	  if(ndigit > 0) {	
	OR	A,A
	LD	BC,(IX+12)
	OR	A,A
	SBC	HL,HL
	SBC	HL,BC
	JR	NC,L_148
;  553		  t = f2 * scal;
	LD	HL,(IX+-11)
	LD	E,(IX+-8)
	LD	BC,(IX+-29)
	LD	A,(IX+-26)
	CALL	__fmul
	LD	(IX+-25),BC
	LD	(IX+-22),A
	OR	A,A
;  554		 z = t + 0.5;
	SBC	HL,HL
	LD	E,63
	CALL	__fadd
	CALL	__ftol
	LD	(IX+-18),BC
	LD	(IX+-15),A
;  555	    for (i = 0;i < ndigit;i++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_143
L_141:
;  556	    {
;  557	      PSH1('0'+ (z % 10));
	LD	BC,(IX+15)
	LD	(IX+-38),BC
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-38)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  558		   z /= 10;
	LD	HL,(IX+-18)
	LD	E,(IX+-15)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-18),HL
	LD	(IX+-15),E
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  559	    }
L_143:
	LD	BC,(IX+12)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	JR	C,L_141
;  560	    PSH1('.');
	LD	BC,(IX+15)
	LD	(IX+-41),BC
	LD	HL,BC
	LD	(HL),46
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  561	  }
;  562	  else
	JR	L_150
L_148:
;  563	    PSH1(0);
	LD	HL,(IX+15)
	LD	(HL),0
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  564	
;  565	  do {
L_150:
;  566	    PSH1('0'+ (k % 10));
	LD	BC,(IX+15)
	LD	(IX+-44),BC
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	LD	BC,10
	XOR	A,A
	CALL	__lremu
	LD	BC,HL
	LD	A,C
	ADD	A,48
	LD	HL,(IX+-44)
	LD	(HL),A
	LD	IY,(IX+15)
	LEA	IY,IY+-1
	LD	(IX+15),IY
;  567	    k /= 10;
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	XOR	A,A
	LD	BC,10
	CALL	__ldivu
	LD	(IX+-7),HL
	LD	(IX+-4),E
;  568	  }while (k);
	LD	HL,(IX+-7)
	LD	E,(IX+-4)
	CALL	__lcmpzero
	JR	NZ,L_150
;  569	
;  570	  if (sign)
	LD	HL,(IX+-21)
	CALL	__icmpzero
	JR	Z,L_156
;  571	    PSH1('-');
	LD	HL,(IX+15)
	LD	(HL),45
L_156:
;  572	  return c;
	LD	HL,(IX+-14)
;  573	}
L_157:
	LD	SP,IX
	POP	IX
	RET	


;**************************** _gcvt ***************************
;Name                         Addr/Register   Size   Type
;f2                                   IX-29      4   variable
;t                                    IX-25      4   variable
;sign                                 IX-21      3   variable
;z                                    IX-18      4   variable
;c                                    IX-14      3   variable
;scal                                 IX-11      4   variable
;k                                     IX-7      4   variable
;i                                     IX-3      3   variable
;buf                                  IX+15      3   parameter
;ndigit                               IX+12      3   parameter
;f                                     IX+6      4   parameter


; Stack Frame Size: 62 (bytes)
;       Spill Code: -4 (instruction)


;  574	
;  575	 //draws the map in the top right corner
;  576	 void drawMap()
;  577	 {
_drawMap:
	LD	HL,-44
	CALL	__frameset
;  578		 float lookview[2];
;  579		int face = 0;
;  580		float scale = 1.25;
;  581		lookview[0] = lookDirection[0];
	LD	BC,(_lookDirection)
	LD	A,(_lookDirection+3)
;  582		lookview[1] = lookDirection[1];
	LD	HL,_lookDirection+4
	LD	(IX+-11),BC
	LD	(IX+-8),A
	LEA	IY,IX+-11
;  583		//draw map box
;  584		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IY+4),BC
	LD	(IY+7),A
	CALL	_gfx_SetColor
	POP	BC
;  585		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  586		gfx_Line_NoClip(LCD_WIDTH -5, 5, LCD_WIDTH - 50, 5);
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,315
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  587		gfx_Line_NoClip(LCD_WIDTH -50, 5, LCD_WIDTH - 50, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	LD	BC,5
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  588		gfx_Line_NoClip(LCD_WIDTH -50, 50, LCD_WIDTH - 5, 50);
	LD	BC,50
	PUSH	BC
	LD	BC,315
	PUSH	BC
	LD	BC,50
	PUSH	BC
	LD	BC,270
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  589	
;  590		//draw faces
;  591		for (face = 0; face < faceArrayCurrentSize; face++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_161
L_159:
;  592		{
;  593			gfx_SetColor(faceArray[face].color);
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	IY,HL
	LD	C,(IY+16)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  594			gfx_Line_NoClip(faceArray[face].point1[0] * scale + LCD_WIDTH-25,  faceArray[face].point1[1]* -scale + 25,  faceArray[face].point2[0]* scale+ LCD_WIDTH-25,  faceArray[face].point2[1]* -scale + 25 );
	LD	HL,(IX+-3)
	LD	A,17
	CALL	__imul_b
	LD	BC,(_faceArray)
	ADD	HL,BC
	LD	(IX+-20),HL
	LD	IY,(IX+-20)
	LEA	BC,IY+8
	LD	(IX+-17),BC
	LEA	BC,IY+0
	LD	(IX+-14),BC
	LD	IY,(IX+-17)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	IY,(IX+-14)
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IY)
	LD	A,(IY+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  595		
;  596		}
L_161:
	LD	BC,(_faceArrayCurrentSize)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_159
;  597	
;  598		//draw player
;  599		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25 - 1,  playerPosition[1]* -scale +25,  playerPosition[0]* scale + LCD_WIDTH-25 + 1, playerPosition[1]* -scale +25);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-34),BC
	LD	(IX+-44),A
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,9699328
	LD	E,67
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-34)
	LD	A,(IX+-44)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13631488
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  600		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1]* -scale +25 -1,  playerPosition[0]* scale + LCD_WIDTH-25, playerPosition[1]* -scale +25 +1);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	(IX+-31),BC
	LD	(IX+-43),A
	LD	HL,13631488
	LD	E,65
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-31)
	LD	A,(IX+-43)
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	HL,8388608
	LD	E,63
	CALL	__fsub
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  601		
;  602		//draw view
;  603		gfx_SetColor(245);
	LD	BC,245
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
	OR	A,A
;  604		rotateVector(&lookview, fov/2);
	SBC	HL,HL
	LD	E,64
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fdiv
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  605		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-27),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-28),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-28)
	LD	HL,(IX+-27)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-41),BC
	LD	(IX+-42),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-41)
	LD	A,(IX+-42)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-27)
	LD	A,(IX+-28)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  606		rotateVector(&lookview, -fov);
	LD	BC,(_fov)
	LD	A,(_fov+3)
	CALL	__fneg
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	PEA	IX+-11
	CALL	_rotateVector
	POP	BC
	POP	BC
	POP	BC
;  607		gfx_Line_NoClip(playerPosition[0]* scale + LCD_WIDTH-25,  playerPosition[1] * -scale + 25,   playerPosition[0]* scale + LCD_WIDTH-25 + lookview[0] * scale * 4 ,  playerPosition[1]* -scale + 25 + lookview[1] * -scale * 4);
	LD	IY,_playerPosition
	LD	BC,(IY+4)
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,191
	CALL	__fmul
	LD	HL,13107200
	LD	E,65
	CALL	__fadd
	LD	(IX+-23),BC
	LEA	IY,IX+-11
	LD	BC,(IY+4)
	LD	(IX+-24),A
	LD	A,(IY+7)
	LD	HL,10485760
	LD	E,192
	CALL	__fmul
	LD	E,(IX+-24)
	LD	HL,(IX+-23)
	CALL	__fadd
	CALL	__ftol
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	LD	(IX+-37),BC
	LD	(IX+-38),A
	LD	A,(IX+-8)
	LD	BC,(IX+-11)
	LD	HL,10485760
	LD	E,64
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-37)
	LD	A,(IX+-38)
	CALL	__fadd
	CALL	__ftol
	PUSH	BC
	LD	BC,(IX+-23)
	LD	A,(IX+-24)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	HL,10485760
	LD	E,63
	CALL	__fmul
	LD	HL,10485760
	LD	E,67
	CALL	__fadd
	LD	HL,13107200
	LD	E,65
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_gfx_Line_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  608		
;  609	 }
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawMap ***************************
;Name                         Addr/Register   Size   Type
;_fov                                STATIC      4   variable
;_rotateVector                       IMPORT  -----   function
;_playerPosition                     STATIC      8   variable
;_faceArrayCurrentSize               STATIC      3   variable
;_faceArray                          STATIC      3   variable
;_gfx_Line_NoClip                    IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;lookview                             IX-11      8   variable
;face                                  IX-3      3   variable


; Stack Frame Size: 50 (bytes)
;       Spill Code: -4 (instruction)


;  610	
;  611	//draws the sprites on the screen (not the gun sprite)
;  612	void drawObjects()
;  613	{
_drawObjects:
	LD	HL,-77
	CALL	__frameset
;  614		
;  615		int num =0;
;  616		float dot;
;  617		float dist;
;  618		float distToFace;
;  619		bool hit;
;  620		int scale;
;  621		float angleFromCenter=0;
	LD	BC,0
	LD	(IX+-12),BC
	XOR	A,A
	LD	(IX+-9),A
;  622		Ray testRay;
;  623		float toObject[2];
;  624		for (num = 0; num<numberOfObjects; num++)
	LD	(IX+-7),BC
	JR	L_171
L_169:
;  625		{
;  626			
;  627			toObject[0] = objectArray[num].position[0] - playerPosition[0];
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	(IX+-46),HL
	LD	IY,(IX+-46)
	LD	HL,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	E,A
	LD	BC,(IY+0)
	LD	A,(IY+3)
	CALL	__fsub
	LD	(IX+-20),BC
;  628			toObject[1] = objectArray[num].position[1] - playerPosition[1];
	LEA	BC,IX+-16
	LD	(IX+-17),A
	LD	(IX+-43),BC
	LEA	BC,IY+4
	LD	IY,_playerPosition
	LD	HL,(IY+4)
	LD	E,(IY+7)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fsub
	LD	IY,(IX+-43)
	LD	(IY),BC
	LD	(IY+3),A
;  629			dot = (lookDirection[0] * toObject[0]) + (lookDirection[1] * toObject[1]);
	LD	BC,_lookDirection+4
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	IY,BC
	LD	BC,(IY)
	LD	A,(IY+3)
	CALL	__fmul
	LD	(IX+-72),BC
	LD	(IX+-73),A
;  630	
;  631			//get the angle of the sprite from the center 
;  632			angleFromCenter = -atan2((lookDirection[0]) *toObject[1] - (lookDirection[1]) * toObject[0], (lookDirection[0]) * toObject[0] + (lookDirection[1]) * toObject[1]);
	LD	A,(_lookDirection+3)
	LD	BC,(_lookDirection)
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	CALL	__fmul
	LD	E,(IX+-73)
	LD	HL,(IX+-72)
	CALL	__fadd
	LD	DE,BC
	LD	C,A
	LD	A,(_lookDirection+3)
	LD	B,0
	PUSH	BC
	PUSH	DE
	LD	IY,(IX+-43)
	LD	HL,(IY)
	LD	E,(IY+3)
	LD	BC,(_lookDirection)
	CALL	__fmul
	LD	(IX+-76),BC
	LD	HL,(IX+-20)
	LD	E,(IX+-17)
	LD	IY,_lookDirection
	LD	BC,(IY+4)
	LD	(IX+-77),A
	LD	A,(IY+7)
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-76)
	LD	A,(IX+-77)
	CALL	__fsub
	LD	DE,BC
	LD	C,A
	LD	B,0
	PUSH	BC
	PUSH	DE
	CALL	_atan2
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	CALL	__fneg
	LD	(IX+-12),BC
	LD	(IX+-9),A
;  633			
;  634			if (floatAbs(angleFromCenter) <= (fov/2))
	LD	BC,(_fov)
	LD	A,(_fov+3)
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	(IX+-68),BC
	LD	C,(IX+-9)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	PUSH	BC
	LD	(IX+-69),A
	CALL	_floatAbs
	POP	BC
	POP	BC
	LD	A,E
	LD	BC,HL
	LD	HL,(IX+-68)
	LD	E,(IX+-69)
	CALL	__fcmp
	JP	M,L_170
;  635			{
;  636				//get distance to object
;  637				dist = (distanceBetween(&playerPosition, &objectArray[num].position));
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+0
	LD	BC,_playerPosition
	PUSH	BC
	CALL	_distanceBetween
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  638				//cast ray to nearest face and compare with distance to object
;  639				testRay.origin[0] = playerPosition[0];
	LEA	BC,IX+-40
	LD	(IX+-52),BC
	LD	HL,BC
	LD	BC,(_playerPosition)
	LD	A,(_playerPosition+3)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  640				testRay.origin[1] = playerPosition[1];
	LD	IY,_playerPosition
	LEA	IY,IY+4
	LD	(IX+-61),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-61)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	INC	IY
	LD	(IX+-61),IY	; spill
	LD	IY,(IX+-52)
	LEA	HL,IY+4
	LD	IY,(IX+-61)	; unspill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  641				testRay.direction[0] = toObject[0];
	LEA	BC,IX+-32
	LD	(IX+-49),BC
	LD	HL,BC
	LD	BC,(IX+-20)
	LD	A,(IX+-17)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
;  642				testRay.direction[1] = toObject[1];
	LEA	IY,IX+-16
	LD	(IX+-58),IY	; spill
	LD	(HL),A
	LD	IY,(IX+-49)
;  643				ClosestFace(&testRay, &distToFace, &hit);
	PEA	IX+-8
	PEA	IX+-24
	PEA	IX+-40
	LEA	HL,IY+4
	LD	IY,(IX+-58)	; unspill
	LD	BC,(IY)
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	INC	IY
	LD	(IX+-58),IY	; spill
	LD	A,(IY)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
	CALL	_ClosestFace
	POP	BC
	POP	BC
	POP	BC
;  644				if (hit && dist >distToFace)
	LD	A,(IX+-8)
	OR	A,A
	JR	Z,L_167
	LD	HL,(IX+-24)
	LD	E,(IX+-21)
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fcmp
	JP	M,L_170
;  645				{
;  646					//if the ray hit a face and that face is closer than the object, skip drawing it (it's obscured).
;  647					continue;
;  648				}
L_167:
;  649	
;  650				//change distance to the scale factor
;  651				dist =abs(1/((dist+3) *0.025)-2);
	LD	HL,4194304
	LD	E,64
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fadd
	LD	HL,13421773
	LD	E,60
	CALL	__fmul
	LD	E,A
	LD	HL,BC
	LD	BC,8388608
	LD	A,63
	CALL	__fdiv
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	CALL	_abs
	POP	BC
	LD	BC,HL
	CALL	__itol
	CALL	__ltof
	LD	(IX+-4),BC
;  652				//limit dist to a minimum scale of 1
;  653				dist = max(dist,1);
	LD	C,63
	LD	B,0
	LD	(IX+-1),A
	PUSH	BC
	LD	BC,8388608
	PUSH	BC
	LD	C,(IX+-1)
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	PUSH	BC
	CALL	_max
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-4),HL
	LD	(IX+-1),E
;  654				//set the color pallete
;  655				gfx_SetPalette(gfx_group_pal, sizeof_gfx_group_pal,0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_gfx_group_pal
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  656				//draw the scaled sprite.
;  657				gfx_ScaledTransparentSprite_NoClip(objectArray[num].sprite, (LCD_WIDTH/2) + (angleFromCenter *100 * fov) - (enemy1_width *dist)/2 ,LCD_HEIGHT/2 - (enemy1_height *dist)/2 ,dist,dist);
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	HL,12058624
	LD	E,65
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__ftol
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-4)
	LD	A,(IX+-1)
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,15728640
	LD	A,66
	CALL	__fsub
	CALL	__ftol
	LD	HL,13107200
	LD	E,66
	LD	B,0
	PUSH	BC
	LD	BC,(IX+-12)
	LD	A,(IX+-9)
	CALL	__fmul
	LD	H,A
	LD	A,(_fov+3)
	LD	E,A
	LD	A,H
	LD	HL,(_fov)
	CALL	__fmul
	LD	HL,2097152
	LD	E,67
	CALL	__fadd
	LD	(IX+-64),BC
	LD	(IX+-65),A
	LD	A,(IX+-1)
	LD	BC,(IX+-4)
	LD	HL,7340032
	LD	E,65
	CALL	__fmul
	OR	A,A
	SBC	HL,HL
	LD	E,64
	CALL	__fdiv
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+-64)
	LD	A,(IX+-65)
	CALL	__fsub
	CALL	__ftol
	PUSH	BC
	LD	HL,(IX+-7)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_gfx_ScaledTransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  658				
;  659			}
;  660		}
L_170:
	LD	BC,(IX+-7)
	INC	BC
	LD	(IX+-7),BC
L_171:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-7)
	OR	A,A
	SBC	HL,BC
	JP	M,L_169
;  661		
;  662	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _drawObjects ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_gfx_ScaledTransparentSprite_NoClip      IMPORT  -----   function
;_gfx_group_pal                      IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_max                                IMPORT  -----   function
;_abs                                IMPORT  -----   function
;_ClosestFace                        IMPORT  -----   function
;_distanceBetween                    IMPORT  -----   function
;_floatAbs                           IMPORT  -----   function
;_fov                                STATIC      4   variable
;_atan2                              IMPORT  -----   function
;_lookDirection                      STATIC      8   variable
;_playerPosition                     STATIC      8   variable
;_objectArray                        STATIC      3   variable
;testRay                              IX-40     16   variable
;distToFace                           IX-24      4   variable
;toObject                             IX-20      8   variable
;angleFromCenter                      IX-12      4   variable
;hit                                   IX-8      1   variable
;num                                   IX-7      3   variable
;dist                                  IX-4      4   variable


; Stack Frame Size: 83 (bytes)
;       Spill Code: -11 (instruction)


;  663	
;  664	//creates and mallocs a face, and returns a pointer to it
;  665	Face * mallocAndGenerateFace(float  point1x, float  point1y, float point2x, float point2y, uint8_t colorIndex)
;  666	{
_mallocAndGenerateFace:
	LD	HL,-6
	CALL	__frameset
;  667		Face * newFace = malloc(sizeof(Face));
	LD	BC,17
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+-6),HL
;  668		newFace->point1[0] = point1x;
	LD	BC,(IX+6)
	LD	A,(IX+9)
	LD	IY,(IX+-6)
	LD	(IY+0),BC
	LD	(IY+3),A
;  669		newFace->point1[1] = point1y;
	LEA	HL,IY+4
	LD	BC,(IX+12)
	LD	A,(IX+15)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  670		newFace->point2[0] = point2x;
	LEA	BC,IY+8
	LD	(IX+-3),BC
	LD	BC,(IX+18)
	LD	A,(IX+21)
	LD	(IY+8),BC
	LD	(IY+11),A
;  671		newFace->point2[1] = point2y;
	LD	IY,(IX+-3)
	LEA	HL,IY+4
	LD	BC,(IX+24)
	LD	A,(IX+27)
	LD	(HL),BC
	INC	HL
	INC	HL
	INC	HL
	LD	(HL),A
;  672		newFace->color = colorIndex;
	LD	A,(IX+30)
	LD	IY,(IX+-6)
	LD	(IY+16),A
;  673		return newFace;
	LD	HL,(IX+-6)
;  674	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _mallocAndGenerateFace ***************************
;Name                         Addr/Register   Size   Type
;_malloc                             IMPORT  -----   function
;newFace                               IX-6      3   variable
;colorIndex                           IX+30      1   parameter
;point2y                              IX+24      4   parameter
;point2x                              IX+18      4   parameter
;point1y                              IX+12      4   parameter
;point1x                               IX+6      4   parameter


; Stack Frame Size: 39 (bytes)
;       Spill Code: -11 (instruction)


;  675	
;  676	
;  677	void loadLevel()
;  678	{
_loadLevel:
	LD	HL,-11
	CALL	__frameset
;  679		Object newObj;
;  680		numberOfObjects++;
	LD	BC,(_numberOfObjects)
	INC	BC
	LD	(_numberOfObjects),BC
;  681		//alloc object array
;  682		objectArray = malloc(sizeof(Object) * numberOfObjects);
	LD	HL,(_numberOfObjects)
	LD	A,11
	CALL	__imul_b
	PUSH	HL
	CALL	_malloc
	POP	BC
;  683		//malloc sprite image
;  684		enemy1Sprite = gfx_MallocSprite(enemy1_width,enemy1_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	(_objectArray),HL
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(_enemy1Sprite),HL
;  685		//decompress sprite image
;  686		zx7_Decompress(enemy1Sprite, enemy1_compressed);
	LD	BC,_enemy1_compressed
	PUSH	BC
	LD	BC,(_enemy1Sprite)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  687		newObj.sprite =  enemy1Sprite;
	LD	BC,(_enemy1Sprite)
	LD	(IX+-3),BC
;  688		
;  689		//set position
;  690		newObj.position[0] = -2;
	LD	BC,0
	LD	(IX+-11),BC
	LD	A,192
	LD	(IX+-8),A
;  691		newObj.position[1] = 2;
	LEA	IY,IX+-11
;  692		//add to array
;  693		objectArray[0] =newObj;
	LEA	HL,IX+-11
	LD	(IY+4),BC
	LD	(IY+7),64
	LD	DE,(_objectArray)
	LD	BC,11
	LDIR	
;  694		
;  695		
;  696	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _loadLevel ***************************
;Name                         Addr/Register   Size   Type
;_enemy1_compressed                  IMPORT    258   variable
;_zx7_Decompress                     IMPORT  -----   function
;_enemy1Sprite                       STATIC      3   variable
;_gfx_AllocSprite                    IMPORT  -----   function
;_objectArray                        STATIC      3   variable
;_malloc                             IMPORT  -----   function
;_numberOfObjects                    STATIC      3   variable
;newObj                               IX-11     11   variable


; Stack Frame Size: 17 (bytes)
;       Spill Code: -11 (instruction)


;  697	
;  698	//frees all of the objects' sprites
;  699	void unloadLevel()
;  700	{
_unloadLevel:
	LD	HL,-3
	CALL	__frameset
;  701		int j =0;
;  702		for (j=0;j<numberOfObjects;j++)
	LD	BC,0
	LD	(IX+-3),BC
	JR	L_179
L_177:
;  703		{
;  704			free(objectArray[j].sprite);
	LD	HL,(IX+-3)
	LD	A,11
	CALL	__imul_b
	LD	BC,(_objectArray)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+8)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	BC,(IX+-3)
	INC	BC
	LD	(IX+-3),BC
;  705		}
L_179:
	LD	BC,(_numberOfObjects)
	LD	HL,(IX+-3)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_177
;  706		free(objectArray);
	LD	BC,(_objectArray)
	PUSH	BC
	CALL	_free
	POP	BC
;  707	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _unloadLevel ***************************
;Name                         Addr/Register   Size   Type
;_numberOfObjects                    STATIC      3   variable
;_objectArray                        STATIC      3   variable
;_free                               IMPORT  -----   function
;j                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: -11 (instruction)


;  708	
;  709	void printText(const char *text, uint8_t xpos, uint8_t ypos) {
_printText:
	CALL	__frameset0
;  710	    os_SetCursorPos(ypos, xpos);
	LD	C,(IX+9)
	LD	B,0
	PUSH	BC
	LD	C,(IX+12)
	PUSH	BC
	CALL	_os_SetCursorPos
	POP	BC
	POP	BC
;  711	    os_PutStrFull(text);
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_PutStrFull
	POP	BC
;  712	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printText ***************************
;Name                         Addr/Register   Size   Type
;_os_PutStrFull                      IMPORT  -----   function
;_os_SetCursorPos                    IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


;  713	
;  714	// Draw small text at the given X/Y location 
;  715	void printTextSmall(const char *text, uint8_t xpos, uint8_t ypos) {
_printTextSmall:
	CALL	__frameset0
;  716	    os_FontSelect(0); // sets small font (1 == big, see docs)
	LD	BC,0
	PUSH	BC
	CALL	_os_FontSelect
	POP	BC
;  717	    os_FontDrawText(text, xpos, ypos);
	LD	C,(IX+12)
	LD	B,0
	PUSH	BC
	LD	C,(IX+9)
	PUSH	BC
	LD	BC,(IX+6)
	PUSH	BC
	CALL	_os_FontDrawText
	POP	BC
	POP	BC
	POP	BC
;  718	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _printTextSmall ***************************
;Name                         Addr/Register   Size   Type
;_os_FontDrawText                    IMPORT  -----   function
;_os_FontSelect                      IMPORT  -----   function
;ypos                                 IX+12      1   parameter
;xpos                                  IX+9      1   parameter
;text                                  IX+6      3   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: -11 (instruction)


	XREF _rotateVector:ROM
	XREF _distanceBetween:ROM
	XREF _fastCos:ROM
	XREF _floatAbs:ROM
	XREF _max:ROM
	XREF _gfx_group_pal:ROM
	XREF _enemy1_compressed:ROM
	XREF _doomak2_compressed:ROM
	XREF _zx7_Decompress:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_ScaledTransparentSprite_NoClip:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintString:ROM
	XREF _gfx_Blit:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle_NoClip:ROM
	XREF _gfx_Line_NoClip:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _calloc:ROM
	XREF _sqrt:ROM
	XREF _atan2:ROM
	XREF _asm_DrawStatusBar:ROM
	XREF _asm_ClrLCD:ROM
	XREF _asm_HomeUp:ROM
	XREF __OS:ROM
	XREF _os_GetCSC:ROM
	XREF _os_PutStrFull:ROM
	XREF _os_FontDrawText:ROM
	XREF _os_FontSelect:ROM
	XREF _os_SetCursorPos:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __lremu:ROM
	XREF __fadd:ROM
	XREF __fsub:ROM
	XREF __fmul:ROM
	XREF __fdiv:ROM
	XREF __fneg:ROM
	XREF __fcmp:ROM
	XREF __ftol:ROM
	XREF __ltof:ROM
	XREF __ultof:ROM
	XREF __itol:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __imul_b:ROM
	XDEF _printTextSmall
	XDEF _printText
	XDEF _unloadLevel
	XDEF _loadLevel
	XDEF _mallocAndGenerateFace
	XDEF _drawObjects
	XDEF _drawMap
	XDEF _gcvt
	XDEF _GetRayToFaceIntersection
	XDEF _ClosestFace
	XDEF _draw
	XDEF _step
	XDEF _end
	XDEF _begin
	XDEF _main
	XDEF _enemy1Sprite
	XDEF _enemy1Sprite_data
	XDEF _akSprite
	XDEF _akSprite_data
	XDEF _nyiError
	XDEF _key
	XDEF _partial_redraw
	XDEF _objectArray
	XDEF _faceArray
	XDEF _FACEARRAYMAXSIZE
	XDEF _playerPosition
	XDEF _lookDirection
	XDEF _MAX_DISTANCE
	XDEF _RENDER_WIDTH
	XDEF _DISTANCE_FOG
	XDEF _fov
	XDEF _multiplier
	XDEF _focalLength
	XDEF _lineSpacing
	XDEF _freeLookupTable
	XDEF _lookupSqrt
	XDEF _generateLookupTable
	XDEF _lut
	END
